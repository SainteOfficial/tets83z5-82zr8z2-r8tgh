-- Performance Optimierungen am Anfang des Scripts
local function optimizePerformance()
    -- Reduziere Grafikqualität temporär
    settings().Rendering.QualityLevel = 3
    
    -- Deaktiviere unnötige Grafikeffekte
    local lighting = game:GetService("Lighting")
    local oldSettings = {
        GlobalShadows = lighting.GlobalShadows,
        Brightness = lighting.Brightness,
        Technology = lighting.Technology
    }
    
    lighting.GlobalShadows = false
    lighting.Brightness = 0.2
    lighting.Technology = Enum.Technology.Compatibility
    
    -- Entferne vorhandene Effekte
    for _, effect in pairs(lighting:GetChildren()) do
        if effect:IsA("BlurEffect") or effect:IsA("BloomEffect") or effect:IsA("SunRaysEffect") then
            effect:Destroy()
        end
    end
    
    -- Workspace Optimierungen
    workspace.StreamingEnabled = true
    
    -- Entferne alte UI-Elemente falls vorhanden
    for _, gui in pairs(game:GetService("CoreGui"):GetChildren()) do
        if gui.Name:match("MythHub") then
            gui:Destroy()
        end
    end
    
    return oldSettings
end

-- Sichere Initialisierung mit Fehlerbehandlung
local function safeInit()
    local success, oldSettings = pcall(optimizePerformance)
    if not success then
        warn("Fehler bei Performance-Optimierung:", oldSettings)
    end
    
    -- Verzögere die UI-Erstellung leicht
    task.wait(0.5)
    
    -- Rest des Scripts...
end

-- Starte die sichere Initialisierung
safeInit()

local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()

--[[ Config Management Functions (based on IntroductionForUI.txt) ]]--
local HttpService = game:GetService("HttpService")
local CONFIG_FOLDER_NAME = "MythHubConfig" -- Define folder name

-- Create folder if it doesn't exist
if not isfolder(CONFIG_FOLDER_NAME) then
    makefolder(CONFIG_FOLDER_NAME)
end

local function SaveConfigToFile(fileName, data)
    if not fileName or fileName == "" then 
        WindUI:Notify({Title = "Save Error", Content = "Please enter a valid file name.", Duration = 3, Icon = "alert-triangle", Color = "Red"})
        return false
    end
    local filePath = CONFIG_FOLDER_NAME .. "/" .. fileName .. ".json"
    local success, result = pcall(function()
        local jsonData = HttpService:JSONEncode(data)
        writefile(filePath, jsonData)
    end)
    if success then
        WindUI:Notify({Title = "Config Saved", Content = "Settings saved to " .. fileName .. ".json", Duration = 3, Icon = "save"})
        return true
    else
        WindUI:Notify({Title = "Save Error", Content = "Failed to save settings: " .. tostring(result), Duration = 5, Icon = "alert-triangle", Color = "Red"})
        return false
    end
end

local function LoadConfigFromFile(fileName)
    if not fileName or fileName == "" then 
        WindUI:Notify({Title = "Load Error", Content = "Please select a file to load.", Duration = 3, Icon = "alert-triangle", Color = "Red"})
        return nil 
    end
    local filePath = CONFIG_FOLDER_NAME .. "/" .. fileName .. ".json"
    if isfile(filePath) then
        local success, result = pcall(function()
            local jsonData = readfile(filePath)
            return HttpService:JSONDecode(jsonData)
        end)
        if success then
            WindUI:Notify({Title = "Config Loaded", Content = "Settings loaded from " .. fileName .. ".json", Duration = 3, Icon = "upload"})
            return result
        else
            WindUI:Notify({Title = "Load Error", Content = "Failed to decode JSON: " .. tostring(result), Duration = 5, Icon = "alert-triangle", Color = "Red"})
            return nil
        end
    else
        WindUI:Notify({Title = "Load Error", Content = "File not found: " .. fileName .. ".json", Duration = 3, Icon = "alert-triangle", Color = "Red"})
        return nil
    end
end

local function ListConfigFiles()
    local files = {}
    if isfolder(CONFIG_FOLDER_NAME) then
        local success, fileList = pcall(function()
             return listfiles(CONFIG_FOLDER_NAME)
        end)
        if success and fileList then
            for _, file in ipairs(fileList) do
                local fileName = file:match("([^/]+)%.json$")
                if fileName then
                    table.insert(files, fileName)
                end
            end
        else
             print("Error listing config files: ", fileList) -- Log error instead of notify spam
        end
    end
    return files
end
--[[ End Config Management Functions ]]--

-- KeyGuardian Integration
local KeyGuardLibrary = loadstring(game:HttpGet("https://cdn.keyguardian.org/library/v1.0.0.lua"))()
local trueData = "85eea4d090ee43d99ef357eaecaae134"
local falseData = "7abb4acc362d4d119602450c5a6e4a82"

-- Unterstützung für ältere und neuere API-Version
KeyGuardLibrary.Set({
	publicToken = "ca02dc6077074a89b877349f9b9894ab",
	privateToken = "cc60f57a2fe1409187d2677d9c3f5242",
	trueData = trueData,
	falseData = falseData,
})

-- Versuch, auch die neuere v2 API zu laden und zu konfigurieren
local KeyGuardianV2 = nil
pcall(function()
    KeyGuardianV2 = loadstring(game:HttpGet('https://cdn.keyguardian.org/library/v2.lua'))()
    if KeyGuardianV2 then
        KeyGuardianV2:Set({
            ServiceToken = "ca02dc6077074a89b877349f9b9894ab", -- publicToken
            APIToken = "cc60f57a2fe1409187d2677d9c3f5242"      -- privateToken
        })
    end
end)

local keyVerified = false
local key = getgenv().MythHubKey or "prefis8b03e264f1244d7da9db6149389aa1bf" -- Voreingestellter Key oder vom Benutzer

-- Debug-Funktion für Key-Verifizierung
local function checkKeyFormat(inputKey)
	-- Prüfe, ob der Key mit "prefix" beginnt (das Standard-Format von KeyGuardian)
	return inputKey and type(inputKey) == "string" and string.match(inputKey, "^prefis")
end

-- Verbesserte Key-Validierungsfunktion mit strikter Prüfung
function validateKey(userKey)
    -- Sicherstellung, dass der Key nicht leer ist
    if not userKey or userKey == "" or string.gsub(userKey, "%s+", "") == "" then
        print("KeyGuardian: Leerer Key wurde abgelehnt!")
        return false
    end
    
    -- Prüfung gegen den Default-Key (falls vorhanden)
    if defaultKey and userKey == defaultKey then
        print("KeyGuardian: Default-Key akzeptiert")
        return true
    end
    
    -- Zuerst mit der neueren API versuchen (wenn verfügbar)
    if KeyGuardianV2 then
        local success, result = pcall(function()
            return KeyGuardianV2:ValidateKey(userKey)
        end)
        
        if success and result then
            print("KeyGuardian V2: Key wurde erfolgreich verifiziert!")
            return true
        end
    end
    
    -- Dann mit der älteren API versuchen
    -- Versuche erst Premium-Key
    local success1, premiumResult = pcall(function()
        return KeyGuardLibrary.validatePremiumKey(userKey)
    end)
    
    if success1 and premiumResult == trueData then
        print("KeyGuardian: Premium-Key wurde erfolgreich verifiziert!")
        return true
    end
    
    -- Als letztes Standard-Key versuchen
    local success2, result = pcall(function()
        return KeyGuardLibrary.verify(userKey)
    end)
    
    -- Bei Fehlern während der Validierung (z.B. Netzwerkprobleme)
    if not success2 then
        print("KeyGuardian: Fehler bei der Validierung: " .. tostring(result))
        
        -- Fallback zur direkten Schlüsselprüfung
        local success3, defaultResult = pcall(function()
            return KeyGuardLibrary.validateDefaultKey(userKey)
        end)
        
        if success3 and defaultResult == trueData then
            print("KeyGuardian: Default-Key wurde über Fallback verifiziert!")
            return true
        end
        
        return false
    end
    
    -- Explizite Überprüfung des Ergebnisses
    if result == true then
        print("KeyGuardian: Key wurde erfolgreich verifiziert!")
        return true
    end
    
    print("KeyGuardian: Ungültiger Key")
    return false
end

-- 3D Fortschrittliche UI für MythHub
local Myth3DUI = {}

-- 3D Engine und Rendering-Funktionen
Myth3DUI.Engine = {}

-- Konstanten und Konfiguration
Myth3DUI.Config = {
	LOGO_URL = "MYTHLOGO.png",
	BACKGROUND_COLOR = Color3.fromRGB(5, 5, 35),
	ACCENT_COLOR = Color3.fromRGB(20, 30, 200),
	SECONDARY_COLOR = Color3.fromRGB(80, 100, 255),
	TEXT_COLOR = Color3.fromRGB(255, 255, 255),
	FONT = Enum.Font.GothamBold,
	ANIMATION_SPEED = 0.5, -- Reduziert von 0.7
	ROTATION_SPEED = 0.2, -- Reduziert von 0.3
	BLUR_INTENSITY = 10, -- Reduziert von 20
	LOGO_SIZE = UDim2.new(0, 200, 0, 200), -- Reduziert von 250x250
	PANEL_SIZE = UDim2.new(0, 400, 0, 500), -- Reduziert von 450x550
	SHADOW_TRANSPARENCY = 0.7, -- Erhöht von 0.5
	BLOOM_INTENSITY = 0.4, -- Reduziert von 0.8
	BLOOM_SIZE = 30, -- Reduziert von 60
	PARTICLE_COUNT = 40, -- Stark reduziert von 120
	PARTICLE_SPEED = 1.5, -- Reduziert von 2.5
	GLOW_COLOR = Color3.fromRGB(30, 80, 255),
	CAMERA_FOV = 40,
	CAMERA_DISTANCE = 8,
	DEPTH_OF_FIELD = false, -- Deaktiviert für bessere Performance
	AMBIENT_LIGHT = Color3.fromRGB(5, 15, 70),
	KEY_PANEL_TRANSPARENCY = 0.2
}

-- 3D-Klasse für Rendering und Transformationen
Myth3DUI.Engine.Object3D = {}
Myth3DUI.Engine.Object3D.__index = Myth3DUI.Engine.Object3D

function Myth3DUI.Engine.Object3D.new(parent)
	local self = setmetatable({}, Myth3DUI.Engine.Object3D)
	self.Parent = parent
	self.Position = Vector3.new(0, 0, 0)
	self.Rotation = Vector3.new(0, 0, 0)
	self.Scale = Vector3.new(1, 1, 1)
	self.Elements = {}
	self.Animations = {}
	
	-- Viewport für 3D-Rendering
	self.Viewport = Instance.new("ViewportFrame")
	self.Viewport.Size = UDim2.new(1, 0, 1, 0)
	self.Viewport.BackgroundTransparency = 1
	self.Viewport.LightingMode = Enum.LightingMode.ShadowMap
	self.Viewport.AnchorPoint = Vector2.new(0.5, 0.5)
	self.Viewport.Position = UDim2.new(0.5, 0, 0.5, 0)
	self.Viewport.Parent = parent
	
	-- Kamera für die 3D-Szene
	self.Camera = Instance.new("Camera")
	self.Camera.FieldOfView = Myth3DUI.Config.CAMERA_FOV
	self.Camera.CFrame = CFrame.new(0, 0, Myth3DUI.Config.CAMERA_DISTANCE, 0, 0, 0, 0, 1, 0)
	self.Camera.Parent = self.Viewport
	self.Viewport.CurrentCamera = self.Camera
	
	-- Szene für 3D-Objekte
	self.Scene = Instance.new("Model")
	self.Scene.Parent = self.Viewport
	
	-- Optimierte Beleuchtung
	self.Lighting = Instance.new("PointLight")
	self.Lighting.Brightness = 0.5 -- Reduzierte Helligkeit
	self.Lighting.Range = 15
	self.Lighting.Color = Color3.fromRGB(255, 255, 255)
	self.Lighting.Parent = self.Scene
	
	-- Optimiertes Umgebungslicht
	self.AmbientLight = Instance.new("PointLight")
	self.AmbientLight.Brightness = 0.2 -- Reduzierte Helligkeit
	self.AmbientLight.Range = 30
	self.AmbientLight.Color = Myth3DUI.Config.AMBIENT_LIGHT
	self.AmbientLight.Parent = self.Scene
	
	-- Animation-Loop
	self.RenderConnection = game:GetService("RunService").RenderStepped:Connect(function(dt)
		self:Update(dt)
	end)
	
	return self
end

function Myth3DUI.Engine.Object3D:AddElement(element)
	table.insert(self.Elements, element)
	element.Parent = self.Scene
	return element
end

function Myth3DUI.Engine.Object3D:Update(dt)
	-- Kamera-Animation
	self.Camera.CFrame = CFrame.new(
		math.sin(time() * 0.2) * 2, 
		math.sin(time() * 0.1) * 0.5 + 2, 
		Myth3DUI.Config.CAMERA_DISTANCE, 
		0, 0, 0
	)
	
	-- Aktualisiere alle Animationen
	for _, anim in pairs(self.Animations) do
		if anim.Active then
			anim:Update(dt)
		end
	end
	
	-- Aktualisiere alle Elemente
	for _, element in pairs(self.Elements) do
		if element:IsA("BasePart") then
			element.CFrame = CFrame.new(element.Position) * 
				CFrame.Angles(
					math.rad(element.RotationX or 0) + time() * Myth3DUI.Config.ROTATION_SPEED, 
					math.rad(element.RotationY or 0) + time() * Myth3DUI.Config.ROTATION_SPEED * 0.5, 
					math.rad(element.RotationZ or 0)
				)
		end
	end
end

function Myth3DUI.Engine.Object3D:AddAnimation(name, callback, duration, easing, loop)
	local animation = {
		Name = name,
		Callback = callback,
		Duration = duration or 1,
		Easing = easing or function(t) return t end, -- Linear easing
		Loop = loop or false,
		StartTime = time(),
		Active = true,
		
		Update = function(self, dt)
			local elapsedTime = time() - self.StartTime
			local progress = math.min(elapsedTime / self.Duration, 1)
			local easedProgress = self.Easing(progress)
			
			self.Callback(easedProgress)
			
			if progress >= 1 then
				if self.Loop then
					self.StartTime = time()
				else
					self.Active = false
				end
			end
		end,
		
		Reset = function(self)
			self.StartTime = time()
			self.Active = true
		end,
		
		Stop = function(self)
			self.Active = false
		end
	}
	
	self.Animations[name] = animation
	return animation
end

function Myth3DUI.Engine.Object3D:CreateLogo()
	-- MYTH Logo in 3D mit hochwertigem Look
	local logo = Instance.new("Part")
	logo.Anchored = true
	logo.CanCollide = false
	logo.Size = Vector3.new(4.5, 1.2, 0.2)
	logo.Position = Vector3.new(0, 0, 0)
	logo.Material = Enum.Material.Glass -- Glaseffekt für Reflexionen
	logo.Reflectance = 0.3 -- Reflexion hinzufügen
	logo.Color = Myth3DUI.Config.ACCENT_COLOR
	logo.Transparency = 0.1
	logo.Parent = self.Scene
	
	-- Logo-Textur (MYTH) mit besserem Kontrast
	local logoTexture = Instance.new("Decal")
	logoTexture.Face = Enum.NormalId.Front
	logoTexture.Texture = Myth3DUI.Config.LOGO_URL
	logoTexture.Transparency = 0.05
	logoTexture.Parent = logo
	
	-- Rückseiten-Textur für 3D-Effekt
	local logoBackTexture = Instance.new("Decal")
	logoBackTexture.Face = Enum.NormalId.Back
	logoBackTexture.Texture = Myth3DUI.Config.LOGO_URL
	logoBackTexture.Transparency = 0.1
	logoBackTexture.Parent = logo
	
	-- Verbesserter Glow-Effekt
	local logoGlow = Instance.new("PointLight")
	logoGlow.Brightness = 2.5
	logoGlow.Range = 15
	logoGlow.Color = Myth3DUI.Config.GLOW_COLOR
	logoGlow.Parent = logo
	
	-- Sekundärer Glüheffekt für dynamischeres Aussehen
	local secondaryGlow = Instance.new("SpotLight")
	secondaryGlow.Brightness = 1.5
	secondaryGlow.Range = 10
	secondaryGlow.Color = Color3.fromRGB(150, 200, 255)
	secondaryGlow.Angle = 60
	secondaryGlow.Face = Enum.NormalId.Front
	secondaryGlow.Parent = logo
	
	-- Umrandung des Logos für mehr Definition
	local logoOutline = Instance.new("SelectionBox")
	logoOutline.Adornee = logo
	logoOutline.Color3 = Color3.fromRGB(150, 180, 255)
	logoOutline.LineThickness = 0.01
	logoOutline.Transparency = 0.7
	logoOutline.Parent = logo
	
	-- Verbesserte Glanzpunkte für Highclass-Look
	for i = 1, 5 do
		local glint = Instance.new("Part")
		glint.Name = "LogoGlint_" .. i
		glint.Anchored = true
		glint.CanCollide = false
		glint.Size = Vector3.new(0.1, 0.1, 0.1)
		glint.Shape = Enum.PartType.Ball
		glint.Material = Enum.Material.Neon
		glint.Color = Color3.fromRGB(220, 240, 255)
		glint.Transparency = 0.3
		
		-- Verschiedene Positionen für die Glanzpunkte
		local xPos = math.random(-20, 20) / 10
		local yPos = math.random(-5, 5) / 10
		glint.Position = Vector3.new(xPos, yPos, 0.2)
		glint.Parent = self.Scene
		
		table.insert(self.Elements, glint)
		
		-- Animation für die Glanzpunkte
		self:AddAnimation("LogoGlint_" .. i, function(progress)
			local pulse = 0.3 + 0.7 * math.sin(progress * math.pi * 2 + i)
			glint.Transparency = 0.3 + (0.6 * (1 - pulse))
			glint.Size = Vector3.new(0.05 + (0.08 * pulse), 0.05 + (0.08 * pulse), 0.05)
		end, 2 + (i * 0.5), nil, true)
	end
	
	-- Animation für pulsierenden Glow
	self:AddAnimation("LogoGlow", function(progress)
		local pulse = 0.6 + 0.4 * math.sin(progress * math.pi * 2)
		logoGlow.Brightness = 2.5 * pulse
		secondaryGlow.Brightness = 1.5 * (1 - pulse * 0.5)
		logoOutline.Transparency = 0.6 + (0.3 * pulse)
	end, 3, nil, true)
	
	-- Animation für schwebenden Effekt
	self:AddAnimation("LogoFloat", function(progress)
		logo.Position = Vector3.new(
			math.sin(progress * math.pi * 0.5) * 0.2,
			math.sin(progress * math.pi) * 0.3,
			math.cos(progress * math.pi * 0.5) * 0.2
		)
	end, 6, nil, true)
	
	-- Animation für Rotation - sanfter und ansprechender
	logo.RotationX = 0
	logo.RotationY = 0
	logo.RotationZ = 0
	
	-- Logorotation als eigene Animation
	self:AddAnimation("LogoRotation", function(progress)
		local rotY = math.sin(progress * math.pi) * 8
		logo.RotationX = math.sin(progress * math.pi * 0.5) * 5
		logo.RotationY = rotY
	end, 8, nil, true)
	
	-- Füge das Logo zu den Elementen hinzu
	table.insert(self.Elements, logo)
	
	return logo
end

function Myth3DUI.Engine.Object3D:CreateParticles()
	local particleSystem = Instance.new("Model")
	particleSystem.Name = "ParticleSystem"
	particleSystem.Parent = self.Scene
	
	-- Reduzierte Partikeltypen für bessere Performance
	local particleTypes = {
		{
			name = "StandardParticle",
			count = Myth3DUI.Config.PARTICLE_COUNT * 0.7,
			size = {min = 0.05, max = 0.1},
			color = function()
				return Color3.fromRGB(100, 150, 255)
			end,
			speed = {min = 0.5, max = 1.0},
			material = Enum.Material.Neon,
			transparency = {min = 0.4, max = 0.8},
			movementRange = {x = 2.0, y = 2.0, z = 1.0},
		},
		{
			name = "GlowParticle",
			count = Myth3DUI.Config.PARTICLE_COUNT * 0.3,
			size = {min = 0.1, max = 0.15},
			color = function() 
				return Color3.fromRGB(220, 230, 255)
			end,
			speed = {min = 0.3, max = 0.6},
			material = Enum.Material.Neon,
			transparency = {min = 0.6, max = 0.9},
			movementRange = {x = 2.5, y = 2.5, z = 1.5},
		}
	}
	
	-- Optimierte Partikelgruppen
	local allParticles = {}
	
	for _, particleType in ipairs(particleTypes) do
		local group = Instance.new("Model")
		group.Name = particleType.name
		group.Parent = particleSystem
		
		for i = 1, particleType.count do
			local particle = Instance.new("Part")
			particle.Anchored = true
			particle.CanCollide = false
			
			local size = math.random() * (particleType.size.max - particleType.size.min) + particleType.size.min
			particle.Size = Vector3.new(size, size, size)
			
			particle.Position = Vector3.new(
				math.random(-8, 8),
				math.random(-8, 8),
				math.random(-3, 0)
			)
			
			particle.Material = particleType.material
			particle.Color = particleType.color()
			particle.Transparency = math.random() * (particleType.transparency.max - particleType.transparency.min) 
				+ particleType.transparency.min
			
			particle.Shape = Enum.PartType.Ball
			
			-- Vereinfachte Eigenschaften für Animation
			particle.InitialPosition = particle.Position
			particle.Speed = math.random(50, 100) / 100 * Myth3DUI.Config.PARTICLE_SPEED
				* (math.random() * (particleType.speed.max - particleType.speed.min) + particleType.speed.min)
			particle.Offset = math.random(1, 100)
			particle.MovementRange = particleType.movementRange
			
			particle.Parent = group
			table.insert(allParticles, particle)
			
			-- Warte kurz zwischen Partikel-Erstellung
			if i % 10 == 0 then
				task.wait(0.01)
			end
		end
	end
	
	-- Optimierte Partikelanimation
	self:AddAnimation("Particles", function(progress)
		for _, particle in pairs(allParticles) do
			if particle:IsA("BasePart") then
				local t = time() * particle.Speed + particle.Offset
				
				local range = particle.MovementRange
				
				-- Vereinfachte Bewegung
				particle.Position = particle.InitialPosition + Vector3.new(
					math.sin(t * 0.3) * range.x,
					math.cos(t * 0.5) * range.y,
					math.sin(t * 0.2) * range.z
				)
			end
		end
	end, 0.03, nil, true) -- Längeres Update-Intervall
	
	return particleSystem
end

function Myth3DUI.Engine.Object3D:Destroy()
	if self.RenderConnection then
		self.RenderConnection:Disconnect()
		self.RenderConnection = nil
	end
	
	-- Alle animationen stoppen
	for animName, animData in pairs(self.Animations or {}) do
		if animData.Connection then
			animData.Connection:Disconnect()
		end
	end
	self.Animations = {}
	
	-- Alle Elemente löschen
	for _, element in ipairs(self.Elements or {}) do
		if element and typeof(element) == "Instance" then
			element:Destroy()
		end
	end
	self.Elements = {}
	
	-- Beleuchtung und Umgebungslicht löschen
	if self.Lighting and self.Lighting.Parent then
		self.Lighting:Destroy()
	end
	
	if self.AmbientLight and self.AmbientLight.Parent then
		self.AmbientLight:Destroy()
	end
	
	-- Szene löschen
	if self.Scene and self.Scene.Parent then
		self.Scene:Destroy()
	end
	
	-- Kamera löschen
	if self.Camera and self.Camera.Parent then
		self.Camera:Destroy()
	end
	
	-- Viewport zuletzt löschen
	if self.Viewport and self.Viewport.Parent then
		self.Viewport:Destroy()
	end
end

-- UI für Key-Eingabe
local KeySystemUI = {}

KeySystemUI.CreateKeyUI = function()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "MythHubKeySystem"
	screenGui.ResetOnSpawn = false
	screenGui.Parent = game:GetService("CoreGui")
	
	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 300, 0, 200)
	mainFrame.Position = UDim2.new(0.5, -150, 0.5, -100)
	mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
	mainFrame.BorderSizePixel = 0
	mainFrame.Parent = screenGui
	
	local cornerMain = Instance.new("UICorner")
	cornerMain.CornerRadius = UDim.new(0, 10)
	cornerMain.Parent = mainFrame
	
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, 0, 0, 40)
	titleLabel.Position = UDim2.new(0, 0, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "MythHub Key System"
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 18
	titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	titleLabel.Parent = mainFrame
	
	local keyInput = Instance.new("TextBox")
	keyInput.Name = "KeyInput"
	keyInput.Size = UDim2.new(0.9, 0, 0, 40)
	keyInput.Position = UDim2.new(0.05, 0, 0.3, 0)
	keyInput.AnchorPoint = Vector2.new(0, 0.5)
	keyInput.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	keyInput.BorderSizePixel = 0
	keyInput.PlaceholderText = "Enter your key..."
	keyInput.Text = ""
	keyInput.Font = Enum.Font.Gotham
	keyInput.TextSize = 14
	keyInput.TextColor3 = Color3.fromRGB(255, 255, 255)
	keyInput.Parent = mainFrame
	
	-- Enter key functionality
	keyInput.FocusLost:Connect(function(enterPressed)
		if enterPressed and keyInput.Text ~= "" then
			-- Button animation
			submitButton.Size = UDim2.new(0.59, 0, 0, 33)
			submitButton.BackgroundColor3 = Color3.fromRGB(0, 100, 195)
			
			task.wait(0.1)
			
			-- Zurück zur Originalform
			submitButton.Size = UDim2.new(0.6, 0, 0, 35)
			submitButton.BackgroundColor3 = Color3.fromRGB(0, 120, 215)
			
			-- Login-Button klicken
			submitButton.MouseButton1Click:Fire()
		end
	end)
	
	local cornerInput = Instance.new("UICorner")
	cornerInput.CornerRadius = UDim.new(0, 6)
	cornerInput.Parent = keyInput
	
	local submitButton = Instance.new("TextButton")
	submitButton.Name = "SubmitButton"
	submitButton.Size = UDim2.new(0.6, 0, 0, 35)
	submitButton.Position = UDim2.new(0.2, 0, 0.55, 0)
	submitButton.BackgroundColor3 = Color3.fromRGB(0, 120, 215)
	submitButton.BorderSizePixel = 0
	submitButton.Text = "Einloggen"
	submitButton.Font = Enum.Font.GothamBold
	submitButton.TextSize = 14
	submitButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	submitButton.Parent = mainFrame
	
	local cornerSubmit = Instance.new("UICorner")
	cornerSubmit.CornerRadius = UDim.new(0, 6)
	cornerSubmit.Parent = submitButton
	
	local getKeyButton = Instance.new("TextButton")
	getKeyButton.Name = "GetKeyButton"
	getKeyButton.Size = UDim2.new(0.6, 0, 0, 30)
	getKeyButton.Position = UDim2.new(0.2, 0, 0.75, 0)
	getKeyButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	getKeyButton.BorderSizePixel = 0
	getKeyButton.Text = "Key holen"
	getKeyButton.Font = Enum.Font.Gotham
	getKeyButton.TextSize = 14
	getKeyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	getKeyButton.Parent = mainFrame
	
	local cornerGetKey = Instance.new("UICorner")
	cornerGetKey.CornerRadius = UDim.new(0, 6)
	cornerGetKey.Parent = getKeyButton
	
	local statusLabel = Instance.new("TextLabel")
	statusLabel.Name = "Status"
	statusLabel.Size = UDim2.new(1, 0, 0, 30)
	statusLabel.Position = UDim2.new(0, 0, 0.9, 0)
	statusLabel.BackgroundTransparency = 1
	statusLabel.Text = ""
	statusLabel.Font = Enum.Font.Gotham
	statusLabel.TextSize = 14
	statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	statusLabel.Parent = mainFrame
	
	-- Schatten hinzufügen
	local shadow = Instance.new("ImageLabel")
	shadow.Name = "Shadow"
	shadow.Size = UDim2.new(1, 30, 1, 30)
	shadow.Position = UDim2.new(0, -15, 0, -15)
	shadow.BackgroundTransparency = 1
	shadow.Image = "rbxassetid://5554236805"
	shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
	shadow.ImageTransparency = 0.6
	shadow.ScaleType = Enum.ScaleType.Slice
	shadow.SliceCenter = Rect.new(23, 23, 277, 277)
	shadow.ZIndex = -1
	shadow.Parent = mainFrame
	
	-- Close Button
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 25, 0, 25)
	closeButton.Position = UDim2.new(1, -30, 0, 5)
	closeButton.BackgroundTransparency = 1
	closeButton.Text = "×"  -- Better X symbol
	closeButton.Font = Enum.Font.GothamBold
	closeButton.TextSize = 20  -- Larger text
	closeButton.TextColor3 = Color3.fromRGB(200, 200, 200)
	closeButton.ZIndex = 10 -- Ensure button is on top
	closeButton.Parent = mainFrame
	
	-- Add visible background on hover to make clickable area more obvious
	local closeButtonBackground = Instance.new("Frame")
	closeButtonBackground.Name = "Background"
	closeButtonBackground.Size = UDim2.new(1, 0, 1, 0)
	closeButtonBackground.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	closeButtonBackground.BackgroundTransparency = 1
	closeButtonBackground.ZIndex = 9
	closeButtonBackground.Parent = closeButton
	
	local closeButtonCorner = Instance.new("UICorner")
	closeButtonCorner.CornerRadius = UDim.new(0, 4)
	closeButtonCorner.Parent = closeButtonBackground
	
	-- Hover effects for X button - improved visibility
	closeButton.MouseEnter:Connect(function()
		closeButton.TextColor3 = Color3.fromRGB(255, 100, 100)  -- Red on hover
		closeButton.TextSize = 22  -- Slightly enlarge
		closeButtonBackground.BackgroundTransparency = 0.5  -- Show background
		-- Animation for smooth transition
		game:GetService("TweenService"):Create(
			closeButton,
			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
			{Rotation = 90}  -- Rotation effect
		):Play()
	end)
	
	closeButton.MouseLeave:Connect(function()
		closeButton.TextColor3 = Color3.fromRGB(200, 200, 200)
		closeButton.TextSize = 20
		closeButtonBackground.BackgroundTransparency = 1  -- Hide background
		-- Reset animation
		game:GetService("TweenService"):Create(
			closeButton,
			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
			{Rotation = 0}
		):Play()
	end)
	
	-- Click effect and improved close function with direct option
	closeButton.MouseButton1Click:Connect(function()
		-- Sofort Zustand als "wird geschlossen" markieren
		local isClosing = true
		
		-- Direkte visuelles Feedback für bessere User Experience
		closeButton.TextColor3 = Color3.fromRGB(255, 50, 50)
		closeButton.TextSize = 26
		
		-- Sichere Funktion für Destroy-Operationen
		local function safeDestroy(instance)
			if instance and typeof(instance) == "Instance" and instance.Parent then
				pcall(function() instance:Destroy() end)
			end
		end
		
		-- Click-Animationseffekt
		pcall(function()
			local clickRipple = Instance.new("Frame")
			clickRipple.Size = UDim2.new(0, 10, 0, 10)
			clickRipple.Position = UDim2.new(0.5, 0, 0.5, 0)
			clickRipple.AnchorPoint = Vector2.new(0.5, 0.5)
			clickRipple.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
			clickRipple.BackgroundTransparency = 0.2
			clickRipple.BorderSizePixel = 0
			clickRipple.ZIndex = 11
			
			local rippleCorner = Instance.new("UICorner")
			rippleCorner.CornerRadius = UDim.new(1, 0)
			rippleCorner.Parent = clickRipple
			
			clickRipple.Parent = closeButton
			
			-- Animiere den Ripple-Effekt
			pcall(function()
				tweenProperty(clickRipple, "Size", UDim2.new(0, 50, 0, 50), 0.3)
				tweenProperty(clickRipple, "BackgroundTransparency", 1, 0.3)
			end)
		end)
		
		-- Ausblendungsanimationen starten mit Fehlerbehandlung
		pcall(function()
			if blurEffect and blurEffect.Parent then
				tweenProperty(blurEffect, "Size", 0, 0.6)
			end
			
			if bloomEffect and bloomEffect.Parent then
				tweenProperty(bloomEffect, "Intensity", 0, 0.6)
			end
			
			if backgroundFrame and backgroundFrame.Parent then
				tweenProperty(backgroundFrame, "BackgroundTransparency", 1, 0.6)
			end
			
			if mainContainer and mainContainer.Parent then
				tweenProperty(mainContainer, "Position", UDim2.new(0.5, 0, 1.5, 0), 0.8, Enum.EasingStyle.Back, Enum.EasingDirection.In)
			end
		end)
		
		-- UI nach kurzer Verzögerung entfernen
		task.delay(0.6, function()
			if not isClosing then return end
			
			safeDestroy(blurEffect)
			safeDestroy(bloomEffect)
			safeDestroy(screenGui)
			
			-- Sicherstellen, dass alle Lighting-Effekte entfernt werden
			for _, effect in pairs(game:GetService("Lighting"):GetChildren()) do
				if string.find(effect.Name, "MythHub") then
					safeDestroy(effect)
				end
			end
		end)
		
		-- Failsafe - falls nach 1.5 Sekunden die UI noch existiert
		task.delay(1.5, function()
			safeDestroy(screenGui)
		end)
	end)
	
	-- Event-Handler
	local keyLink = ""
	
	-- Versuche den Link mit beiden API-Versionen zu bekommen
	if KeyGuardianV2 then
		pcall(function()
			keyLink = KeyGuardianV2:GetKeylink()
		end)
	end
	
	-- Fallback auf ältere API, wenn noch kein Link vorhanden
	if keyLink == "" then
		pcall(function()
			keyLink = KeyGuardLibrary.getLink()
		end)
	end
	
	submitButton.MouseButton1Click:Connect(function()
		local inputKey = keyInput.Text
		if inputKey and inputKey ~= "" then
			statusLabel.Text = "Validating key..."
			statusLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
			
			-- Use enhanced validation
			local isValid = validateKey(inputKey)
			
			if isValid then
				statusLabel.Text = "Key valid! Loading MythHub..."
				statusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
				getgenv().MythHubKey = inputKey
				keyVerified = true
				task.wait(1)
				screenGui:Destroy()
			else
				statusLabel.Text = "Key invalid!"
				statusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
			end
		else
			statusLabel.Text = "Please enter a key"
			statusLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
		end
	end)
	
	getKeyButton.MouseButton1Click:Connect(function()
		statusLabel.Text = "Link copied!"
		statusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
		setclipboard(keyLink)
	end)
	
	-- Mache die UI beweglich
	local dragging = false
	local dragInput, dragStart, startPos
	
	local function update(input)
		local delta = input.Position - dragStart
		mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
	
	mainFrame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
			startPos = mainFrame.Position
			
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	
	mainFrame.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement then
			dragInput = input
		end
	end)
	
	game:GetService("UserInputService").InputChanged:Connect(function(input)
		if input == dragInput and dragging then
			update(input)
		end
	end)
	
	return screenGui
end

-- Validierungsfunktion mit besserer Ausführungslogik und Premium 3D-UI
local function ValidateAndStartScript()
    -- Initialer Key-Status ist immer false
    keyVerified = false
    
    -- Debugging-Ausgabe
    print("KeyGuardian: Starte Validierungsprozess")
    
    -- Prüfe, ob ein Key als globale Variable gespeichert ist
    if key and validateKey(key) then
        print("KeyGuardian: Gespeicherter Key ist gültig")
        keyVerified = true
        return true
    else
        print("KeyGuardian: Gespeicherter Key fehlt oder ist ungültig")
    end
    
    -- 3D Premium UI mit Animationen erstellen
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MythHubPremiumKeySystem"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = game:GetService("CoreGui")
    
    -- Hintergrundeffekte
    local blurEffect = Instance.new("BlurEffect")
    blurEffect.Size = 0
    blurEffect.Parent = game:GetService("Lighting")
    
    local bloomEffect = Instance.new("BloomEffect")
    bloomEffect.Intensity = 0
    bloomEffect.Size = 15
    bloomEffect.Threshold = 0.8
    bloomEffect.Parent = game:GetService("Lighting")
    
    -- Hintergrund-Frame mit Animationen
    local backgroundFrame = Instance.new("Frame")
    backgroundFrame.Name = "AnimatedBackground"
    backgroundFrame.Size = UDim2.new(1, 0, 1, 0)
    backgroundFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 30)
    backgroundFrame.BackgroundTransparency = 1 -- Wird animiert
    backgroundFrame.BorderSizePixel = 0
    backgroundFrame.Parent = screenGui
    
    -- 3D ViewportFrame für Partikeleffekte
    local viewport = Instance.new("ViewportFrame")
    viewport.Name = "ParticleViewport"
    viewport.Size = UDim2.new(1, 0, 1, 0)
    viewport.BackgroundTransparency = 1
    viewport.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    viewport.Ambient = Color3.fromRGB(50, 50, 100)
    viewport.Parent = backgroundFrame
    
    local camera = Instance.new("Camera")
    camera.FieldOfView = 70
    viewport.CurrentCamera = camera
    camera.Parent = viewport
    
    -- 3D Welt für Partikel
    local worldModel = Instance.new("WorldModel")
    worldModel.Parent = viewport
    
    -- 3D Partikel erzeugen
    for i = 1, 50 do
        local particle = Instance.new("Part")
        particle.Name = "Particle_" .. i
        particle.Shape = Enum.PartType.Ball
        particle.Material = Enum.Material.Neon
        particle.Size = Vector3.new(0.5, 0.5, 0.5)
        particle.Position = Vector3.new(math.random(-20, 20), math.random(-15, 15), math.random(10, 30))
        particle.Anchored = true
        particle.CanCollide = false
        particle.Transparency = math.random(3, 7) / 10
        particle.Color = Color3.fromRGB(
            math.random(40, 100),
            math.random(80, 180),
            math.random(200, 255)
        )
        particle.Parent = worldModel
        
        -- Partikel-Animation
        task.spawn(function()
            local startPos = particle.Position
            local speed = math.random(5, 15) / 10
            local offset = math.random(1, 100)
            
            while task.wait() do
                if not particle or not particle.Parent then break end
                
                local t = tick() * speed + offset
                particle.Position = Vector3.new(
                    startPos.X + math.sin(t * 0.5) * 3,
                    startPos.Y + math.cos(t * 0.3) * 3,
                    startPos.Z + math.sin(t * 0.7) * 2
                )
                
                -- Farbe pulsieren lassen
                local pulse = (math.sin(t * 0.2) + 1) / 2
                particle.Color = Color3.fromRGB(
                    math.floor(40 + (60 * pulse)),
                    math.floor(80 + (100 * pulse)),
                    math.floor(200 + (55 * pulse))
                )
            end
        end)
    end
    
    -- Kamera Animation
    task.spawn(function()
        while task.wait(0.01) do
            if not camera or not camera.Parent then break end
            
            local t = tick() * 0.1
            camera.CFrame = CFrame.new(
                math.sin(t) * 5, 
                math.cos(t * 0.5) * 3, 
                -25, 
                0, 0, 0
            )
        end
    end)
    
    -- Hauptcontainer für die UI
    local mainContainer = Instance.new("Frame")
    mainContainer.Name = "MainContainer"
    mainContainer.Size = UDim2.new(0, 450, 0, 500)
    mainContainer.Position = UDim2.new(0.5, 0, 0.5, 0)
    mainContainer.AnchorPoint = Vector2.new(0.5, 0.5)
    mainContainer.BackgroundTransparency = 1
    mainContainer.Parent = screenGui
    
    -- Logo Container (oben)
    local logoContainer = Instance.new("Frame")
    logoContainer.Name = "LogoContainer"
    logoContainer.Size = UDim2.new(0, 200, 0, 200)
    logoContainer.Position = UDim2.new(0.5, 0, 0, 50)
    logoContainer.AnchorPoint = Vector2.new(0.5, 0)
    logoContainer.BackgroundTransparency = 1
    logoContainer.Parent = mainContainer
    
    -- Dein benutzerdefiniertes Logo
    local logoImage = Instance.new("ImageLabel")
    logoImage.Name = "Logo"
    logoImage.Size = UDim2.new(1, 0, 1, 0)
    logoImage.BackgroundTransparency = 1
    logoImage.Image = Myth3DUI.Config.LOGO_URL -- Lokales Logo verwenden
    logoImage.ScaleType = Enum.ScaleType.Fit
    logoImage.ImageTransparency = 1 -- Wird animiert
    logoImage.Parent = logoContainer
    
    -- Verbesserter Glowing-Effekt für das Logo
    local logoGlow = Instance.new("ImageLabel")
    logoGlow.Name = "LogoGlow"
    logoGlow.Size = UDim2.new(1.2, 0, 1.2, 0)
    logoGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
    logoGlow.AnchorPoint = Vector2.new(0.5, 0.5)
    logoGlow.BackgroundTransparency = 1
    logoGlow.Image = "rbxassetid://4996891970" -- Glow-Effekt
    logoGlow.ImageColor3 = Color3.fromRGB(100, 150, 255)
    logoGlow.ImageTransparency = 0.5
    logoGlow.Parent = logoContainer
    
    -- Zusätzlicher Leuchteffekt für das Logo
    local logoHighlight = Instance.new("ImageLabel")
    logoHighlight.Name = "LogoHighlight"
    logoHighlight.Size = UDim2.new(1.5, 0, 1.5, 0)
    logoHighlight.Position = UDim2.new(0.5, 0, 0.5, 0)
    logoHighlight.AnchorPoint = Vector2.new(0.5, 0.5)
    logoHighlight.BackgroundTransparency = 1
    logoHighlight.Image = "rbxassetid://5060023708" -- Zusätzlicher Leuchteffekt
    logoHighlight.ImageColor3 = Color3.fromRGB(60, 110, 255)
    logoHighlight.ImageTransparency = 0.8
    logoHighlight.ZIndex = logoGlow.ZIndex - 1
    logoHighlight.Parent = logoContainer
    
    -- Key-Panel (unten)
    local keyPanel = Instance.new("Frame")
    keyPanel.Name = "KeyPanel"
    keyPanel.Size = UDim2.new(0, 400, 0, 250)
    keyPanel.Position = UDim2.new(0.5, 0, 1, -150)
    keyPanel.AnchorPoint = Vector2.new(0.5, 1)
    keyPanel.BackgroundColor3 = Color3.fromRGB(20, 20, 40)
    keyPanel.BackgroundTransparency = 0.15
    keyPanel.BorderSizePixel = 0
    keyPanel.Parent = mainContainer
    
    -- Make panel draggable
    local dragBar = Instance.new("Frame")
    dragBar.Name = "DragBar"
    dragBar.Size = UDim2.new(1, 0, 0, 30)
    dragBar.Position = UDim2.new(0, 0, 0, 0)
    dragBar.BackgroundColor3 = Color3.fromRGB(30, 30, 50)
    dragBar.BackgroundTransparency = 0.5
    dragBar.BorderSizePixel = 0
    dragBar.Parent = keyPanel
    
    -- Make the corners round for the drag bar
    local dragBarCorner = Instance.new("UICorner")
    dragBarCorner.CornerRadius = UDim.new(0, 8)
    dragBarCorner.Parent = dragBar
    
    -- Dragging functionality
    local dragging = false
    local dragInput
    local dragStart
    local startPos
    
    local function updateDrag(input)
        local delta = input.Position - dragStart
        mainContainer.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    
    dragBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = mainContainer.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    dragBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            updateDrag(input)
        end
    end)
    
    -- Drag handle visual indicator
    local dragIndicator = Instance.new("TextLabel")
    dragIndicator.Name = "DragIndicator"
    dragIndicator.Size = UDim2.new(1, 0, 1, 0)
    dragIndicator.BackgroundTransparency = 1
    dragIndicator.Text = "• • •"
    dragIndicator.TextColor3 = Color3.fromRGB(150, 150, 200)
    dragIndicator.TextSize = 18
    dragIndicator.Font = Enum.Font.GothamBold
    dragIndicator.Parent = dragBar
    
    -- X-Button (Schließen-Button) hinzufügen
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 24, 0, 24)
    closeButton.Position = UDim2.new(1, -10, 0, 3)
    closeButton.AnchorPoint = Vector2.new(1, 0)
    closeButton.BackgroundTransparency = 1
    closeButton.Text = "×"
    closeButton.TextColor3 = Color3.fromRGB(180, 180, 220)
    closeButton.TextSize = 24
    closeButton.Font = Enum.Font.GothamBold
    closeButton.ZIndex = 10
    closeButton.Parent = dragBar
    
    -- Hover-Effekt für den X-Button
    closeButton.MouseEnter:Connect(function()
        tweenProperty(closeButton, "TextColor3", Color3.fromRGB(255, 100, 100), 0.3)
        tweenProperty(closeButton, "TextSize", 26, 0.3)
        tweenProperty(closeButton, "Rotation", 90, 0.3)
    end)
    
    closeButton.MouseLeave:Connect(function()
        tweenProperty(closeButton, "TextColor3", Color3.fromRGB(180, 180, 220), 0.3)
        tweenProperty(closeButton, "TextSize", 24, 0.3)
        tweenProperty(closeButton, "Rotation", 0, 0.3)
    end)
    
    -- Klick-Effekt und Schließen der GUI
    closeButton.MouseButton1Click:Connect(function()
        -- Sofort Zustand als "wird geschlossen" markieren
        local isClosing = true
        
        -- Direkte visuelles Feedback für bessere User Experience
        closeButton.TextColor3 = Color3.fromRGB(255, 50, 50)
        closeButton.TextSize = 26
        
        -- Sichere Funktion für Destroy-Operationen
        local function safeDestroy(instance)
            if instance and typeof(instance) == "Instance" and instance.Parent then
                pcall(function() instance:Destroy() end)
            end
        end
        
        -- Click-Animationseffekt
        pcall(function()
            local clickRipple = Instance.new("Frame")
            clickRipple.Size = UDim2.new(0, 10, 0, 10)
            clickRipple.Position = UDim2.new(0.5, 0, 0.5, 0)
            clickRipple.AnchorPoint = Vector2.new(0.5, 0.5)
            clickRipple.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
            clickRipple.BackgroundTransparency = 0.2
            clickRipple.BorderSizePixel = 0
            clickRipple.ZIndex = 11
            
            local rippleCorner = Instance.new("UICorner")
            rippleCorner.CornerRadius = UDim.new(1, 0)
            rippleCorner.Parent = clickRipple
            
            clickRipple.Parent = closeButton
            
            -- Animiere den Ripple-Effekt
            pcall(function()
                tweenProperty(clickRipple, "Size", UDim2.new(0, 50, 0, 50), 0.3)
                tweenProperty(clickRipple, "BackgroundTransparency", 1, 0.3)
            end)
        end)
        
        -- Ausblendungsanimationen starten mit Fehlerbehandlung
        pcall(function()
            if blurEffect and blurEffect.Parent then
                tweenProperty(blurEffect, "Size", 0, 0.6)
            end
            
            if bloomEffect and bloomEffect.Parent then
                tweenProperty(bloomEffect, "Intensity", 0, 0.6)
            end
            
            if backgroundFrame and backgroundFrame.Parent then
                tweenProperty(backgroundFrame, "BackgroundTransparency", 1, 0.6)
            end
            
            if mainContainer and mainContainer.Parent then
                tweenProperty(mainContainer, "Position", UDim2.new(0.5, 0, 1.5, 0), 0.8, Enum.EasingStyle.Back, Enum.EasingDirection.In)
            end
        end)
        
        -- UI nach kurzer Verzögerung entfernen
        task.delay(0.6, function()
            if not isClosing then return end
            
            safeDestroy(blurEffect)
            safeDestroy(bloomEffect)
            safeDestroy(screenGui)
            
            -- Sicherstellen, dass alle Lighting-Effekte entfernt werden
            for _, effect in pairs(game:GetService("Lighting"):GetChildren()) do
                if string.find(effect.Name, "MythHub") then
                    safeDestroy(effect)
                end
            end
        end)
        
        -- Failsafe - falls nach 1.5 Sekunden die UI noch existiert
        task.delay(1.5, function()
            safeDestroy(screenGui)
        end)
    end)
    
    -- Glaseffekt für das Panel
    local keyPanelCorner = Instance.new("UICorner")
    keyPanelCorner.CornerRadius = UDim.new(0, 12)
    keyPanelCorner.Parent = keyPanel
    
    -- Schicker Rahmen für das Panel
    local keyPanelStroke = Instance.new("UIStroke")
    keyPanelStroke.Color = Color3.fromRGB(80, 120, 255)
    keyPanelStroke.Thickness = 2
    keyPanelStroke.Transparency = 0.7
    keyPanelStroke.Parent = keyPanel
    
    -- Gradient für das Panel
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 50)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 40))
    })
    gradient.Rotation = 45
    gradient.Parent = keyPanel
    
    -- Schatten
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Size = UDim2.new(1.1, 0, 1.1, 0)
    shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
    shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 10)
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(23, 23, 277, 277)
    shadow.ZIndex = keyPanel.ZIndex - 1
    shadow.Parent = keyPanel
    
    -- Titel mit Animationseffekt
    local titleContainer = Instance.new("Frame")
    titleContainer.Name = "TitleContainer"
    titleContainer.Size = UDim2.new(1, 0, 0, 50)
    titleContainer.Position = UDim2.new(0, 0, 0, 10)
    titleContainer.BackgroundTransparency = 1
    titleContainer.ClipsDescendants = true
    titleContainer.Parent = keyPanel
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, 0, 1, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "MYTHHUB PREMIUM"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 28
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextTransparency = 1 -- Wird animiert
    titleLabel.Parent = titleContainer
    
    -- Subtitel mit Animationseffekt
    local subtitleLabel = Instance.new("TextLabel")
    subtitleLabel.Name = "SubtitleLabel"
    subtitleLabel.Size = UDim2.new(1, 0, 0, 20)
    subtitleLabel.Position = UDim2.new(0, 0, 0, 45)
    subtitleLabel.BackgroundTransparency = 1
    subtitleLabel.Text = "AUTHENTICATION SYSTEM"
    subtitleLabel.TextColor3 = Color3.fromRGB(180, 180, 255)
    subtitleLabel.TextSize = 14
    subtitleLabel.Font = Enum.Font.Gotham
    subtitleLabel.TextTransparency = 1 -- Wird animiert
    subtitleLabel.Parent = keyPanel
    
    -- Key-Eingabebereich
    local inputContainer = Instance.new("Frame")
    inputContainer.Name = "InputContainer"
    inputContainer.Size = UDim2.new(0.85, 0, 0, 45)
    inputContainer.Position = UDim2.new(0.5, 0, 0, 85)
    inputContainer.AnchorPoint = Vector2.new(0.5, 0)
    inputContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 60)
    inputContainer.BackgroundTransparency = 0.5
    inputContainer.BorderSizePixel = 0
    
    -- Abgerundete Ecken für den Eingabebereich
    local inputContainerCorner = Instance.new("UICorner")
    inputContainerCorner.CornerRadius = UDim.new(0, 8)
    inputContainerCorner.Parent = inputContainer
    
    -- Rahmen für den Eingabebereich
    local inputContainerStroke = Instance.new("UIStroke")
    inputContainerStroke.Color = Color3.fromRGB(100, 150, 255)
    inputContainerStroke.Thickness = 1.5
    inputContainerStroke.Transparency = 0.7
    inputContainerStroke.Parent = inputContainer
    
    inputContainer.Parent = keyPanel
    
    -- Icon für das Eingabefeld
    local keyIcon = Instance.new("ImageLabel")
    keyIcon.Name = "KeyIcon"
    keyIcon.Size = UDim2.new(0, 20, 0, 20)
    keyIcon.Position = UDim2.new(0, 15, 0.5, 0)
    keyIcon.AnchorPoint = Vector2.new(0, 0.5)
    keyIcon.BackgroundTransparency = 1
    keyIcon.Image = "rbxassetid://6031225816" -- Key-Icon
    keyIcon.ImageColor3 = Color3.fromRGB(150, 150, 255)
    keyIcon.Parent = inputContainer
    
    -- Das eigentliche Eingabefeld
    local keyInput = Instance.new("TextBox")
    keyInput.Name = "KeyInput"
    keyInput.Size = UDim2.new(1, -50, 1, -10)
    keyInput.Position = UDim2.new(0, 45, 0.5, 0)
    keyInput.AnchorPoint = Vector2.new(0, 0.5)
    keyInput.BackgroundTransparency = 1
    keyInput.Text = ""
    keyInput.PlaceholderText = "Enter your key here..."
    keyInput.PlaceholderColor3 = Color3.fromRGB(130, 130, 180)
    keyInput.TextColor3 = Color3.fromRGB(255, 255, 255)
    keyInput.TextSize = 16
    keyInput.TextXAlignment = Enum.TextXAlignment.Left
    keyInput.Font = Enum.Font.Gotham
    keyInput.ClearTextOnFocus = false
    keyInput.Parent = inputContainer
    
    -- Fokus-Animation für verbessertes visuelles Feedback
    keyInput.Focused:Connect(function()
        tweenProperty(inputContainerStroke, "Color", Color3.fromRGB(150, 200, 255), 0.3)
        tweenProperty(inputContainerStroke, "Thickness", 2.5, 0.3)
        tweenProperty(keyIcon, "ImageColor3", Color3.fromRGB(200, 200, 255), 0.3)
        
        -- Coole Pulsiereffekt für den Fokus
        local pulseEffect = Instance.new("Frame")
        pulseEffect.Name = "PulseEffect"
        pulseEffect.Size = UDim2.new(1, 0, 1, 0)
        pulseEffect.Position = UDim2.new(0.5, 0, 0.5, 0)
        pulseEffect.AnchorPoint = Vector2.new(0.5, 0.5)
        pulseEffect.BackgroundColor3 = Color3.fromRGB(100, 150, 255)
        pulseEffect.BackgroundTransparency = 0.9
        pulseEffect.BorderSizePixel = 0
        pulseEffect.ZIndex = inputContainer.ZIndex - 1
        
        local pulseCorner = Instance.new("UICorner")
        pulseCorner.CornerRadius = UDim.new(0, 8)
        pulseCorner.Parent = pulseEffect
        
        pulseEffect.Parent = inputContainer
        
        -- Pulsieren-Animation
        task.spawn(function()
            for i = 1, 3 do
                tweenProperty(pulseEffect, "Size", UDim2.new(1.1, 0, 1.1, 0), 0.5)
                tweenProperty(pulseEffect, "BackgroundTransparency", 1, 0.5)
                task.wait(0.5)
                
                if pulseEffect and pulseEffect.Parent then
                    pulseEffect.Size = UDim2.new(1, 0, 1, 0)
                    pulseEffect.BackgroundTransparency = 0.9
                else
                    break
                end
            end
            
            if pulseEffect and pulseEffect.Parent then
                pulseEffect:Destroy()
            end
        end)
    end)
    
    keyInput.FocusLost:Connect(function()
        tweenProperty(inputContainerStroke, "Color", Color3.fromRGB(100, 150, 255), 0.3)
        tweenProperty(inputContainerStroke, "Thickness", 1.5, 0.3)
        tweenProperty(keyIcon, "ImageColor3", Color3.fromRGB(150, 150, 255), 0.3)
    end)
    
    -- Login-Button mit Animationseffekten
    local loginButton = Instance.new("TextButton")
    loginButton.Name = "LoginButton"
    loginButton.Size = UDim2.new(0.7, 0, 0, 45)
    loginButton.Position = UDim2.new(0.5, 0, 0, 145)
    loginButton.AnchorPoint = Vector2.new(0.5, 0)
    loginButton.BackgroundColor3 = Color3.fromRGB(60, 100, 255)
    loginButton.BorderSizePixel = 0
    loginButton.Text = "VERIFY KEY"
    loginButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    loginButton.TextSize = 18
    loginButton.Font = Enum.Font.GothamBold
    loginButton.AutoButtonColor = false -- Wir machen unsere eigenen Hover-Effekte
    
    -- Abgerundete Ecken für den Button
    local loginButtonCorner = Instance.new("UICorner")
    loginButtonCorner.CornerRadius = UDim.new(0, 8)
    loginButtonCorner.Parent = loginButton
    
    -- Schicker Gradient für den Button
    local buttonGradient = Instance.new("UIGradient")
    buttonGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 130, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 100, 255))
    })
    buttonGradient.Rotation = 45
    buttonGradient.Parent = loginButton
    
    -- Leuchteffekt für den Button
    local buttonGlow = Instance.new("ImageLabel")
    buttonGlow.Name = "ButtonGlow"
    buttonGlow.Size = UDim2.new(1.2, 0, 1.5, 0)
    buttonGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
    buttonGlow.AnchorPoint = Vector2.new(0.5, 0.5)
    buttonGlow.BackgroundTransparency = 1
    buttonGlow.Image = "rbxassetid://4996891970"
    buttonGlow.ImageColor3 = Color3.fromRGB(60, 100, 255)
    buttonGlow.ImageTransparency = 0.9
    buttonGlow.ZIndex = loginButton.ZIndex - 1
    buttonGlow.Parent = loginButton
    
    -- Button-Rahmen mit Leuchteffekt
    local buttonStroke = Instance.new("UIStroke")
    buttonStroke.Color = Color3.fromRGB(100, 150, 255)
    buttonStroke.Thickness = 1.5
    buttonStroke.Transparency = 0.7
    buttonStroke.Parent = loginButton
    
    loginButton.Parent = keyPanel
    
    -- Status-Meldungsbereich
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Name = "StatusLabel"
    statusLabel.Size = UDim2.new(0.9, 0, 0, 30)
    statusLabel.Position = UDim2.new(0.5, 0, 0, 200)
    statusLabel.AnchorPoint = Vector2.new(0.5, 0)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = ""
    statusLabel.TextColor3 = Color3.fromRGB(150, 150, 180)
    statusLabel.TextSize = 14
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.Parent = keyPanel
    
    -- Get Key Button
    local getKeyButton = Instance.new("TextButton")
    getKeyButton.Name = "GetKeyButton"
    getKeyButton.Size = UDim2.new(0.5, 0, 0, 25)
    getKeyButton.Position = UDim2.new(0.5, 0, 0, 220)
    getKeyButton.AnchorPoint = Vector2.new(0.5, 0)
    getKeyButton.BackgroundTransparency = 1
    getKeyButton.TextColor3 = Color3.fromRGB(130, 170, 255)
    getKeyButton.Text = "GET KEY"
    getKeyButton.TextSize = 14
    getKeyButton.Font = Enum.Font.Gotham
    getKeyButton.Parent = keyPanel
    
    -- Animationsfunktionen
    local function tweenProperty(object, property, value, time, easingStyle, easingDirection, delay)
        -- Sicherheitsprüfung, ob das Objekt noch existiert
        if not object or typeof(object) ~= "Instance" or not object.Parent then
            return nil -- Objekt existiert nicht mehr, daher nichts tun
        end
        
        -- Sicherheitscheck, ob das Property existiert
        local success, _ = pcall(function() 
            return object[property] 
        end)
        
        if not success then
            return nil -- Property existiert nicht
        end
        
        -- Standardwerte setzen
        delay = delay or 0
        easingStyle = easingStyle or Enum.EasingStyle.Quad
        easingDirection = easingDirection or Enum.EasingDirection.Out
        time = time or 0.3
        
        -- Tween erstellen und starten
        local tweenInfo = TweenInfo.new(time, easingStyle, easingDirection, 0, false, delay)
        
        local tween
        pcall(function()
            tween = game:GetService("TweenService"):Create(object, tweenInfo, {[property] = value})
            tween:Play()
        end)
        
        return tween
    end
    
    -- Animationen starten
    task.spawn(function()
        -- Hintergrund einblenden
        tweenProperty(backgroundFrame, "BackgroundTransparency", 0.2, 1)
        tweenProperty(blurEffect, "Size", 15, 1.5)
        tweenProperty(bloomEffect, "Intensity", 0.6, 1.5)
        
        -- Logo-Animation
        tweenProperty(logoImage, "ImageTransparency", 0, 1.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0.3)
        
        -- Logo pulsieren lassen
        task.spawn(function()
            while task.wait(0.05) do
                if not logoGlow or not logoGlow.Parent then break end
                
                local pulse = (math.sin(tick() * 1.5) + 1) / 2
                logoGlow.ImageTransparency = 0.5 + (pulse * 0.3)
                logoGlow.Size = UDim2.new(1.2 + (pulse * 0.1), 0, 1.2 + (pulse * 0.1), 0)
            end
        end)
        
        -- Text-Animationen
        tweenProperty(titleLabel, "TextTransparency", 0, 0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0.5)
        tweenProperty(subtitleLabel, "TextTransparency", 0, 0.8, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0.7)
        
        -- Panel-Animation (von unten hochfahren)
        keyPanel.Position = UDim2.new(0.5, 0, 1.2, 0) -- Außerhalb starten
        tweenProperty(keyPanel, "Position", UDim2.new(0.5, 0, 1, -150), 1, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0.2)
    end)
    
    -- Button Hover-Effekte
    loginButton.MouseEnter:Connect(function()
        tweenProperty(loginButton, "BackgroundColor3", Color3.fromRGB(100, 140, 255), 0.3)
        tweenProperty(loginButton, "Size", UDim2.new(0.72, 0, 0, 47), 0.3, Enum.EasingStyle.Back)
        tweenProperty(buttonGlow, "ImageTransparency", 0.7, 0.3)
        tweenProperty(buttonStroke, "Transparency", 0.3, 0.3)
        tweenProperty(buttonStroke, "Thickness", 2, 0.3)
        
        -- Gradient-Animation
        tweenProperty(buttonGradient, "Rotation", buttonGradient.Rotation + 45, 0.3)
        
        -- Text-Pulsieren
        task.spawn(function()
            local originalSize = loginButton.TextSize
            tweenProperty(loginButton, "TextSize", originalSize + 2, 0.2)
            task.wait(0.2)
            tweenProperty(loginButton, "TextSize", originalSize, 0.2)
        end)
        
        -- Hover-Partikel
        task.spawn(function()
            for i = 1, 5 do
                local particle = Instance.new("Frame")
                particle.Name = "HoverParticle"
                particle.Size = UDim2.new(0, math.random(3, 6), 0, math.random(3, 6))
                particle.Position = UDim2.new(math.random(10, 90)/100, 0, math.random(10, 90)/100, 0)
                particle.BackgroundColor3 = Color3.fromRGB(
                    math.random(150, 255),
                    math.random(150, 255),
                    255
                )
                particle.BackgroundTransparency = 0.6
                particle.BorderSizePixel = 0
                particle.ZIndex = loginButton.ZIndex + 1
                
                local particleCorner = Instance.new("UICorner")
                particleCorner.CornerRadius = UDim.new(1, 0)
                particleCorner.Parent = particle
                
                particle.Parent = loginButton
                
                -- Partikelanimation
                task.spawn(function()
                    local startY = particle.Position.Y.Scale
                    for j = 1, 10 do
                        particle.Position = UDim2.new(
                            particle.Position.X.Scale,
                            0,
                            startY - (j * 0.015),
                            0
                        )
                        particle.BackgroundTransparency = 0.6 + (j * 0.04)
                        task.wait(0.03)
                    end
                    particle:Destroy()
                end)
                
                task.wait(0.1)
            end
        end)
    end)
    
    loginButton.MouseLeave:Connect(function()
        tweenProperty(loginButton, "BackgroundColor3", Color3.fromRGB(60, 100, 255), 0.3)
        tweenProperty(loginButton, "Size", UDim2.new(0.7, 0, 0, 45), 0.3, Enum.EasingStyle.Back)
        tweenProperty(buttonGlow, "ImageTransparency", 0.9, 0.3)
        tweenProperty(buttonStroke, "Transparency", 0.7, 0.3)
        tweenProperty(buttonStroke, "Thickness", 1.5, 0.3)
        
        -- Gradient-Animation zurück
        tweenProperty(buttonGradient, "Rotation", buttonGradient.Rotation - 45, 0.3)
        
        -- Partikel löschen
        for _, child in pairs(loginButton:GetChildren()) do
            if child.Name == "HoverParticle" then
                child:Destroy()
            end
        end
    end)
    
    getKeyButton.MouseEnter:Connect(function()
        tweenProperty(getKeyButton, "TextColor3", Color3.fromRGB(180, 200, 255), 0.3)
    end)
    
    getKeyButton.MouseLeave:Connect(function()
        tweenProperty(getKeyButton, "TextColor3", Color3.fromRGB(130, 170, 255), 0.3)
    end)
    
    -- Event-Handler
    local keyLink = ""
    
    -- Versuche den Link mit beiden API-Versionen zu bekommen
    if KeyGuardianV2 then
        pcall(function()
            keyLink = KeyGuardianV2:GetKeylink()
        end)
    end
    
    -- Fallback auf ältere API, wenn noch kein Link vorhanden
    if keyLink == "" then
        pcall(function()
            keyLink = KeyGuardLibrary.getLink()
        end)
    end
    
    -- Status-Animation
    local function animateStatus(text, color)
        statusLabel.Text = ""
        statusLabel.TextTransparency = 1
        statusLabel.TextColor3 = color or Color3.fromRGB(150, 150, 180)
        
        tweenProperty(statusLabel, "TextTransparency", 0, 0.5)
        
        -- Text-Schreibeffekt
        task.spawn(function()
            for i = 1, #text do
                statusLabel.Text = string.sub(text, 1, i)
                task.wait(0.02)
            end
        end)
    end
    
    -- Login-Button-Logik
    loginButton.MouseButton1Click:Connect(function()
        local inputKey = keyInput.Text:gsub("%s+", "") -- Leerzeichen entfernen
        
        -- Sicherstellen, dass ein Key eingegeben wurde
        if inputKey == "" then
            animateStatus("Please enter your key", Color3.fromRGB(255, 150, 100))
            
            -- Verbesserte Button Shake-Animation
            local originalPos = inputContainer.Position
            local shakeIntensity = 8
            
            -- Hinzufügen eines Fehlersound-Effekts
            local errorEffect = Instance.new("Frame")
            errorEffect.Name = "ErrorEffect"
            errorEffect.Size = UDim2.new(1, 0, 1, 0)
            errorEffect.Position = UDim2.new(0.5, 0, 0.5, 0)
            errorEffect.AnchorPoint = Vector2.new(0.5, 0.5)
            errorEffect.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
            errorEffect.BackgroundTransparency = 0.8
            errorEffect.BorderSizePixel = 0
            
            local errorCorner = Instance.new("UICorner")
            errorCorner.CornerRadius = UDim.new(0, 8)
            errorCorner.Parent = errorEffect
            
            errorEffect.Parent = inputContainer
            
            -- Animierter Fehlerblink
            for i = 1, 2 do
                tweenProperty(errorEffect, "BackgroundTransparency", 0.6, 0.1)
                task.wait(0.1)
                tweenProperty(errorEffect, "BackgroundTransparency", 0.8, 0.1)
                task.wait(0.1)
            end
            
            for i = 1, 6 do
                local xOffset = i % 2 == 0 and shakeIntensity or -shakeIntensity
                tweenProperty(inputContainer, "Position", UDim2.new(originalPos.X.Scale, originalPos.X.Offset + xOffset, originalPos.Y.Scale, originalPos.Y.Offset), 0.06)
                
                -- Shake-Intensität verringern
                shakeIntensity = shakeIntensity * 0.8
                
                task.wait(0.06)
            end
            tweenProperty(inputContainer, "Position", originalPos, 0.1)
            
            task.wait(0.4)
            
            if errorEffect and errorEffect.Parent then
                errorEffect:Destroy()
            end
            
            return
        end
        
        -- EPIC button press animation
        -- Visual shockwave effect
        local shockwave = Instance.new("ImageLabel")
        shockwave.Name = "Shockwave"
        shockwave.Size = UDim2.new(0, 0, 0, 0)
        shockwave.Position = UDim2.new(0.5, 0, 0.5, 0)
        shockwave.AnchorPoint = Vector2.new(0.5, 0.5)
        shockwave.BackgroundTransparency = 1
        shockwave.Image = "rbxassetid://266543268" -- Ripple/shockwave effect
        shockwave.ImageColor3 = Color3.fromRGB(100, 150, 255)
        shockwave.ImageTransparency = 0.7
        shockwave.Parent = loginButton
        
        -- Animate shockwave
        tweenProperty(shockwave, "Size", UDim2.new(4, 0, 4, 0), 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        tweenProperty(shockwave, "ImageTransparency", 1, 0.5)
        
        task.delay(0.5, function()
            if shockwave and shockwave.Parent then
                shockwave:Destroy()
            end
        end)
        
        -- Create 3D animation of key entering a lock
        local keyModel = Instance.new("Part")
        keyModel.Name = "KeyModel"
        keyModel.Size = Vector3.new(2, 1, 0.5)
        keyModel.Position = Vector3.new(-5, 0, 15)
        keyModel.Anchored = true
        keyModel.CanCollide = false
        keyModel.Material = Enum.Material.Metal
        keyModel.Color = Color3.fromRGB(220, 220, 255)
        keyModel.Parent = worldModel
        
        -- Key teeth
        for i = 1, 3 do
            local tooth = Instance.new("Part")
            tooth.Size = Vector3.new(0.3, 0.5, 0.5)
            tooth.Position = Vector3.new(-5 + (i * 0.5) - 1.5, -0.5, 15)
            tooth.Anchored = true
            tooth.CanCollide = false
            tooth.Material = Enum.Material.Metal
            tooth.Color = Color3.fromRGB(220, 220, 255)
            tooth.Parent = worldModel
            
            -- Attach tooth to key for animation
            tooth.Name = "KeyTooth" .. i
        end
        
        -- Lock model
        local lockModel = Instance.new("Part") 
        lockModel.Name = "LockModel"
        lockModel.Size = Vector3.new(3, 2, 1)
        lockModel.Position = Vector3.new(5, 0, 15)
        lockModel.Anchored = true
        lockModel.CanCollide = false
        lockModel.Material = Enum.Material.Metal
        lockModel.Color = Color3.fromRGB(150, 150, 180)
        lockModel.Parent = worldModel
        
        -- Keyhole
        local keyhole = Instance.new("Part")
        keyhole.Name = "Keyhole"
        keyhole.Size = Vector3.new(0.5, 0.8, 1.1)
        keyhole.Position = Vector3.new(3.5, 0, 15)
        keyhole.Anchored = true
        keyhole.CanCollide = false
        keyhole.Material = Enum.Material.SmoothPlastic
        keyhole.Color = Color3.fromRGB(30, 30, 50)
        keyhole.Parent = worldModel
        
        -- Animate key into lock
        task.spawn(function()
            -- Move key towards lock
            for i = 1, 20 do
                local t = i/20
                local xPos = Lerp(-5, 3, t)
                
                keyModel.Position = Vector3.new(xPos, 0, 15)
                
                -- Update teeth positions
                for j = 1, 3 do
                    local tooth = worldModel:FindFirstChild("KeyTooth" .. j)
                    if tooth then
                        tooth.Position = Vector3.new(xPos + (j * 0.5) - 1.5, -0.5, 15)
                    end
                end
                
                task.wait(0.02)
            end
            
            -- Rotate key in lock
            local originalRot = keyModel.CFrame
            for i = 1, 10 do
                local angle = i/10 * math.pi/2
                keyModel.CFrame = CFrame.new(3, 0, 15) * CFrame.Angles(0, 0, angle)
                
                -- Update teeth positions with rotation
                for j = 1, 3 do
                    local tooth = worldModel:FindFirstChild("KeyTooth" .. j)
                    if tooth then
                        local offset = Vector3.new((j * 0.5) - 1.5, -0.5, 0)
                        local rotOffset = CFrame.new(3, 0, 15) * CFrame.Angles(0, 0, angle) * CFrame.new(offset)
                        tooth.Position = rotOffset.Position
                        tooth.Rotation = keyModel.Rotation
                    end
                end
                
                task.wait(0.03)
            end
        end)
        
        -- Login-Animation
        animateStatus("Validating key...", Color3.fromRGB(255, 255, 100))
        
        -- Button-Druck-Animation
        tweenProperty(loginButton, "Size", UDim2.new(0.68, 0, 0, 43), 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        tweenProperty(loginButton, "BackgroundColor3", Color3.fromRGB(40, 80, 220), 0.2)
        task.wait(0.2)
        tweenProperty(loginButton, "Size", UDim2.new(0.7, 0, 0, 45), 0.2, Enum.EasingStyle.Back)
        tweenProperty(loginButton, "BackgroundColor3", Color3.fromRGB(60, 100, 255), 0.2)
        
        -- Key validieren
        local isValid = validateKey(inputKey)
        
        task.wait(0.8) -- Zeit für die Animation
        
        if isValid then
            -- Key successful animation
            -- Emit glow from lock with verbesserter Effekt
            local lockGlow = Instance.new("PointLight")
            lockGlow.Name = "LockGlow"
            lockGlow.Color = Color3.fromRGB(100, 255, 150)
            lockGlow.Range = 15
            lockGlow.Brightness = 1
            lockGlow.Parent = lockModel
            
            -- Animate light brightness with pulsierendem Effekt
            task.spawn(function()
                for i = 1, 3 do
                    tweenProperty(lockGlow, "Brightness", 5, 0.2)
                    tweenProperty(lockGlow, "Range", 20, 0.2)
                    task.wait(0.2)
                    tweenProperty(lockGlow, "Brightness", 1, 0.2)
                    tweenProperty(lockGlow, "Range", 15, 0.2)
                    task.wait(0.2)
                end
                tweenProperty(lockGlow, "Brightness", 0, 0.5)
            end)
            
            -- Success particles from lock with dynamischen Farben
            local particleColors = {
                Color3.fromRGB(100, 255, 150),  -- Grün
                Color3.fromRGB(150, 255, 100),  -- Hellgrün
                Color3.fromRGB(100, 200, 255),  -- Blau
                Color3.fromRGB(200, 255, 100),  -- Gelbgrün
                Color3.fromRGB(150, 200, 255)   -- Hellblau
            }
            
            for i = 1, 60 do
                local successParticle = Instance.new("Part")
                successParticle.Shape = Enum.PartType.Ball
                successParticle.Size = Vector3.new(0.2, 0.2, 0.2)
                successParticle.Position = Vector3.new(5, 0, 15)
                successParticle.Anchored = true
                successParticle.CanCollide = false
                successParticle.Material = Enum.Material.Neon
                successParticle.Color = particleColors[math.random(1, #particleColors)]
                successParticle.Transparency = 0
                successParticle.Parent = worldModel
                
                -- Verbesserte Partikelanimation mit verschiedenen Bewegungsmustern
                task.spawn(function()
                    local speed = math.random(5, 20) / 10
                    local pattern = math.random(1, 3)
                    local direction
                    
                    if pattern == 1 then
                        -- Standard-Explosion
                        direction = Vector3.new(
                            math.random(-100, 100) / 100,
                            math.random(-100, 100) / 100,
                            math.random(-100, 100) / 100
                        ).Unit
                    elseif pattern == 2 then
                        -- Spiralmuster
                        local angle = math.rad(math.random(0, 360))
                        direction = Vector3.new(
                            math.cos(angle),
                            math.sin(angle),
                            math.random(-50, 50) / 100
                        ).Unit
                    else
                        -- Fontänenmuster
                        direction = Vector3.new(
                            math.random(-70, 70) / 100,
                            math.random(50, 100) / 100,
                            math.random(-70, 70) / 100
                        ).Unit
                    end
                    
                    local lifetime = math.random(20, 40)
                    
                    for j = 1, lifetime do
                        if pattern == 2 then
                            -- Für Spiralmuster: Richtung ändern
                            local t = j / lifetime
                            local angle = math.rad(j * 12) -- Winkel ändert sich mit der Zeit
                            direction = Vector3.new(
                                math.cos(angle) * (1 - t * 0.5),
                                math.sin(angle) * (1 - t * 0.5),
                                direction.Z
                            ).Unit
                        end
                        
                        successParticle.Position = successParticle.Position + direction * speed
                        
                        -- Bei manchen Partikeln Größe ändern
                        if j % 5 == 0 and math.random(1, 3) == 1 then
                            local pulseSize = math.random(80, 120) / 100
                            successParticle.Size = Vector3.new(0.2, 0.2, 0.2) * pulseSize
                        end
                        
                        -- Transparenz über die Zeit erhöhen
                        successParticle.Transparency = j / lifetime
                        
                        task.wait()
                    end
                    
                    successParticle:Destroy()
                end)
                
                -- Zeitversetzung für einen kontinuierlichen Strom von Partikeln
                if i % 10 == 0 then
                    task.wait(0.02)
                end
            end

            -- Erfolgsanimation mit pulsierendem Text
            loginButton.Text = "VERIFIED!"
            tweenProperty(loginButton, "BackgroundColor3", Color3.fromRGB(70, 200, 120), 0.3)
            
            -- Pulsierender Erfolgstext
            task.spawn(function()
                for i = 1, 3 do
                    tweenProperty(loginButton, "TextSize", 20, 0.2)
                    task.wait(0.2)
                    tweenProperty(loginButton, "TextSize", 18, 0.2)
                    task.wait(0.2)
                end
            end)
            
            -- Animierter Status mit Schreibeffekt
            animateStatus("Key accepted! Loading MythHub...", Color3.fromRGB(100, 255, 150))
            
            -- Speichere den validierten Key
            getgenv().MythHubKey = inputKey
            key = inputKey
            keyVerified = true
            
            -- Ausblenden mit Animation
            task.wait(1)
            
            -- Celebrate with fireworks before closing
            for i = 1, 5 do
                task.spawn(function()
                    local basePosition = Vector3.new(
                        math.random(-15, 15),
                        math.random(5, 15),
                        20
                    )
                    
                    -- Firework trail
                    for j = 1, 20 do
                        local trail = Instance.new("Part")
                        trail.Shape = Enum.PartType.Ball
                        trail.Size = Vector3.new(0.2, 0.2, 0.2)
                        trail.Position = basePosition - Vector3.new(0, j/5, 0)
                        trail.Anchored = true
                        trail.CanCollide = false
                        trail.Material = Enum.Material.Neon
                        trail.Color = Color3.fromRGB(255, 200, 100)
                        trail.Transparency = j/20
                        trail.Parent = worldModel
                        
                        task.delay(0.5, function()
                            trail:Destroy()
                        end)
                    end
                    
                    task.wait(0.5)
                    
                    -- Explosion
                    local colors = {
                        Color3.fromRGB(255, 50, 50),
                        Color3.fromRGB(50, 255, 50),
                        Color3.fromRGB(50, 50, 255),
                        Color3.fromRGB(255, 255, 50),
                        Color3.fromRGB(255, 50, 255),
                        Color3.fromRGB(50, 255, 255)
                    }
                    
                    local color = colors[math.random(1, #colors)]
                    
                    -- Explosion light
                    local explosionLight = Instance.new("PointLight")
                    explosionLight.Color = color
                    explosionLight.Range = 20
                    explosionLight.Brightness = 5
                    explosionLight.Position = basePosition
                    explosionLight.Parent = worldModel
                    
                    for j = 1, 30 do
                        local spark = Instance.new("Part")
                        spark.Shape = Enum.PartType.Ball
                        spark.Size = Vector3.new(0.3, 0.3, 0.3)
                        spark.Position = basePosition
                        spark.Anchored = true
                        spark.CanCollide = false
                        spark.Material = Enum.Material.Neon
                        spark.Color = color
                        spark.Transparency = 0
                        spark.Parent = worldModel
                        
                        task.spawn(function()
                            local dir = Vector3.new(
                                math.random(-100, 100),
                                math.random(-100, 100),
                                math.random(-20, 20)
                            ).Unit
                            
                            local speed = math.random(10, 30) / 10
                            
                            for k = 1, 20 do
                                spark.Position = spark.Position + dir * speed
                                spark.Transparency = k/20
                                task.wait()
                            end
                            
                            spark:Destroy()
                        end)
                    end
                    
                    task.delay(1, function()
                        tweenProperty(explosionLight, "Brightness", 0, 0.5)
                        task.delay(0.5, function()
                            explosionLight:Destroy()
                        end)
                    end)
                end)
                
                task.wait(math.random(20, 40) / 100)
            end
            
            tweenProperty(mainContainer, "Position", UDim2.new(0.5, 0, 1.5, 0), 1, Enum.EasingStyle.Back, Enum.EasingDirection.In)
            tweenProperty(blurEffect, "Size", 0, 1)
            tweenProperty(bloomEffect, "Intensity", 0, 1)
            tweenProperty(backgroundFrame, "BackgroundTransparency", 1, 1)
            
            task.wait(1.2)
            
            -- Clean up 3D models
            if keyModel and keyModel.Parent then keyModel:Destroy() end
            if lockModel and lockModel.Parent then lockModel:Destroy() end
            for i = 1, 3 do
                local tooth = worldModel:FindFirstChild("KeyTooth" .. i)
                if tooth then tooth:Destroy() end
            end
            if keyhole and keyhole.Parent then keyhole:Destroy() end
            
            -- UI entfernen
            if blurEffect and blurEffect.Parent then blurEffect:Destroy() end
            if bloomEffect and bloomEffect.Parent then bloomEffect:Destroy() end
            if screenGui and screenGui.Parent then screenGui:Destroy() end
        else
            -- Failed key animation
            -- Error effect in the 3D world
            local errorShake = Instance.new("Part")
            errorShake.Name = "ErrorShake"
            errorShake.Size = Vector3.new(15, 15, 1)
            errorShake.Position = Vector3.new(0, 0, 14)
            errorShake.Anchored = true
            errorShake.CanCollide = false
            errorShake.Material = Enum.Material.Neon
            errorShake.Color = Color3.fromRGB(255, 50, 50)
            errorShake.Transparency = 0.8
            errorShake.Parent = worldModel
            
            -- Red warning flash
            local redLight = Instance.new("PointLight")
            redLight.Color = Color3.fromRGB(255, 0, 0)
            redLight.Range = 20
            redLight.Brightness = 5
            redLight.Parent = errorShake
            
            -- Shake animation
            for i = 1, 5 do
                errorShake.Position = Vector3.new(math.random(-10, 10)/10, math.random(-10, 10)/10, 14)
                errorShake.Rotation = Vector3.new(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5))
                task.wait(0.05)
            end
            
            -- Fade out
            for i = 1, 10 do
                errorShake.Transparency = 0.8 + (i/50)
                redLight.Brightness = 5 - (i/2)
                task.wait(0.05)
            end
            
            errorShake:Destroy()
            
            -- Break the key
            task.spawn(function()
                -- Split the key into pieces
                for i = 1, 5 do
                    local keyPiece = Instance.new("Part")
                    keyPiece.Size = Vector3.new(math.random(3, 8)/10, math.random(3, 8)/10, math.random(3, 8)/10)
                    keyPiece.Position = keyModel.Position
                    keyPiece.Anchored = true
                    keyPiece.CanCollide = false
                    keyPiece.Material = Enum.Material.Metal
                    keyPiece.Color = Color3.fromRGB(220, 220, 255)
                    keyPiece.Parent = worldModel
                    
                    -- Animation
                    task.spawn(function()
                        local dir = Vector3.new(
                            math.random(-100, 100)/100,
                            math.random(-100, 100)/100,
                            math.random(-20, 20)/100
                        ).Unit
                        
                        local rotSpeed = Vector3.new(
                            math.random(-30, 30),
                            math.random(-30, 30),
                            math.random(-30, 30)
                        )
                        
                        for j = 1, 30 do
                            keyPiece.Position = keyPiece.Position + dir * 0.2
                            keyPiece.Orientation = keyPiece.Orientation + rotSpeed * 0.1
                            keyPiece.Transparency = j/30
                            task.wait()
                        end
                        
                        keyPiece:Destroy()
                    end)
                end
                
                -- Hide original key
                keyModel.Transparency = 1
                for j = 1, 3 do
                    local tooth = worldModel:FindFirstChild("KeyTooth" .. j)
                    if tooth then tooth.Transparency = 1 end
                end
            end)

            -- Fehler-Animation
            animateStatus("Invalid key!", Color3.fromRGB(255, 100, 100))
            
            -- Shake-Animation für den Button
            local originalPos = loginButton.Position
            for i = 1, 4 do
                tweenProperty(loginButton, "Position", UDim2.new(originalPos.X.Scale, originalPos.X.Offset + (i % 2 == 0 and 10 or -10), originalPos.Y.Scale, originalPos.Y.Offset), 0.08)
                task.wait(0.08)
            end
            tweenProperty(loginButton, "Position", originalPos, 0.1)
            
            -- Input leeren
            task.wait(0.3)
            keyInput.Text = ""
        end
    end)
    
    -- Get Key Button Logik
    getKeyButton.MouseButton1Click:Connect(function()
        setclipboard(keyLink)
        animateStatus("Link copied to clipboard!", Color3.fromRGB(100, 200, 255))
        
        -- Button-Animation
        tweenProperty(getKeyButton, "TextColor3", Color3.fromRGB(100, 255, 255), 0.3)
        tweenProperty(getKeyButton, "TextSize", 16, 0.2)
        task.wait(0.2)
        tweenProperty(getKeyButton, "TextSize", 14, 0.2)
        task.wait(1)
        tweenProperty(getKeyButton, "TextColor3", Color3.fromRGB(130, 170, 255), 0.5)
    end)
    
    -- Warte auf erfolgreiche Validierung
    local startTime = os.time()
    local maxWaitTime = 300 -- 5 Minuten Timeout
    
    print("KeyGuardian: Warte auf Benutzereingabe")
    
    while not keyVerified and os.time() - startTime < maxWaitTime do
        task.wait(0.5)
    end
    
    -- Abschließende Validierung
    if not keyVerified then
        print("KeyGuardian: Zeit abgelaufen oder Validierung fehlgeschlagen")
        
        -- Falls UI noch existiert, entfernen
        if screenGui and screenGui.Parent then
            if blurEffect and blurEffect.Parent then blurEffect:Destroy() end
            if bloomEffect and bloomEffect.Parent then bloomEffect:Destroy() end
            screenGui:Destroy()
        end
        
        return false
    end
    
    print("KeyGuardian: Validierung erfolgreich abgeschlossen")
    
    -- Falls UI noch existiert, entfernen
    if screenGui and screenGui.Parent then
        if blurEffect and blurEffect.Parent then blurEffect:Destroy() end
        if bloomEffect and bloomEffect.Parent then bloomEffect:Destroy() end
        screenGui:Destroy()
    end
				
    return true
end

-- Main-Ausführungslogik mit expliziter Prüfung
local validationResult = ValidateAndStartScript()

-- Überprüfe das Ergebnis und breche ab, wenn nicht validiert
if not validationResult then
    warn("MythHub: Key-Authentifizierung fehlgeschlagen oder abgebrochen!")
    return -- Breche das Skript ab, wenn der Key ungültig ist
end

print("MythHub: Key verifiziert, Script wird geladen!")

-- WindUI KeySystem überschreiben, um KeyGuardian zu verwenden
local originalKeySystem = WindUI.KeySystem
WindUI.KeySystem = function(options)
    if options and options.Title then
        return {
            Verify = function()
                return keyVerified -- Verwende die globale Statusvariable
            end
        }
    end
end

-- Ab hier beginnt das eigentliche MythHub-Script
local Window = WindUI:CreateWindow({
    Title = "MythHub",
    Icon = "star",
    Author = "MythHub",
    Folder = "MythHub",
    Size = UDim2.fromOffset(580, 460),
    Transparent = true,
    Theme = "Dark",
    UserEnabled = false,
    SideBarWidth = 200,
    HasOutline = true,
})

-- Create Tabs
local Tabs = {
    DashboardTab = Window:Tab({ Title = "Dashboard", Icon = "layout-dashboard", Desc = "Overview and statistics" }), -- Icon changed from 'home'
    AutoFarmTab = Window:Tab({ Title = "Auto Farm", Icon = "bot", Desc = "Automate enemy farming" }),
    TowersTab = Window:Tab({ Title = "Towers", Icon = "align-center", Desc = "Battle and Infinite Tower features" }), -- Icon changed from 'bar-chart-horizontal'
    RaidsTab = Window:Tab({ Title = "Raids", Icon = "swords", Desc = "Raid battle features" }), -- Icon changed from 'dragon'
    ExplorationTab = Window:Tab({ Title = "Exploration", Icon = "compass", Desc = "Automate exploration missions" }),
    ShopTab = Window:Tab({ Title = "Shop", Icon = "shopping-cart", Desc = "Purchase items automatically" }),
    MiscTab = Window:Tab({ Title = "Misc", Icon = "settings", Desc = "Miscellaneous features" }),
}

-- Select Dashboard tab by default
Window:SelectTab(1)

-- Konfigurationsverwaltung
local ConfigManager = {}

-- Konfigurationsstruktur
local Config = {
	autoFarmSettings = {
		selectedLocation = nil,
		selectedEnemy = nil,
		autoPickupEnabled = false
	},
	explorationSettings = {
		autoDeployEnabled = {
			easy = false,
			medium = false,
			hard = false,
			extreme = false,
			nightmare = false
		},
		autoClaimEnabled = {
			easy = false,
			medium = false,
			hard = false,
			extreme = false,
			nightmare = false
		}
	},
	towerSettings = {
		autoBattleTower = false,
		autoInfiniteTower = false,
		autoPauseInfiniteTower = false
	},
	raidSettings = {
		autoDetectDragon = false,
		autoEternalDragon = false,
		autoShadowDragon = false
	},
	miscSettings = {
		autoUpgradeStats = {
			BOSS_CHANCE = false,
			BORDER_CHANCE = false,
			POTION_DURATION = false,
			COOLDOWN_REDUCTION = false,
			LUCK = false
		},
		fpsBoostEnabled = false,
		disableParticles = false,
		webhookURL = "",
		webhookInterval = 15,
		webhookEnabled = false,
		antiAFKEnabled = true  -- Neue Option für Anti-AFK, standardmäßig aktiviert
	},
	customFarmSettings = {
		selectedLocations = {},
		includeNormal = true,
		includeBosses = false
	}
}

-- Auto Farm Section
local enemies = {
    ["Ninja Village"] = {
        "Rock Lee (unstoppable_fist)",
        "Kakashi (copy_ninja)",
        "Sasuke (awakened_dark_avenger)",
        "Naruto Sage (awakened_promised_child)",
        "Pain (six_paths_of_pain)",
        "Naruto Rage (bijuu_beast) [BOSS]"
    },
    ["Green Village"] = {
        "Son Gohan (ultimate_warrior)",
        "Captain Ginyu (body_switcher)",
        "Piccolo (namekian_sage)",
        "Vegeta (awakened_prideful_prince)",
        "Goku (awakened_earth_strongest)",
        "Frieza (awakened_galactic_tyrant) [BOSS]"
    },
    ["Shibuya Station"] = {
        "Nobara (cursed_doll)",
        "Megumi (awakened_shadow_summoner)",
        "Yuji (cursed_fist)",
        "Yuta (rika_blessing)",
        "Gojo (limitless_master)",
        "Sukuna (king_of_curses) [BOSS]"
    },
    ["Titans City"] = {
        "Erwin (survey_commander)",
        "Mikasa (blade_warrior)",
        "Reiner (armored_giant)",
        "Zeke (beast_giant)",
        "Levi (blade_captain)",
        "Eren (combat_giant) [BOSS]"
    },
    ["Dimensional Fortress"] = {
        "Kaigaku (thunder_demon)",
        "Hantengu (childish_demon)",
        "Akaza (compass_demon)",
        "Doma (awakened_frost_demon)",
        "Kokushibo (awakened_six_eyed_slayer)",
        "Muzan (awakened_pale_demon_lord) [BOSS]"
    },
    ["Candy Island"] = {
        "Daifuku (genie_commander)",
        "Perospero (candy_master)",
        "Cracker (biscuit_warrior)",
        "Smoothie (juice_queen)",
        "Katakuri (mochi_emperor)",
        "Big Mom (soul_queen) [BOSS]"
    },
    ["Solo City"] = {
        "Cha Hae-In (light_saintess)",
        "Thomas Andre (the_goliath)",
        "Tank (shadow_bear)",
        "Igris (shadow_commander)",
        "Beru (shadow_ant)",
        "Sung Jinwoo (awakened_shadow_monarch) [BOSS]"
    }
}

-- Auto Farm Tab Content
Tabs.AutoFarmTab:Section({ Title = "Enemy Farm" })

local selectedLocation = nil
local selectedEnemy = nil

local enemyDropdown = Tabs.AutoFarmTab:Dropdown({
    Title = "Select Enemy",
    Values = {},
    Callback = function(enemy)
        selectedEnemy = enemy
    end
})

Tabs.AutoFarmTab:Dropdown({
    Title = "Select Location",
    Values = {
        "Ninja Village",
        "Green Village",
        "Shibuya Station",
        "Titans City",
        "Dimensional Fortress",
        "Candy Island",
        "Solo City"
    },
    Callback = function(location)
        selectedLocation = location
        if enemies[location] then
            enemyDropdown:Refresh(enemies[location])
        end
    end
})

Tabs.AutoFarmTab:Toggle({
    Title = "Auto Farm Selected Enemy",
    Default = false,
    Callback = function(state)
        if state and selectedEnemy then
            -- Extract the enemy ID from the selected enemy string
            local enemyId = selectedEnemy:match("%(([^)]+)%)")
            if enemyId then
                -- Auto farm logic here
                local args = {
                    [1] = enemyId
                }
				game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("f8ea5400-f81a-4964-a0a1-c64a18f52f27"):FireServer(unpack(args))
            end
        end
    end
})

-- Towers Tab Content (NEUE STRUKTUR)

-- Battle Tower Section
Tabs.TowersTab:Section({ Title = "Battle Tower" })

Tabs.TowersTab:Toggle({
    Title = "Auto Battle Tower Highest",
    Default = false,
    Callback = function(state)
        _G.AutoBattleTowerHighest = state
        -- TODO: Implement logic for Auto Battle Tower Highest
        if state then
            print("Auto Battle Tower Highest: Enabled")
            -- Hier Logik hinzufügen, um den höchsten verfügbaren Turm automatisch zu starten/spielen
        else
            print("Auto Battle Tower Highest: Disabled")
        end
    end
})

Tabs.TowersTab:Toggle({
    Title = "Auto Battle Tower Selected Tier",
    Default = false,
    Callback = function(state)
        _G.AutoBattleTowerSelected = state
        -- TODO: Implement logic for Auto Battle Tower Selected Tier
        if state then
            local selectedTier = _G.SelectedBattleTowerTier or 1 -- Standardmäßig Tier 1 oder gespeicherten Wert verwenden
            print("Auto Battle Tower Selected Tier: Enabled for Tier " .. selectedTier)
            -- Hier Logik hinzufügen, um den ausgewählten Turm-Tier automatisch zu starten/spielen
        else
            print("Auto Battle Tower Selected Tier: Disabled")
        end
    end
})

Tabs.TowersTab:Dropdown({
    Title = "Select Tier Here",
    Default = "1", -- Standardwert
    List = {"1", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55", "60", "65", "70", "75", "80", "85", "90", "95", "100", "105", "110", "115", "120", "125", "130", "135", "140", "145", "150"}, -- Updated Tier List
    Callback = function(selectedTier)
        _G.SelectedBattleTowerTier = tonumber(selectedTier)
        print("Selected Battle Tower Tier: " .. selectedTier)
        -- Hier ggf. Logik hinzufügen, wenn ein Tier ausgewählt wird
    end
})

-- Infinite Tower Section (neu hinzugefügt)
Tabs.TowersTab:Section({ Title = "Infinite Tower" })

Tabs.TowersTab:Toggle({
    Title = "Auto Infinite Tower",
    Default = false,
    Callback = function(state)
        _G.AutoInfiniteTower = state -- Update the global state

        if state then
            print("Auto Infinite Tower: Enabled")
            -- Start the loop only if it's not already running to prevent multiple loops
            if not _G.InfiniteTowerLoopActive then
                _G.InfiniteTowerLoopActive = true
                spawn(function()
                    print("Infinite Tower Loop Started")
                    while _G.AutoInfiniteTower do -- Loop continues as long as the toggle is ON
			local args = {
				[1] = "infinite_tower"
			}
                        print("Firing Infinite Tower start event (every 5s)...")
                        local success, err = pcall(function()
			game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("67d0dfdd-f5a4-4eb6-a985-fe9e03e6e245"):FireServer(unpack(args))
                        end)
                        if not success then
                            print("Error firing Infinite Tower start event: " .. tostring(err))
                            -- Optional: Stop loop on error?
                            -- _G.AutoInfiniteTower = false 
                        end
                        wait(5) -- Wait for 5 seconds
                    end
                    -- Loop ended because toggle was turned off or an error occurred (if stopping on error)
                    print("Infinite Tower Loop Stopped")
                    _G.InfiniteTowerLoopActive = false -- Mark the loop as inactive
                end)
            end
        else
            print("Auto Infinite Tower: Disabled (Loop will stop on next iteration)")
            -- Setting _G.AutoInfiniteTower to false is enough to signal the loop to stop.
            -- The loop itself will set _G.InfiniteTowerLoopActive to false when it exits.
		end
	end
})

-- Nightmare Tower Section
Tabs.TowersTab:Section({ Title = "Nightmare Tower" })

Tabs.TowersTab:Toggle({
	Title = "Auto Nightmare Tower",
	Default = false,
	Callback = function(state)
		_G.AutoNightmareTower = state -- Update the global state

        if state then
            print("Auto Nightmare Tower: Enabled")
            -- Start the loop only if it's not already running to prevent multiple loops
            if not _G.NightmareTowerLoopActive then
                _G.NightmareTowerLoopActive = true
                spawn(function()
                    print("Nightmare Tower Loop Started")
                    while _G.AutoNightmareTower do -- Loop continues as long as the toggle is ON
						local args = {
							[1] = "nightmare_tower"
						}
                        print("Firing Nightmare Tower start event (every 5s)...")
                        local success, err = pcall(function()
							game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("67d0dfdd-f5a4-4eb6-a985-fe9e03e6e245"):FireServer(unpack(args))
                        end)
                        if not success then
                            print("Error firing Nightmare Tower start event: " .. tostring(err))
                        end
                        wait(5) -- Wait for 5 seconds
                    end
                    -- Loop ended because toggle was turned off
                    print("Nightmare Tower Loop Stopped")
                    _G.NightmareTowerLoopActive = false -- Mark the loop as inactive
                end)
            end
        else
            print("Auto Nightmare Tower: Disabled (Loop will stop on next iteration)")
            -- Setting _G.AutoNightmareTower to false is enough to signal the loop to stop.
            -- The loop itself will set _G.NightmareTowerLoopActive to false when it exits.
		end
    end
})

-- Raids Tab Content - Completely restructured
Tabs.RaidsTab:Section({ Title = "Raid Dragons" })

-- Dragon auto farm
Tabs.RaidsTab:Toggle({
    Title = "Auto Detect & Farm Active Dragon",
    Default = false,
    Callback = function(state)
        _G.AutoDetectDragon = state
        
        if state then
            -- Raid detection variables
            _G.InDragonRaid = false -- Whether player is in a raid
            _G.EndingRaid = false -- Whether raid is ending (reward screen)
            _G.LastRaidAttempt = 0 -- Time of last raid start attempt
            
            -- Virtual Input Function for clicking on screen
            local function virtualClick()
                -- Using VirtualInputManager to simulate clicks without moving cursor
                local vim = game:GetService("VirtualInputManager")
                local screenSize = workspace.CurrentCamera.ViewportSize
                
                -- Click in the center of the screen
                local centerX = screenSize.X / 2
                local centerY = screenSize.Y / 2
                
                -- Press and release mouse button 1 (left click)
                vim:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
                task.wait(0.1)
                vim:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
                
                -- Small delay between clicks
                task.wait(0.3)
            end
            
            -- Check current raid status
            _G.CheckRaidStatusConnection = game:GetService("RunService").Heartbeat:Connect(function()
                -- Check if player is in a fight
                local player = game.Players.LocalPlayer
                local playerGui = player:FindFirstChild("PlayerGui")
                
                if playerGui then
                    -- Use the specific GUIs mentioned to check if in battle
                    local inBattle = playerGui:FindFirstChild("battle") ~= nil or playerGui:FindFirstChild("HideBattleButton") ~= nil
                    local battleEnding = playerGui:FindFirstChild("reward-ui") ~= nil or playerGui:FindFirstChild("battle-end") ~= nil
                    
                    -- Update state based on GUI presence
                    if inBattle then
                        _G.InDragonRaid = true
                        _G.EndingRaid = false
                    elseif battleEnding then
                        -- Battle has ended, but rewards UI is showing
                        _G.InDragonRaid = false
                        _G.EndingRaid = true
                        
                        -- Click to dismiss reward screens
                        virtualClick()
                        virtualClick()
                        virtualClick()
                    else
                        -- No battle or ending screens
                        _G.InDragonRaid = false
                        _G.EndingRaid = false
                    end
                end
                
                -- Limit how often we check this
                task.wait(0.2)
            end)
            
            -- Main raid detection logic
            _G.DragonDetectionConnection = game:GetService("RunService").Heartbeat:Connect(function()
                -- If already in a raid or raid is ending, don't start new one
                if _G.InDragonRaid or _G.EndingRaid then
                    return
                end
                
                -- Check if we tried to start a raid recently (within 2 seconds)
                if os.time() - _G.LastRaidAttempt < 2 then
                    return
                end
                
                -- Path to the raid portal UI
                local raidPortal = workspace:FindFirstChild("lobby")
                if not raidPortal then return end
                
                local teleport = raidPortal:FindFirstChild("portals")
                if not teleport then return end
                
                local raidTeleport = teleport:FindFirstChild("raid_teleportation")
                if not raidTeleport then return end
                
                local attachment = raidTeleport:FindFirstChild("Attachment")
                if not attachment then return end
                
                local billboardGui = attachment:FindFirstChild("BillboardGui")
                if not billboardGui then return end
                
                -- Check if there's an active raid
                local dragonLabel = billboardGui:FindFirstChild("TextLabel")
                local timeLabel = billboardGui:GetChildren()[3]
                
                if dragonLabel and timeLabel then
                    local dragonText = dragonLabel.Text
                    local timeText = timeLabel.Text
                    
                    -- Check if there's a raid timer active
                    if timeText:match("Raid ends in %d+:%d+") then
                        local dragonType = nil
                        
                        -- Determine dragon type from label
                        if dragonText:match("Eternal Dragon") then
                            dragonType = "eternal_dragon"
                        elseif dragonText:match("Shadow Dragon") then
                            dragonType = "shadow_dragon"
                        end
                        
                        -- If dragon type is identified, start raid
                        if dragonType then
                            -- Update raid status and set attempt time
                            _G.LastRaidAttempt = os.time()
                            _G.InDragonRaid = true
                            
                            local args = {
                                [1] = dragonType
                            }
							game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("f8ea5400-f81a-4964-a0a1-c64a18f52f27"):FireServer(unpack(args))
                            
                            -- Notify user which raid is active
                            WindUI:Notify({
                                Title = "Auto Raid",
                                Content = "Starting " .. (dragonType == "eternal_dragon" and "Eternal Dragon" or "Shadow Dragon") .. " raid",
                                Duration = 3,
                                Icon = "dragon"
                            })
                        end
                    end
                end
                
                -- Wait to prevent excessive checks
                task.wait(1)
            end)
        else
            if _G.DragonDetectionConnection then
                _G.DragonDetectionConnection:Disconnect()
                _G.DragonDetectionConnection = nil
            end
            
            if _G.CheckRaidStatusConnection then
                _G.CheckRaidStatusConnection:Disconnect()
                _G.CheckRaidStatusConnection = nil
            end
            
            _G.InDragonRaid = false
            _G.EndingRaid = false
            _G.LastRaidAttempt = 0
        end
    end
})

-- Manual dragon options
Tabs.RaidsTab:Toggle({
    Title = "Auto Eternal Dragon",
    Default = false,
    Callback = function(state)
        if state then
            local args = {
                [1] = "eternal_dragon"
            }
			game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("f8ea5400-f81a-4964-a0a1-c64a18f52f27"):FireServer(unpack(args))
        end
    end
})

Tabs.RaidsTab:Toggle({
    Title = "Auto Shadow Dragon",
    Default = false,
    Callback = function(state)
        if state then
            local args = {
                [1] = "shadow_dragon"
            }
			game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("f8ea5400-f81a-4964-a0a1-c64a18f52f27"):FireServer(unpack(args))
        end
    end
})

-- Raid Potions - Completely separated section
Tabs.RaidsTab:Section({ Title = "Raid Potions" })

-- Raid Potions information
Tabs.RaidsTab:Paragraph({
    Title = "Raid Potions",
    Desc = "Purchase potions to improve raid drops and cooldowns",
    Color = "Orange",
    Image = "flask"
})

-- Raid Potions buttons
local raidPotions = {
    ["Raid Luck Potion"] = "raid_luck_potion",
    ["Raid Border Chance Potion"] = "raid_border_chance_potion",
    ["Raid Cooldown Potion"] = "raid_cooldown_potion",
    ["Raid Boss Chance Potion"] = "raid_boss_chance_potion",
    ["Raid Moon Cycle Reroll Potion"] = "raid_moon_cycle_reroll_potion"
}

for potionName, potionId in pairs(raidPotions) do
    Tabs.RaidsTab:Button({
        Title = "Buy " .. potionName,
        Callback = function()
            local args = {
                [1] = potionId,
                [2] = 1
            }
			game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("59a49ed0-d2f5-413d-bd73-d3f74eea2140"):FireServer(unpack(args))
            
            -- Notify user that the potion was purchased
            WindUI:Notify({
                Title = "Shop",
                Content = "Purchased: " .. potionName,
                Duration = 2,
                Icon = "shopping-cart"
            })
        end
    })
end

-- Exploration Tab Content
Tabs.ExplorationTab:Section({ Title = "Exploration" })

-- Setup deployments for each difficulty
local deploymentUnits = {
    ["Easy"] = {
		difficultyId = "easy",
		minDenominator = 10000 -- 10K
    },
    ["Medium"] = {
		difficultyId = "medium",
		minDenominator = 1000000 -- 1M
    },
    ["Hard"] = {
		difficultyId = "hard",
		minDenominator = 10000000 -- 10M
    },
    ["Extreme"] = {
		difficultyId = "hard", -- Änderung von "extreme" zu "hard" gemäß ScriptHubFeatures.txt
		minDenominator = 100000000 -- 100M
    },
    ["Nightmare"] = {
		difficultyId = "hard", -- Änderung von "nightmare" zu "hard" gemäß ScriptHubFeatures.txt
		minDenominator = 1000000000 -- 1B
	}
}

-- Function to find units with the lowest matching denominator for the difficulty
local function getBestUnitsForDeployment(minDenominator)
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RuntimeLib = ReplicatedStorage:WaitForChild("rbxts_include"):WaitForChild("RuntimeLib")
	local module = require(RuntimeLib)
	
	-- Import modules without using script
	local LocalUserModule = ReplicatedStorage:WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")
	local LocalUser = require(LocalUserModule).LocalUser
	
	-- Get all cards
	local bestUnits = {}
	
	local success, cards = pcall(function()
		return LocalUser.deck:getCards()
	end)
	
	if not success then
		-- Keine Benachrichtigung mehr, stattdessen nur Konsolen-Log
		print("Fehler: Konnte Karteninventar nicht abrufen")
		return {"light_admiral:rainbow", "light_admiral:rainbow", "light_admiral:rainbow", "light_admiral:rainbow"} -- Fallback
	end
	
	-- Karten in Array konvertieren und filtern nach passendem Denominator
	local cardArray = {}
	for cardId, userCard in pairs(cards) do
		local card = userCard:getCard()
		-- Nur Kampfkarten (keine Support-Karten) mit ausreichendem Denominator
		if not card.isSupport and card.denominator and card.denominator >= minDenominator then
			table.insert(cardArray, {
				id = card.id,
				denominator = card.denominator
			})
		end
	end
	
	-- Nach Denominator sortieren (aufsteigend, um die schwächsten passenden zuerst zu nehmen)
	table.sort(cardArray, function(a, b)
		return (a.denominator or 0) < (b.denominator or 0)
	end)
	
	-- Die 4 schwächsten passenden Karten auswählen (oder weniger, falls nicht genug vorhanden)
	for i = 1, 4 do
		if cardArray[i] then
			table.insert(bestUnits, cardArray[i].id)
		else
			table.insert(bestUnits, "light_admiral:rainbow") -- Fallback wenn nicht genügend Karten
		end
	end
	
	-- Keine Benachrichtigung mehr über ausgewählte Einheiten
	
	return bestUnits
end

-- Variablen für Exploration-Automatisierung
_G.ExplorationToggles = {
	easy = false,
	medium = false,
	hard = false,
	extreme = false,
	nightmare = false
}

-- Funktion zur automatischen Ausführung der Exploration-Aktionen
local function RunExplorationCycle()
	-- Nichts tun, wenn keine Schwierigkeit aktiviert ist
	local activeToggles = {}
	for diff, isEnabled in pairs(_G.ExplorationToggles) do
		if isEnabled then
			table.insert(activeToggles, diff)
		end
	end
	
	if #activeToggles == 0 then
		return
	end
	
	-- Aktuelle Phase (Deploy oder Claim) und aktuelle Schwierigkeit verfolgen
	_G.ExplorationPhase = _G.ExplorationPhase or "Deploy"
	_G.CurrentDifficultyIndex = _G.CurrentDifficultyIndex or 1
	
	-- Aktuelle Schwierigkeit ermitteln
	local currentDifficulty = activeToggles[_G.CurrentDifficultyIndex]
	
	-- Nichts tun, wenn keine Schwierigkeit gefunden wurde
	if not currentDifficulty then
		_G.CurrentDifficultyIndex = 1
		return
	end
	
	-- Die entsprechende Aktion für die aktuelle Schwierigkeit ausführen
	if _G.ExplorationPhase == "Deploy" then
		-- Deploy für aktuelle Schwierigkeit
		local difficultyName
		for name, info in pairs(deploymentUnits) do
			if info.difficultyId == currentDifficulty then
				difficultyName = name
				break
			end
		end
		
		-- Wenn keine passende Schwierigkeit gefunden wurde, uppercase first letter
		if not difficultyName then
			difficultyName = currentDifficulty:sub(1,1):upper() .. currentDifficulty:sub(2)
		end
		
		-- Keine Benachrichtigung mehr
		
		-- Einheiten auswählen und deployen
		local bestUnits = getBestUnitsForDeployment(deploymentUnits[difficultyName].minDenominator)
                local args = {
			[1] = currentDifficulty,
			[2] = bestUnits
		}
		game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("7e218913-87f3-4a0c-8337-ce1c31634afc"):FireServer(unpack(args))
		
		-- Zur nächsten Phase wechseln
		_G.ExplorationPhase = "Claim"
	else
		-- Claim für aktuelle Schwierigkeit
		local difficultyName = currentDifficulty:sub(1,1):upper() .. currentDifficulty:sub(2)
		
		-- Keine Benachrichtigung mehr
		
		-- Belohnungen abholen
		local args = {
			[1] = currentDifficulty
		}
		game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("dd4222d2-9feb-4f65-9937-16b4df7f81a3"):FireServer(unpack(args))
		
		-- Zur nächsten Phase und Schwierigkeit wechseln
		_G.ExplorationPhase = "Deploy"
		_G.CurrentDifficultyIndex = _G.CurrentDifficultyIndex + 1
		
		-- Wenn alle Schwierigkeiten durchlaufen wurden, von vorne beginnen
		if _G.CurrentDifficultyIndex > #activeToggles then
			_G.CurrentDifficultyIndex = 1
            end
        end
end

-- Timer-Verbindung zurücksetzen, falls vorhanden
if _G.ExplorationTimer then
	_G.ExplorationTimer:Disconnect()
	_G.ExplorationTimer = nil
end

-- Neuen Timer für den Exploration-Zyklus erstellen
spawn(function()
	while wait(3) do  -- 3 Sekunden zwischen den Aktionen warten
		pcall(RunExplorationCycle)
	end
end)

-- Strong visual separator
Tabs.ExplorationTab:Paragraph({
	Title = "Exploration Automatisierung",
	Desc = "Ein Toggle pro Schwierigkeit aktiviert beide Funktionen: Deploy und Claim",
    Color = "Blue",
    Image = "compass"
})

-- Unified toggles for each difficulty
local difficulties = {
	"Easy",
	"Medium",
	"Hard",
	"Extreme",
	"Nightmare"
}

for _, difficulty in ipairs(difficulties) do
	local lowerDiff = difficulty:lower()
	
	Tabs.ExplorationTab:Toggle({
		Title = "Auto " .. difficulty .. " (Deploy + Claim)",
		Default = false,
		Callback = function(state)
			_G.ExplorationToggles[lowerDiff] = state
			
			if state then
				-- Keine Benachrichtigung mehr
				
				-- Sofort die ersten Aktionen ausführen
				local claimArgs = {
					[1] = lowerDiff
				}
				game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("dd4222d2-9feb-4f65-9937-16b4df7f81a3"):FireServer(unpack(claimArgs))
				
				wait(1)
				
				local deployArgs = {
					[1] = deploymentUnits[difficulty].difficultyId,
					[2] = getBestUnitsForDeployment(deploymentUnits[difficulty].minDenominator)
				}
				game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("7e218913-87f3-4a0c-8337-ce1c31634afc"):FireServer(unpack(deployArgs))
			else
				-- Keine Benachrichtigung mehr
			end
		end
	})
end

-- Shop Tab Content - Completely restructured
Tabs.ShopTab:Section({ Title = "Shop" })

-- Shop introduction
Tabs.ShopTab:Paragraph({
    Title = "Regular Potions",
    Desc = "Purchase potions to boost gameplay",
    Color = "Blue",
    Image = "potion"
})

-- Small Potions
Tabs.ShopTab:Section({ Title = "Small Potions" })
local smallPotions = {
    ["Small Cooldown Reduction Potion"] = "small_cooldown_reduction_potion",
    ["Small Luck Potion"] = "small_luck_potion"
}

for potionName, potionId in pairs(smallPotions) do
    Tabs.ShopTab:Button({
        Title = "Buy " .. potionName,
        Callback = function()
            local args = {
                [1] = potionId,
                [2] = 1
            }
			game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("59a49ed0-d2f5-413d-bd73-d3f74eea2140"):FireServer(unpack(args))
            
            -- Notify user that the potion was purchased
            WindUI:Notify({
                Title = "Shop",
                Content = "Purchased: " .. potionName,
                Duration = 2,
                Icon = "shopping-cart"
            })
        end
    })
end

-- Medium Potions
Tabs.ShopTab:Section({ Title = "Medium Potions" })
local mediumPotions = {
    ["Medium Luck Potion"] = "medium_luck_potion",
    ["Medium Cooldown Reduction Potion"] = "medium_cooldown_reduction_potion"
}

for potionName, potionId in pairs(mediumPotions) do
    Tabs.ShopTab:Button({
        Title = "Buy " .. potionName,
        Callback = function()
            local args = {
                [1] = potionId,
                [2] = 1
            }
			game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("59a49ed0-d2f5-413d-bd73-d3f74eea2140"):FireServer(unpack(args))
            
            -- Notify user that the potion was purchased
            WindUI:Notify({
                Title = "Shop",
                Content = "Purchased: " .. potionName,
                Duration = 2,
                Icon = "shopping-cart"
            })
        end
    })
end

-- Large Potions
Tabs.ShopTab:Section({ Title = "Large Potions" })
local largePotions = {
    ["Large Cooldown Reduction Potion"] = "large_cooldown_reduction_potion",
    ["Large Luck Potion"] = "large_luck_potion"
}

for potionName, potionId in pairs(largePotions) do
    Tabs.ShopTab:Button({
        Title = "Buy " .. potionName,
        Callback = function()
            local args = {
                [1] = potionId,
                [2] = 1
            }
			game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("59a49ed0-d2f5-413d-bd73-d3f74eea2140"):FireServer(unpack(args))
            
            -- Notify user that the potion was purchased
            WindUI:Notify({
                Title = "Shop",
                Content = "Purchased: " .. potionName,
                Duration = 2,
                Icon = "shopping-cart"
            })
        end
    })
end

-- Misc Tab Content - Completely restructured
Tabs.MiscTab:Section({ Title = "Auto Stats" })

local stats = {
    ["Boss Chance"] = "BOSS_CHANCE",
    ["Border Chance"] = "BORDER_CHANCE",
    ["Potion Duration"] = "POTION_DURATION",
    ["Cooldown Reduction"] = "COOLDOWN_REDUCTION",
    ["Luck"] = "LUCK"
}

for statName, statId in pairs(stats) do
    Tabs.MiscTab:Toggle({
        Title = "Auto Upgrade " .. statName,
        Default = false,
        Callback = function(state)
            if state then
                local args = {
                    [1] = statId
                }
				game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("67367a95-f21c-4296-9c17-795351b6f6d3"):FireServer(unpack(args))
            end
        end
    })
end

-- Performance section
Tabs.MiscTab:Section({ Title = "Performance" })

Tabs.MiscTab:Paragraph({
    Title = "Performance Options",
    Desc = "Enhance your game performance with these settings",
    Color = "Green",
    Image = "settings"
})

-- Anti-AFK Toggle
Tabs.MiscTab:Toggle({
	Title = "Anti-AFK",
	Default = true, -- Changed from false to true
	Callback = function(state)
		_G.AntiAFK = state
		
		if state then
			-- Starte Anti-AFK
			_G.AntiAFKConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
				-- Simuliere Bewegung, um AFK-Kick zu verhindern
				local VirtualUser = game:GetService("VirtualUser")
				VirtualUser:CaptureController()
				VirtualUser:ClickButton2(Vector2.new())
				
				-- Benachrichtigung
				WindUI:Notify({
					Title = "Anti-AFK",
					Content = "AFK detection prevented",
					Duration = 2,
					Icon = "shield"
				})
			end)
			
			-- Benachrichtigung beim Aktivieren
			WindUI:Notify({
				Title = "Anti-AFK",
				Content = "Anti-AFK protection enabled",
				Duration = 3,
				Icon = "user-check"
			})
		else
			-- Stoppe Anti-AFK
			if _G.AntiAFKConnection then
				_G.AntiAFKConnection:Disconnect()
				_G.AntiAFKConnection = nil
			end
			
			-- Benachrichtigung beim Deaktivieren
			WindUI:Notify({
				Title = "Anti-AFK",
				Content = "Anti-AFK protection disabled",
				Duration = 3,
				Icon = "user-x"
			})
		end
	end
})

-- FPS Boost option
Tabs.MiscTab:Toggle({
    Title = "FPS Boost",
    Default = false,
    Callback = function(state)
        if state then
            -- Disable unnecessary rendering features
            local lighting = game:GetService("Lighting")
            
            -- Store original values to restore later
            _G.OriginalLightingSettings = {
                Brightness = lighting.Brightness,
                GlobalShadows = lighting.GlobalShadows,
                Technology = lighting.Technology,
                Ambient = lighting.Ambient,
                OutdoorAmbient = lighting.OutdoorAmbient
            }
            
            -- Apply performance settings
            lighting.GlobalShadows = false
            lighting.Technology = Enum.Technology.Compatibility
            lighting.Brightness = 0.1
            
            -- Reduce graphics quality
            settings().Rendering.QualityLevel = 1
            
            -- Remove terrain details
            workspace.Terrain.WaterWaveSize = 0
            workspace.Terrain.WaterWaveSpeed = 0
            workspace.Terrain.WaterReflectance = 0
            workspace.Terrain.WaterTransparency = 0
            
            -- Notify user
            WindUI:Notify({
                Title = "Performance",
                Content = "FPS Boost enabled",
                Duration = 3,
                Icon = "zap"
            })
        else
            -- Restore original settings
            if _G.OriginalLightingSettings then
                local lighting = game:GetService("Lighting")
                lighting.GlobalShadows = _G.OriginalLightingSettings.GlobalShadows
                lighting.Technology = _G.OriginalLightingSettings.Technology
                lighting.Brightness = _G.OriginalLightingSettings.Brightness
                lighting.Ambient = _G.OriginalLightingSettings.Ambient
                lighting.OutdoorAmbient = _G.OriginalLightingSettings.OutdoorAmbient
                
                -- Restore terrain
                workspace.Terrain.WaterWaveSize = 0.15
                workspace.Terrain.WaterWaveSpeed = 10
                workspace.Terrain.WaterReflectance = 0.05
                workspace.Terrain.WaterTransparency = 0.7
                
                -- Restore graphics quality
                settings().Rendering.QualityLevel = 7
                
                _G.OriginalLightingSettings = nil
                
                -- Notify user
                WindUI:Notify({
                    Title = "Performance",
                    Content = "FPS Boost disabled",
                    Duration = 3,
                    Icon = "zap-off"
                })
            end
        end
    end
})

-- Disable particles option
Tabs.MiscTab:Toggle({
    Title = "Disable Particles",
    Default = false,
    Callback = function(state)
        _G.DisableParticles = state
        
        if state then
            -- Connect to RenderStepped to disable particles as they appear
            _G.ParticleConnection = game:GetService("RunService").RenderStepped:Connect(function()
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Fire") or v:IsA("Sparkles") then
                        v.Enabled = false
                    end
                end
            end)
            
            -- Notify user
            WindUI:Notify({
                Title = "Performance",
                Content = "Particles disabled",
                Duration = 3,
                Icon = "snowflake-off"
            })
        else
            if _G.ParticleConnection then
                _G.ParticleConnection:Disconnect()
                _G.ParticleConnection = nil
            end
            
            -- Notify user
            WindUI:Notify({
                Title = "Performance",
                Content = "Particles enabled",
                Duration = 3,
                Icon = "snowflake"
            })
        end
    end
})

-- Webhook settings section
Tabs.MiscTab:Section({ Title = "Discord Webhook" })

Tabs.MiscTab:Paragraph({
    Title = "Discord Notifications",
    Desc = "Send game notifications to your Discord server",
    Color = "Blue",
    Image = "message-square"
})

-- Webhook URL input
Tabs.MiscTab:Input({
    Title = "Discord Webhook URL",
    Default = "",
    PlaceholderText = "Enter your Discord webhook URL here",
    Callback = function(input)
        _G.WebhookURL = input
    end
})

-- Webhook interval dropdown
local webhookIntervals = {"5", "10", "15", "30", "60"}
Tabs.MiscTab:Dropdown({
    Title = "Notification Interval (minutes)",
    Values = webhookIntervals,
    Default = "15",
    Callback = function(selected)
        _G.WebhookInterval = tonumber(selected)
    end
})

-- Toggle webhook notifications
Tabs.MiscTab:Toggle({
    Title = "Enable Discord Notifications",
    Default = false,
    Callback = function(state)
        _G.WebhookEnabled = state
        
        if state then
            if not _G.WebhookURL or _G.WebhookURL == "" then
                WindUI:Notify({
                    Title = "Webhook Error",
                    Content = "Please enter a valid webhook URL first",
                    Duration = 5,
                    Icon = "alert-triangle",
                    Color = "Red"
                })
                return
            end
            
            -- Start webhook notifications
            _G.LastWebhookTime = os.time()
            
            _G.WebhookConnection = game:GetService("RunService").Heartbeat:Connect(function()
                -- Check if it's time to send a webhook
                local currentTime = os.time()
                local intervalInSeconds = (_G.WebhookInterval or 15) * 60
                
                if currentTime - _G.LastWebhookTime >= intervalInSeconds then
                    -- Send webhook notification
                    -- This function will be implemented later
                    WindUI:Notify({
                        Title = "Discord Notification",
                        Content = "Sending update to Discord...",
                        Duration = 3,
                        Icon = "send"
                    })
                    
                    -- Update last webhook time
                    _G.LastWebhookTime = currentTime
                end
                
                -- Only check every 30 seconds to save performance
                task.wait(30)
            end)
        else
            if _G.WebhookConnection then
                _G.WebhookConnection:Disconnect()
                _G.WebhookConnection = nil
            end
        end
    end
})

-- Auto Farm Tab additional content
Tabs.AutoFarmTab:Section({ Title = "Auto Pickup" })

Tabs.AutoFarmTab:Toggle({
    Title = "Auto Pickup Items",
    Default = false,
    Callback = function(state)
        _G.AutoPickup = state
        
        if state then
            -- Initialize variables
            _G.LastItemCheck = 0
            _G.TargetItem = nil
            _G.CurrentlyTweening = false
            
            -- Function to find the closest item
            local function findClosestItem()
                local player = game.Players.LocalPlayer
                local character = player.Character
                
                if not character then return nil end
                
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if not humanoidRootPart then return nil end
                
                -- Check for items in the folder
                local folder = workspace:FindFirstChild("Folder")
                if not folder then return nil end
                
                -- Get all items in the folder
                local items = folder:GetChildren()
                
                if #items == 0 then return nil end
                
                -- Find the closest item
                local closestItem = nil
                local closestDistance = math.huge
                
                for _, item in pairs(items) do
                    if item:IsA("Model") then
                        local itemPosition = item:GetPivot().Position
                        local distance = (itemPosition - humanoidRootPart.Position).Magnitude
                        
                        if distance < closestDistance then
                            closestDistance = distance
                            closestItem = item
                        end
                    end
                end
                
                return closestItem
            end
            
            -- Auto pickup loop with better performance
            _G.AutoPickupConnection = game:GetService("RunService").Heartbeat:Connect(function()
                local player = game.Players.LocalPlayer
                local character = player.Character
                
                if not character then return end
                
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if not humanoidRootPart then return end
                
                -- If we're currently tweening to an item, don't search for a new one
                if _G.CurrentlyTweening then return end
                
                -- Check if we have a target item and it still exists
                if _G.TargetItem and _G.TargetItem.Parent then
                    -- We already have a target, continue moving to it
                    local itemPosition = _G.TargetItem:GetPivot().Position
                    local distance = (itemPosition - humanoidRootPart.Position).Magnitude
                    
                    -- If we're close enough, we probably picked it up
                    if distance < 5 then
                        WindUI:Notify({
                            Title = "Auto Pickup",
                            Content = "Item collected",
                            Duration = 1,
                            Icon = "check"
                        })
                        
                        _G.TargetItem = nil
                        
                        -- Immediately find the next item
                        _G.TargetItem = findClosestItem()
                        if _G.TargetItem then
                            WindUI:Notify({
                                Title = "Auto Pickup",
                                Content = "Moving to next item",
                                Duration = 1,
                                Icon = "package"
                            })
                        end
                        
                        return
                    end
                    
                    -- Calculate tween time based on distance (faster for closer items)
                    local tweenTime = math.min(distance / 100, 1.5)
                    
                    _G.CurrentlyTweening = true
                    
                    -- Tween to item position
                    local tween = game:GetService("TweenService"):Create(
                        humanoidRootPart,
                        TweenInfo.new(tweenTime, Enum.EasingStyle.Linear),
                        {CFrame = CFrame.new(itemPosition)}
                    )
                    
                    tween:Play()
                    
                    tween.Completed:Connect(function()
                        task.wait(0.2) -- Small wait to pick up item
                        _G.CurrentlyTweening = false
                        
                        -- Check if we still have the same target and it exists
                        if _G.TargetItem and _G.TargetItem.Parent then
                            -- If we're still far from the item after tweening, it might be unreachable
                            local newDistance = (_G.TargetItem:GetPivot().Position - humanoidRootPart.Position).Magnitude
                            if newDistance > 10 then
                                -- Item might be unreachable, forget it
                                _G.TargetItem = nil
                                
                                -- Try to find a new item immediately
                                _G.TargetItem = findClosestItem()
                            end
                        else
                            -- Item no longer exists, we probably picked it up
                            _G.TargetItem = nil
                            
                            -- Try to find a new item immediately
                            _G.TargetItem = findClosestItem()
                            if _G.TargetItem then
                                WindUI:Notify({
                                    Title = "Auto Pickup",
                                    Content = "Moving to next item",
                                    Duration = 1,
                                    Icon = "package"
                                })
                            end
                        end
                    end)
                else
                    -- Only check for new items every 0.5 seconds if we don't have a target
                    local currentTime = tick()
                    if currentTime - _G.LastItemCheck < 0.5 then 
                        return
                    end
                    
                    _G.LastItemCheck = currentTime
                    
                    -- Find a new target item
                    _G.TargetItem = findClosestItem()
                    
                    if _G.TargetItem then
                        WindUI:Notify({
                            Title = "Auto Pickup",
                            Content = "Moving to item",
                            Duration = 1,
                            Icon = "package"
                        })
                    end
                end
            end)
        else
            if _G.AutoPickupConnection then
                _G.AutoPickupConnection:Disconnect()
                _G.AutoPickupConnection = nil
            end
            _G.CurrentlyTweening = false
            _G.TargetItem = nil
        end
    end
})

-- Debug button to show items in Folder
Tabs.AutoFarmTab:Button({
    Title = "Check Available Items",
    Callback = function()
        local folder = workspace:FindFirstChild("Folder")
        if not folder then
            WindUI:Notify({
                Title = "Items",
                Content = "No item folder found",
                Duration = 3,
                Icon = "alert-triangle",
                Color = "Red"
            })
            return
        end
        
        local items = folder:GetChildren()
        
        WindUI:Notify({
            Title = "Items Found",
            Content = "Found " .. #items .. " items in the world",
            Duration = 3,
            Icon = "package"
        })
        
        -- Print item details to console
        print("\n==== ITEMS IN WORLD ====")
        for i, item in ipairs(items) do
            if i <= 10 then -- Only print first 10 to avoid spam
                print("Item " .. i .. ": " .. item.Name .. " (Type: " .. item.ClassName .. ")")
            end
        end
        if #items > 10 then
            print("... and " .. (#items - 10) .. " more items")
        end
        print("=======================")
    end
})

-- Auto Farm All Enemies and Bosses
Tabs.AutoFarmTab:Section({ Title = "Auto Farm Sequences" })

-- Definition aller Gegner
local allEnemies = {
    -- Ninja Village
    {name = "Rock Lee", id = "unstoppable_fist", isBoss = false, location = "Ninja Village"},
    {name = "Kakashi", id = "copy_ninja", isBoss = false, location = "Ninja Village"},
    {name = "Sasuke", id = "awakened_dark_avenger", isBoss = false, location = "Ninja Village"},
    {name = "Naruto Sage", id = "awakened_promised_child", isBoss = false, location = "Ninja Village"},
    {name = "Pain", id = "six_paths_of_pain", isBoss = false, location = "Ninja Village"},
    {name = "Naruto Rage", id = "bijuu_beast", isBoss = true, location = "Ninja Village"},
    
    -- Green Village
    {name = "Son Gohan", id = "ultimate_warrior", isBoss = false, location = "Green Village"},
    {name = "Captain Ginyu", id = "body_switcher", isBoss = false, location = "Green Village"},
    {name = "Piccolo", id = "namekian_sage", isBoss = false, location = "Green Village"},
    {name = "Vegeta", id = "awakened_prideful_prince", isBoss = false, location = "Green Village"},
    {name = "Goku", id = "awakened_earth_strongest", isBoss = false, location = "Green Village"},
    {name = "Frieza", id = "awakened_galactic_tyrant", isBoss = true, location = "Green Village"},
    
    -- Shibuya Station
    {name = "Nobara", id = "cursed_doll", isBoss = false, location = "Shibuya Station"},
    {name = "Megumi", id = "awakened_shadow_summoner", isBoss = false, location = "Shibuya Station"},
    {name = "Yuji", id = "cursed_fist", isBoss = false, location = "Shibuya Station"},
    {name = "Yuta", id = "rika_blessing", isBoss = false, location = "Shibuya Station"},
    {name = "Gojo", id = "limitless_master", isBoss = false, location = "Shibuya Station"},
    {name = "Sukuna", id = "king_of_curses", isBoss = true, location = "Shibuya Station"},
    
    -- Titans City
    {name = "Erwin", id = "survey_commander", isBoss = false, location = "Titans City"},
    {name = "Mikasa", id = "blade_warrior", isBoss = false, location = "Titans City"},
    {name = "Reiner", id = "armored_giant", isBoss = false, location = "Titans City"},
    {name = "Zeke", id = "beast_giant", isBoss = false, location = "Titans City"},
    {name = "Levi", id = "blade_captain", isBoss = false, location = "Titans City"},
    {name = "Eren", id = "combat_giant", isBoss = true, location = "Titans City"},
    
    -- Dimensional Fortress
    {name = "Kaigaku", id = "thunder_demon", isBoss = false, location = "Dimensional Fortress"},
    {name = "Hantengu", id = "childish_demon", isBoss = false, location = "Dimensional Fortress"},
    {name = "Akaza", id = "compass_demon", isBoss = false, location = "Dimensional Fortress"},
    {name = "Doma", id = "awakened_frost_demon", isBoss = false, location = "Dimensional Fortress"},
    {name = "Kokushibo", id = "awakened_six_eyed_slayer", isBoss = false, location = "Dimensional Fortress"},
    {name = "Muzan", id = "awakened_pale_demon_lord", isBoss = true, location = "Dimensional Fortress"},
    
    -- Candy Island
    {name = "Daifuku", id = "genie_commander", isBoss = false, location = "Candy Island"},
    {name = "Perospero", id = "candy_master", isBoss = false, location = "Candy Island"},
    {name = "Cracker", id = "biscuit_warrior", isBoss = false, location = "Candy Island"},
    {name = "Smoothie", id = "juice_queen", isBoss = false, location = "Candy Island"},
    {name = "Katakuri", id = "mochi_emperor", isBoss = false, location = "Candy Island"},
    {name = "Big Mom", id = "soul_queen", isBoss = true, location = "Candy Island"},
    
    -- Solo City
    {name = "Cha Hae-In", id = "light_saintess", isBoss = false, location = "Solo City"},
    {name = "Thomas Andre", id = "the_goliath", isBoss = false, location = "Solo City"},
    {name = "Tank", id = "shadow_bear", isBoss = false, location = "Solo City"},
    {name = "Igris", id = "shadow_commander", isBoss = false, location = "Solo City"},
    {name = "Beru", id = "shadow_ant", isBoss = false, location = "Solo City"},
    {name = "Sung Jinwoo", id = "awakened_shadow_monarch", isBoss = true, location = "Solo City"}
}

-- Kampffunktion für alle Auto-Farm Modi
local function fightEnemy(enemyId)
    local args = {
        [1] = enemyId
    }
	game:GetService("ReplicatedStorage"):WaitForChild("aJv"):WaitForChild("f8ea5400-f81a-4964-a0a1-c64a18f52f27"):FireServer(unpack(args))
end

-- Auto Farm alle normalen Gegner
Tabs.AutoFarmTab:Toggle({
    Title = "Auto Farm All Normal Enemies",
    Default = false,
    Callback = function(state)
        _G.AutoFarmAllEnemies = state
        
        if state then
            -- Globale Variablen für das Auto-Farming
            _G.CurrentEnemyIndex = 1
            _G.InBattle = false
            _G.LastEnemyTime = 0
            
            -- Kampfstatus erkennen
            _G.BattleStatusConnection = game:GetService("RunService").Heartbeat:Connect(function()
                local player = game.Players.LocalPlayer
                local playerGui = player:FindFirstChild("PlayerGui")
                
                if playerGui then
                    -- Überprüfen, ob der Spieler in einem Kampf ist
                    local inBattle = playerGui:FindFirstChild("battle") ~= nil or 
                                     playerGui:FindFirstChild("HideBattleButton") ~= nil
                    _G.InBattle = inBattle
                end
                
                task.wait(0.5) -- Überprüfen Sie den Kampfstatus alle 0,5 Sekunden
            end)
            
            -- Auto Farm Loop für normale Gegner
            _G.AutoFarmEnemiesConnection = game:GetService("RunService").Heartbeat:Connect(function()
                -- Wenn der Spieler in einem Kampf ist, nicht fortfahren
                if _G.InBattle then return end
                
                -- Warten Sie zwischen den Gegnern
                local currentTime = os.time()
                if currentTime - _G.LastEnemyTime < 5 then 
                    return 
                end
                
                -- Sortiere Feinde für normales Farming (keine Bosse)
                local regularEnemies = {}
                for _, enemy in ipairs(allEnemies) do
                    if not enemy.isBoss then
                        table.insert(regularEnemies, enemy)
                    end
                end
                
                -- Wenn alle Gegner bekämpft wurden, beginnen Sie von vorne
                if _G.CurrentEnemyIndex > #regularEnemies then
                    _G.CurrentEnemyIndex = 1
                    
                    WindUI:Notify({
                        Title = "Auto Farm",
                        Content = "Alle Gegner bekämpft, starte von vorne",
                        Duration = 3,
                        Icon = "refresh-cw"
                    })
                    
                    return
                end
                
                -- Gegner bekämpfen
                local currentEnemy = regularEnemies[_G.CurrentEnemyIndex]
                fightEnemy(currentEnemy.id)
                
                -- Aktualisieren Sie Variablen
                _G.LastEnemyTime = currentTime
                _G.CurrentEnemyIndex = _G.CurrentEnemyIndex + 1
                
                -- Benachrichtigung anzeigen
                WindUI:Notify({
                    Title = "Auto Farm",
                    Content = "Bekämpfe " .. currentEnemy.name .. " in " .. currentEnemy.location,
                    Duration = 3,
                    Icon = "swords"
                })
            end)
        else
            -- Verbindungen trennen, wenn deaktiviert
            if _G.AutoFarmEnemiesConnection then
                _G.AutoFarmEnemiesConnection:Disconnect()
                _G.AutoFarmEnemiesConnection = nil
            end
            
            if _G.BattleStatusConnection then
                _G.BattleStatusConnection:Disconnect()
                _G.BattleStatusConnection = nil
            end
        end
    end
})

-- Auto Farm alle Bosse
Tabs.AutoFarmTab:Toggle({
    Title = "Auto Farm All Bosses",
    Default = false,
    Callback = function(state)
        _G.AutoFarmAllBosses = state
        
        if state then
            -- Globale Variablen für das Boss-Farming
            _G.CurrentBossIndex = 1
            _G.InBossBattle = false
            _G.LastBossTime = 0
            
            -- Kampfstatus erkennen (falls noch nicht verbunden)
            if not _G.BattleStatusConnection then
                _G.BattleStatusConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    local player = game.Players.LocalPlayer
                    local playerGui = player:FindFirstChild("PlayerGui")
                    
                    if playerGui then
                        -- Überprüfen, ob der Spieler in einem Kampf ist
                        local inBattle = playerGui:FindFirstChild("battle") ~= nil or 
                                         playerGui:FindFirstChild("HideBattleButton") ~= nil
                        _G.InBossBattle = inBattle
                    end
                    
                    task.wait(0.5)
                end)
            end
            
            -- Boss Auto Farm Loop
            _G.AutoFarmBossesConnection = game:GetService("RunService").Heartbeat:Connect(function()
                -- Wenn der Spieler in einem Kampf ist, nicht fortfahren
                if _G.InBossBattle then return end
                
                -- Warten Sie zwischen den Bossen
                local currentTime = os.time()
                if currentTime - _G.LastBossTime < 5 then 
                    return 
                end
                
                -- Bosse filtern
                local bosses = {}
                for _, enemy in ipairs(allEnemies) do
                    if enemy.isBoss then
                        table.insert(bosses, enemy)
                    end
                end
                
                -- Wenn alle Bosse bekämpft wurden, beginnen Sie von vorne
                if _G.CurrentBossIndex > #bosses then
                    _G.CurrentBossIndex = 1
                    
                    WindUI:Notify({
                        Title = "Boss Farm",
                        Content = "Alle Bosse bekämpft, starte von vorne",
                        Duration = 3,
                        Icon = "refresh-cw"
                    })
                    
                    return
                end
                
                -- Boss bekämpfen
                local currentBoss = bosses[_G.CurrentBossIndex]
                fightEnemy(currentBoss.id)
                
                -- Aktualisieren Sie Variablen
                _G.LastBossTime = currentTime
                _G.CurrentBossIndex = _G.CurrentBossIndex + 1
                
                -- Benachrichtigung anzeigen
                WindUI:Notify({
                    Title = "Boss Farm",
                    Content = "Bekämpfe BOSS: " .. currentBoss.name .. " in " .. currentBoss.location,
                    Duration = 3,
                    Icon = "shield"
                })
            end)
        else
            -- Verbindungen trennen, wenn deaktiviert
            if _G.AutoFarmBossesConnection then
                _G.AutoFarmBossesConnection:Disconnect()
                _G.AutoFarmBossesConnection = nil
            end
            
            -- Trennen Sie die BattleStatusConnection nur, wenn beide Auto Farm-Optionen deaktiviert sind
            if not _G.AutoFarmAllEnemies and _G.BattleStatusConnection then
                _G.BattleStatusConnection:Disconnect()
                _G.BattleStatusConnection = nil
            end
        end
    end
})

-- Information zur Abklingzeit
Tabs.AutoFarmTab:Paragraph({
    Title = "Important Note",
    Desc = "All enemies and bosses have a cooldown time of 10 minutes after being defeated!",
    Color = "Orange",
    Image = "info"
})

-- Dashboard Tab content
Tabs.DashboardTab:Section({ Title = "Player Info" })

Tabs.DashboardTab:Paragraph({
    Title = "MythHub Dashboard",
    Desc = "Welcome to MythHub - Your ultimate anime game assistant",
    Color = "Blue",
    Image = "home"
})

-- Current player info
Tabs.DashboardTab:Button({
    Title = "Check Stats",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local success, LocalUser = pcall(function()
            return require(ReplicatedStorage:WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        end)
        
        if not success then
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to load player data",
                Duration = 3,
                Icon = "alert-triangle",
                Color = "Red"
            })
            return
        end
        
        -- Try to get player stats
        local stats = {}
        
        pcall(function()
            -- Available upgrade points
            stats.upgradePoints = LocalUser.upgrades:getCards() or 0
            
            -- Get other important stats
            stats.battleTowerWave = LocalUser.metadata:getAsNumber("battle_tower_wave") or 1
            stats.level = LocalUser.profile:getLevel() or 1
            stats.exp = LocalUser.profile:getExperience() or 0
        end)
        
        -- Notify stats
        WindUI:Notify({
            Title = "Player Stats",
            Content = "Level: " .. (stats.level or "N/A") .. 
                     "\nExp: " .. (stats.exp or "N/A") ..
                     "\nUpgrade Points: " .. (stats.upgradePoints or "N/A") .. 
                     "\nBattle Tower Level: " .. (stats.battleTowerWave or "N/A"),
            Duration = 5,
            Icon = "info"
        })
    end
})

-- Active timers and boosts
Tabs.DashboardTab:Button({
    Title = "Check Active Boosts",
    Callback = function()
        local player = game.Players.LocalPlayer
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local success, LocalUser = pcall(function()
            return require(ReplicatedStorage:WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        end)
        
        if not success then
            WindUI:Notify({
                Title = "Error",
                Content = "Failed to load player data",
                Duration = 3,
                Icon = "alert-triangle",
                Color = "Red"
            })
            return
        end
        
        -- Check for active potions
        local potions = {}
        
        pcall(function()
            local backpackItems = LocalUser.atomMap.player().backpack.items
            
            for itemId, itemData in pairs(backpackItems) do
                if itemData.equipped then
                    table.insert(potions, itemId)
                end
            end
        end)
        
        if #potions > 0 then
            WindUI:Notify({
                Title = "Active Boosts",
                Content = #potions .. " active boost(s) found",
                Duration = 3,
                Icon = "zap"
            })
        else
            WindUI:Notify({
                Title = "Active Boosts",
                Content = "No active boosts found",
                Duration = 3,
                Icon = "zap-off"
            })
        end
    end
})

-- Game server info
Tabs.DashboardTab:Button({
    Title = "Server Info",
    Callback = function()
        local players = game:GetService("Players"):GetPlayers()
        local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
        local fps = math.floor(1/game:GetService("RunService").RenderStepped:Wait())
        
        WindUI:Notify({
            Title = "Server Info",
            Content = "Players: " .. #players .. "/12\nPing: " .. math.floor(ping) .. "ms\nFPS: " .. fps,
            Duration = 5,
            Icon = "server"
        })
    end
})

-- Quick actions section
Tabs.DashboardTab:Section({ Title = "Quick Actions" })

Tabs.DashboardTab:Button({
    Title = "Check Inventory",
    Callback = function()
        -- Display inventory notification
        WindUI:Notify({
            Title = "Inventory Check",
            Content = "View console for detailed inventory information",
            Duration = 5,
            Icon = "package"
        })
        
        -- Print card inventory to console
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local success, LocalUser = pcall(function()
            local RuntimeLib = ReplicatedStorage:WaitForChild("rbxts_include"):WaitForChild("RuntimeLib")
            local module = require(RuntimeLib)
            return module.import(script, ReplicatedStorage, "TS", "user", "local", "local-user").LocalUser
        end)
        
        if not success then
            print("Error accessing user data: " .. tostring(LocalUser))
            return
        end
        
        -- Function to safely print values
        local function safePrint(name, value)
            if value == nil then
                print(name .. ": nil")
                return
            end
            print(name .. ": " .. tostring(value))
        end
        
        -- Function to list all cards in user's inventory
        local success, cards = pcall(function()
            return LocalUser.deck:getCards()
        end)
        
        if not success then
            print("Error accessing deck: " .. tostring(cards))
            return
        end
        
        local count = 0
        print("\n====== CARD INVENTORY ======")
        
        for cardId, userCard in pairs(cards) do
            count = count + 1
            local card = userCard:getCard()
            
            print("\n--- CARD " .. count .. " ---")
            safePrint("ID", card.id)
            safePrint("Amount", userCard:getAmount())
            safePrint("Is Support", card.isSupport)
            safePrint("Denominator", card.denominator)
        end
        
        print("\n" .. count .. " cards found")
        print("====== END OF INVENTORY ======")
    end
})

Tabs.DashboardTab:Button({
    Title = "Refresh UI",
    Callback = function()
        WindUI:Notify({
            Title = "Refreshing UI",
            Content = "Please wait...",
            Duration = 2,
            Icon = "refresh-cw"
        })
        
        task.delay(1, function()
            -- Aktualisieren der UI-Elemente hier
            WindUI:Notify({
                Title = "UI Refreshed",
                Content = "All UI elements have been updated",
                Duration = 2,
                Icon = "check-circle"
            })
        end)
    end
})

-- Teleport to areas
Tabs.DashboardTab:Section({ Title = "Quick Teleports" })

local teleportLocations = {
    ["Ninja Village"] = Vector3.new(-1152, 296, -3744),
    ["Green Village"] = Vector3.new(-2532, 254, -8184),
    ["Shibuya Station"] = Vector3.new(-4992, 299, -2784),
    ["Titans City"] = Vector3.new(-3840, 255, -3744),
    ["Dimensional Fortress"] = Vector3.new(-6768, 256, -4080),
    ["Candy Island"] = Vector3.new(-8016, 255, -4080),
    ["Solo City"] = Vector3.new(-9312, 255, -4080)
}

for locationName, position in pairs(teleportLocations) do
    Tabs.DashboardTab:Button({
        Title = "Teleport to " .. locationName,
        Callback = function()
            local player = game.Players.LocalPlayer
            local character = player.Character
            
            if character and character:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.CFrame = CFrame.new(position)
                
                WindUI:Notify({
                    Title = "Teleport",
                    Content = "Teleported to " .. locationName,
                    Duration = 2,
                    Icon = "map-pin"
                })
            else
                WindUI:Notify({
                    Title = "Teleport Failed",
                    Content = "Character not found",
                    Duration = 2,
                    Icon = "alert-triangle",
                    Color = "Red"
                })
            end
        end
    })
end

-- Spielerdaten-Info
Tabs.DashboardTab:Section({ Title = "Development" })

Tabs.DashboardTab:Button({
    Title = "MythHub Info",
    Callback = function()
        WindUI:Notify({
            Title = "MythHub Info",
            Content = "Version: 1.2.1\nLast Updated: " .. os.date("%d.%m.%Y"),
            Duration = 5,
            Icon = "info"
        })
    end
})

-- Funktion zum Speichern der Konfiguration
function ConfigManager:SaveConfig()
	-- Aktuelle Einstellungen in die Konfiguration übertragen
	-- Auto Farm
	Config.autoFarmSettings.selectedLocation = selectedLocation
	Config.autoFarmSettings.selectedEnemy = selectedEnemy
	Config.autoFarmSettings.autoPickupEnabled = _G.AutoPickup or false
	
	-- Custom Farm
	Config.customFarmSettings.selectedLocations = selectedLocations or {}
	Config.customFarmSettings.includeNormal = includeNormal
	Config.customFarmSettings.includeBosses = includeBosses
	
	-- Raid Settings
	Config.raidSettings.autoDetectDragon = _G.AutoDetectDragon or false
	
	-- Misc Settings
	Config.miscSettings.fpsBoostEnabled = (_G.OriginalLightingSettings ~= nil)
	Config.miscSettings.disableParticles = _G.DisableParticles or false
	Config.miscSettings.webhookURL = _G.WebhookURL or ""
	Config.miscSettings.webhookInterval = _G.WebhookInterval or 15
	Config.miscSettings.webhookEnabled = _G.WebhookEnabled or false
	Config.miscSettings.antiAFKEnabled = _G.AntiAFK or false
	
	-- Speichern der Konfiguration mit WindUI
	WindowUtil = require(game.ReplicatedStorage:WaitForChild("SharedModules"):WaitForChild("WindowUtil"))
	WindowUtil:SetSetting("MythHubConfig", Config)
	
	WindUI:Notify({
		Title = "Configuration",
		Content = "Settings saved!",
		Duration = 3,
		Icon = "save"
	})
end

-- Funktion zum Laden der Konfiguration
function ConfigManager:LoadConfig()
	-- Laden der Konfiguration mit WindUI
	WindowUtil = require(game.ReplicatedStorage:WaitForChild("SharedModules"):WaitForChild("WindowUtil"))
	local savedConfig = WindowUtil:GetSetting("MythHubConfig")
	
	if savedConfig then
		-- Konfiguration auf gespeicherte Werte setzen
		Config = savedConfig
		
		-- Auto Farm Einstellungen anwenden
		selectedLocation = Config.autoFarmSettings.selectedLocation
		selectedEnemy = Config.autoFarmSettings.selectedEnemy
		_G.AutoPickup = Config.autoFarmSettings.autoPickupEnabled
		
		-- Custom Farm Einstellungen anwenden
		selectedLocations = Config.customFarmSettings.selectedLocations or {}
		includeNormal = Config.customFarmSettings.includeNormal
		includeBosses = Config.customFarmSettings.includeBosses
		
		-- Raid Einstellungen anwenden
		_G.AutoDetectDragon = Config.raidSettings.autoDetectDragon
		
		-- Misc Einstellungen anwenden
		_G.DisableParticles = Config.miscSettings.disableParticles
		_G.WebhookURL = Config.miscSettings.webhookURL
		_G.WebhookInterval = Config.miscSettings.webhookInterval
		_G.WebhookEnabled = Config.miscSettings.webhookEnabled
		
		-- Anti-AFK-Status laden und anwenden
		_G.AntiAFK = Config.miscSettings.antiAFKEnabled
		if _G.AntiAFK then
			-- Starte Anti-AFK
			_G.AntiAFKConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
				-- Simuliere Bewegung, um AFK-Kick zu verhindern
				local VirtualUser = game:GetService("VirtualUser")
				VirtualUser:CaptureController()
				VirtualUser:ClickButton2(Vector2.new())
				
				-- Benachrichtigung
				WindUI:Notify({
					Title = "Anti-AFK",
					Content = "AFK detection prevented",
					Duration = 2,
					Icon = "shield"
				})
			end)
			
			-- Benachrichtigung beim Aktivieren
			WindUI:Notify({
				Title = "Anti-AFK",
				Content = "Anti-AFK protection enabled",
				Duration = 3,
				Icon = "user-check"
			})
		end
		
		-- FPS Boost wenn aktiviert
		if Config.miscSettings.fpsBoostEnabled then
			-- FPS Boost Funktionalität hier aktivieren
			local lighting = game:GetService("Lighting")
			
			-- Store original values to restore later
			_G.OriginalLightingSettings = {
				Brightness = lighting.Brightness,
				GlobalShadows = lighting.GlobalShadows,
				Technology = lighting.Technology,
				Ambient = lighting.Ambient,
				OutdoorAmbient = lighting.OutdoorAmbient
			}
			
			-- Apply performance settings
			lighting.GlobalShadows = false
			lighting.Technology = Enum.Technology.Compatibility
			lighting.Brightness = 0.1
			
			-- Reduce graphics quality
			settings().Rendering.QualityLevel = 1
			
			-- Remove terrain details
			workspace.Terrain.WaterWaveSize = 0
			workspace.Terrain.WaterWaveSpeed = 0
			workspace.Terrain.WaterReflectance = 0
			workspace.Terrain.WaterTransparency = 0
		end
		
		-- Benachrichtigung
		WindUI:Notify({
			Title = "Configuration",
			Content = "Settings loaded!",
			Duration = 3,
			Icon = "download"
		})
		
		return true
	else
		-- Keine gespeicherte Konfiguration gefunden
		WindUI:Notify({
			Title = "Configuration",
			Content = "No saved settings found!",
			Duration = 3,
			Icon = "alert-triangle",
			Color = "Orange"
		})
		
		return false
	end
end


Myth3DUI.CreateUI = function()
    -- Haupt-ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MythHub3DKeySystem"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = game:GetService("CoreGui")
    
    -- Hintergrund mit Blur-Effekt
    local backgroundFrame = Instance.new("Frame")
    backgroundFrame.Name = "Background"
    backgroundFrame.Size = UDim2.new(1, 0, 1, 0)
    backgroundFrame.BackgroundColor3 = Myth3DUI.Config.BACKGROUND_COLOR
    backgroundFrame.BackgroundTransparency = 0.3
    backgroundFrame.BorderSizePixel = 0
    backgroundFrame.Parent = screenGui
    
    -- Blur-Effekt
    local blurEffect = Instance.new("BlurEffect")
    blurEffect.Size = Myth3DUI.Config.BLUR_INTENSITY
    blurEffect.Parent = game:GetService("Lighting")
    
    -- Bloom für den Glow-Effekt
    local bloomEffect = Instance.new("BloomEffect")
    bloomEffect.Intensity = Myth3DUI.Config.BLOOM_INTENSITY
    bloomEffect.Size = Myth3DUI.Config.BLOOM_SIZE
    bloomEffect.Threshold = 0.8
    bloomEffect.Parent = game:GetService("Lighting")
    
    -- Hauptcontainer für die 3D-Szene
    local mainContainer = Instance.new("Frame")
    mainContainer.Name = "MainContainer"
    mainContainer.Size = UDim2.new(1, 0, 1, 0)
    mainContainer.BackgroundTransparency = 1
    mainContainer.Parent = screenGui
    
    -- Logo-Container
    local logoContainer = Instance.new("Frame")
    logoContainer.Name = "LogoContainer"
    logoContainer.Size = UDim2.new(0, 500, 0, 300)
    logoContainer.Position = UDim2.new(0.5, 0, 0.3, 0)
    logoContainer.AnchorPoint = Vector2.new(0.5, 0.5)
    logoContainer.BackgroundTransparency = 1
    logoContainer.Parent = mainContainer
    
    -- Container für die Key-Eingabe
    local keyPanel = Instance.new("Frame")
    keyPanel.Name = "KeyPanel"
    keyPanel.Size = UDim2.new(0, 400, 0, 280)
    keyPanel.Position = UDim2.new(0.5, 0, 0.65, 0)
    keyPanel.AnchorPoint = Vector2.new(0.5, 0.5)
    keyPanel.BackgroundColor3 = Myth3DUI.Config.ACCENT_COLOR
    keyPanel.BackgroundTransparency = Myth3DUI.Config.KEY_PANEL_TRANSPARENCY
    keyPanel.BorderSizePixel = 0
    keyPanel.Parent = mainContainer
    
    -- UI-Ecken abrunden
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 15)
    uiCorner.Parent = keyPanel
    
    -- Schatten für das Panel
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Size = UDim2.new(1, 30, 1, 30)
    shadow.Position = UDim2.new(0, -15, 0, -15)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    shadow.ImageTransparency = Myth3DUI.Config.SHADOW_TRANSPARENCY
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(23, 23, 277, 277)
    shadow.ZIndex = keyPanel.ZIndex - 1
    shadow.Parent = keyPanel
    
    -- Überschrift
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Size = UDim2.new(1, 0, 0, 50)
    titleLabel.Position = UDim2.new(0, 0, 0, 10)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "MYTHHUB KEY SYSTEM"
    titleLabel.Font = Myth3DUI.Config.FONT
    titleLabel.TextSize = 28
    titleLabel.TextColor3 = Myth3DUI.Config.TEXT_COLOR
    titleLabel.Parent = keyPanel
    
    -- Key-Eingabefeld mit Glaseffekt
    local keyInput = Instance.new("TextBox")
    keyInput.Name = "KeyInput"
    keyInput.Size = UDim2.new(0.9, 0, 0, 50)
    keyInput.Position = UDim2.new(0.5, 0, 0.4, 0)
    keyInput.AnchorPoint = Vector2.new(0.5, 0.5)
    keyInput.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    keyInput.BackgroundTransparency = 0.8
    keyInput.BorderSizePixel = 0
    keyInput.PlaceholderText = "Gib deinen Key ein..."
    keyInput.PlaceholderColor3 = Color3.fromRGB(200, 200, 255)
    keyInput.Text = ""
    keyInput.ClearTextOnFocus = false
    keyInput.Font = Enum.Font.Gotham
    keyInput.TextSize = 18
    keyInput.TextColor3 = Myth3DUI.Config.TEXT_COLOR
    keyInput.Parent = keyPanel
    
    -- Abgerundete Ecken für das Eingabefeld
    local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius = UDim.new(0, 8)
    inputCorner.Parent = keyInput
    
    -- Schlagschatten für das Eingabefeld
    local inputStroke = Instance.new("UIStroke")
    inputStroke.Color = Myth3DUI.Config.SECONDARY_COLOR
    inputStroke.Thickness = 1.5
    inputStroke.Transparency = 0.3
    inputStroke.Parent = keyInput
    
    -- Einloggen-Button mit Glaseffekt
    local loginButton = Instance.new("TextButton")
    loginButton.Name = "LoginButton"
    loginButton.Size = UDim2.new(0.6, 0, 0, 50)
    loginButton.Position = UDim2.new(0.5, 0, 0.65, 0)
    loginButton.AnchorPoint = Vector2.new(0.5, 0.5)
    loginButton.BackgroundColor3 = Myth3DUI.Config.SECONDARY_COLOR
    loginButton.BackgroundTransparency = 0.3
    loginButton.BorderSizePixel = 0
    loginButton.Text = "LOGIN"
    loginButton.Font = Myth3DUI.Config.FONT
    loginButton.TextSize = 20
    loginButton.TextColor3 = Myth3DUI.Config.TEXT_COLOR
    loginButton.AutoButtonColor = false
    loginButton.Parent = keyPanel
    
    -- Abgerundete Ecken für den Button
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 8)
    buttonCorner.Parent = loginButton
    
    -- Gradient für den Button
    local buttonGradient = Instance.new("UIGradient")
    buttonGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(60, 60, 255)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 100, 255))
    })
    buttonGradient.Rotation = 45
    buttonGradient.Parent = loginButton
    
    -- Leuchteffekt für den Button
    local buttonGlow = Instance.new("ImageLabel")
    buttonGlow.Name = "ButtonGlow"
    buttonGlow.Size = UDim2.new(1.2, 0, 1.5, 0)
    buttonGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
    buttonGlow.AnchorPoint = Vector2.new(0.5, 0.5)
    buttonGlow.BackgroundTransparency = 1
    buttonGlow.Image = "rbxassetid://4996891970"
    buttonGlow.ImageColor3 = Color3.fromRGB(60, 100, 255)
    buttonGlow.ImageTransparency = 0.9
    buttonGlow.ZIndex = loginButton.ZIndex - 1
    buttonGlow.Parent = loginButton
    
    -- Button-Rahmen mit Leuchteffekt
    local buttonStroke = Instance.new("UIStroke")
    buttonStroke.Color = Color3.fromRGB(100, 150, 255)
    buttonStroke.Thickness = 1.5
    buttonStroke.Transparency = 0.7
    buttonStroke.Parent = loginButton
    
    loginButton.Parent = keyPanel
    
    -- Get Key Button mit Glaseffekt
    local getKeyButton = Instance.new("TextButton")
    getKeyButton.Name = "GetKeyButton"
    getKeyButton.Size = UDim2.new(0.6, 0, 0, 40)
    getKeyButton.Position = UDim2.new(0.5, 0, 0.85, 0)
    getKeyButton.AnchorPoint = Vector2.new(0.5, 0.5)
    getKeyButton.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
    getKeyButton.BackgroundTransparency = 0.3
    getKeyButton.BorderSizePixel = 0
    getKeyButton.Text = "GET KEY"
    getKeyButton.Font = Enum.Font.Gotham
    getKeyButton.TextSize = 16
    getKeyButton.TextColor3 = Myth3DUI.Config.TEXT_COLOR
    getKeyButton.AutoButtonColor = false
    getKeyButton.Parent = keyPanel
    
    -- Abgerundete Ecken für den Get Key Button
    local getKeyCorner = Instance.new("UICorner")
    getKeyCorner.CornerRadius = UDim.new(0, 8)
    getKeyCorner.Parent = getKeyButton
    
    -- Status-Label
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Name = "StatusLabel"
    statusLabel.Size = UDim2.new(0.9, 0, 0, 30)
    statusLabel.Position = UDim2.new(0.5, 0, 0.95, 0)
    statusLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 14
    statusLabel.TextColor3 = Myth3DUI.Config.TEXT_COLOR
    statusLabel.Text = ""
    statusLabel.Parent = keyPanel
    
    -- Erstelle 3D-Logobereich
    local logo3D = Myth3DUI.Engine.Object3D.new(logoContainer)
    local logoObject = logo3D:CreateLogo()
    local particles = logo3D:CreateParticles()
    
    -- Button-Hover-Effekte
    local function setupButtonEffects(button)
        button.MouseEnter:Connect(function()
            game:GetService("TweenService"):Create(button, TweenInfo.new(0.3), {
                BackgroundTransparency = 0.1,
                Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset + 10, button.Size.Y.Scale, button.Size.Y.Offset + 5)
            }):Play()
        end)
        
        button.MouseLeave:Connect(function()
            game:GetService("TweenService"):Create(button, TweenInfo.new(0.3), {
                BackgroundTransparency = 0.3,
                Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset - 10, button.Size.Y.Scale, button.Size.Y.Offset - 5)
            }):Play()
        end)
        
        button.MouseButton1Down:Connect(function()
            game:GetService("TweenService"):Create(button, TweenInfo.new(0.1), {
                BackgroundTransparency = 0.5,
                Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset - 5, button.Size.Y.Scale, button.Size.Y.Offset - 2)
            }):Play()
        end)
        
        button.MouseButton1Up:Connect(function()
            game:GetService("TweenService"):Create(button, TweenInfo.new(0.1), {
                BackgroundTransparency = 0.1,
                Size = UDim2.new(button.Size.X.Scale, button.Size.X.Offset + 5, button.Size.Y.Scale, button.Size.Y.Offset + 2)
            }):Play()
        end)
    end
    
    setupButtonEffects(loginButton)
    setupButtonEffects(getKeyButton)
    
    -- Panel-Animation bei Start
    keyPanel.Position = UDim2.new(0.5, 0, 1.2, 0)
    game:GetService("TweenService"):Create(keyPanel, TweenInfo.new(0.8, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Position = UDim2.new(0.5, 0, 0.65, 0)
    }):Play()
    
    -- Titel-Animation
    titleLabel.TextTransparency = 1
    titleLabel.Position = UDim2.new(0, 0, 0, -30)
    game:GetService("TweenService"):Create(titleLabel, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.3), {
        TextTransparency = 0,
        Position = UDim2.new(0, 0, 0, 10)
    }):Play()
    
    -- Status-Animation
    local function animateStatus(text, color)
        statusLabel.Text = text
        statusLabel.TextColor3 = color
        statusLabel.TextTransparency = 1
        statusLabel.TextStrokeTransparency = 1
        
        game:GetService("TweenService"):Create(statusLabel, TweenInfo.new(0.3), {
            TextTransparency = 0,
            TextStrokeTransparency = 0.7
        }):Play()
    end
    
    -- Event-Handler für den Einloggen-Button
    local keyLink = ""
    
    -- Versuche den Link mit beiden API-Versionen zu bekommen
    if KeyGuardianV2 then
        pcall(function()
            keyLink = KeyGuardianV2:GetKeylink()
        end)
    end
    
    -- Fallback auf ältere API, wenn noch kein Link vorhanden
    if keyLink == "" then
        pcall(function()
            keyLink = KeyGuardLibrary.getLink()
        end)
    end
    
    loginButton.MouseButton1Click:Connect(function()
        local inputKey = keyInput.Text
        if inputKey and inputKey ~= "" then
            animateStatus("Validating key...", Color3.fromRGB(255, 255, 0))
            
            -- EPIC button press animation
            -- Visual shockwave effect
            local shockwave = Instance.new("ImageLabel")
            shockwave.Name = "Shockwave"
            shockwave.Size = UDim2.new(0, 0, 0, 0)
            shockwave.Position = UDim2.new(0.5, 0, 0.5, 0)
            shockwave.AnchorPoint = Vector2.new(0.5, 0.5)
            shockwave.BackgroundTransparency = 1
            shockwave.Image = "rbxassetid://266543268" -- Ripple/shockwave effect
            shockwave.ImageColor3 = Color3.fromRGB(100, 150, 255)
            shockwave.ImageTransparency = 0.7
            shockwave.Parent = loginButton
            
            -- Animate shockwave
            tweenProperty(shockwave, "Size", UDim2.new(4, 0, 4, 0), 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            tweenProperty(shockwave, "ImageTransparency", 1, 0.5)
            
            task.delay(0.5, function()
                if shockwave and shockwave.Parent then
                    shockwave:Destroy()
                end
            end)
            
            -- Create 3D animation of key entering a lock
            local keyModel = Instance.new("Part")
            keyModel.Name = "KeyModel"
            keyModel.Size = Vector3.new(2, 1, 0.5)
            keyModel.Position = Vector3.new(-5, 0, 15)
            keyModel.Anchored = true
            keyModel.CanCollide = false
            keyModel.Material = Enum.Material.Metal
            keyModel.Color = Color3.fromRGB(220, 220, 255)
            keyModel.Parent = worldModel
            
            -- Key teeth
            for i = 1, 3 do
                local tooth = Instance.new("Part")
                tooth.Size = Vector3.new(0.3, 0.5, 0.5)
                tooth.Position = Vector3.new(-5 + (i * 0.5) - 1.5, -0.5, 15)
                tooth.Anchored = true
                tooth.CanCollide = false
                tooth.Material = Enum.Material.Metal
                tooth.Color = Color3.fromRGB(220, 220, 255)
                tooth.Parent = worldModel
                
                -- Attach tooth to key for animation
                tooth.Name = "KeyTooth" .. i
            end
            
            -- Lock model
            local lockModel = Instance.new("Part") 
            lockModel.Name = "LockModel"
            lockModel.Size = Vector3.new(3, 2, 1)
            lockModel.Position = Vector3.new(5, 0, 15)
            lockModel.Anchored = true
            lockModel.CanCollide = false
            lockModel.Material = Enum.Material.Metal
            lockModel.Color = Color3.fromRGB(150, 150, 180)
            lockModel.Parent = worldModel
            
            -- Keyhole
            local keyhole = Instance.new("Part")
            keyhole.Name = "Keyhole"
            keyhole.Size = Vector3.new(0.5, 0.8, 1.1)
            keyhole.Position = Vector3.new(3.5, 0, 15)
            keyhole.Anchored = true
            keyhole.CanCollide = false
            keyhole.Material = Enum.Material.SmoothPlastic
            keyhole.Color = Color3.fromRGB(30, 30, 50)
            keyhole.Parent = worldModel
            
            -- Animate key into lock
            task.spawn(function()
                -- Move key towards lock
                for i = 1, 20 do
                    local t = i/20
                    local xPos = Lerp(-5, 3, t)
                    
                    keyModel.Position = Vector3.new(xPos, 0, 15)
                    
                    -- Update teeth positions
                    for j = 1, 3 do
                        local tooth = worldModel:FindFirstChild("KeyTooth" .. j)
                        if tooth then
                            tooth.Position = Vector3.new(xPos + (j * 0.5) - 1.5, -0.5, 15)
                        end
                    end
                    
                    task.wait(0.02)
                end
                
                -- Rotate key in lock
                local originalRot = keyModel.CFrame
                for i = 1, 10 do
                    local angle = i/10 * math.pi/2
                    keyModel.CFrame = CFrame.new(3, 0, 15) * CFrame.Angles(0, 0, angle)
                    
                    -- Update teeth positions with rotation
                    for j = 1, 3 do
                        local tooth = worldModel:FindFirstChild("KeyTooth" .. j)
                        if tooth then
                            local offset = Vector3.new((j * 0.5) - 1.5, -0.5, 0)
                            local rotOffset = CFrame.new(3, 0, 15) * CFrame.Angles(0, 0, angle) * CFrame.new(offset)
                            tooth.Position = rotOffset.Position
                            tooth.Rotation = keyModel.Rotation
                        end
                    end
                    
                    task.wait(0.03)
                end
            end)
            
            -- Login-Animation
            animateStatus("Validating key...", Color3.fromRGB(255, 255, 100))
            
            -- Button-Druck-Animation
            tweenProperty(loginButton, "Size", UDim2.new(0.68, 0, 0, 43), 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
            tweenProperty(loginButton, "BackgroundColor3", Color3.fromRGB(40, 80, 220), 0.2)
            task.wait(0.2)
            tweenProperty(loginButton, "Size", UDim2.new(0.7, 0, 0, 45), 0.2, Enum.EasingStyle.Back)
            tweenProperty(loginButton, "BackgroundColor3", Color3.fromRGB(60, 100, 255), 0.2)
            
            -- Key validieren
            local isValid = validateKey(inputKey)
            
            task.wait(0.8) -- Zeit für die Animation
            
            if isValid then
                -- Key successful animation
                -- Emit glow from lock
                local lockGlow = Instance.new("PointLight")
                lockGlow.Name = "LockGlow"
                lockGlow.Color = Color3.fromRGB(100, 255, 150)
                lockGlow.Range = 15
                lockGlow.Brightness = 1
                lockGlow.Parent = lockModel
                
                -- Animate light brightness with pulsierendem Effekt
                task.spawn(function()
                    for i = 1, 3 do
                        tweenProperty(lockGlow, "Brightness", 5, 0.2)
                        tweenProperty(lockGlow, "Range", 20, 0.2)
                        task.wait(0.2)
                        tweenProperty(lockGlow, "Brightness", 1, 0.2)
                        tweenProperty(lockGlow, "Range", 15, 0.2)
                        task.wait(0.2)
                    end
                    tweenProperty(lockGlow, "Brightness", 0, 0.5)
                end)
                
                -- Success particles from lock with dynamischen Farben
                local particleColors = {
                    Color3.fromRGB(100, 255, 150),  -- Grün
                    Color3.fromRGB(150, 255, 100),  -- Hellgrün
                    Color3.fromRGB(100, 200, 255),  -- Blau
                    Color3.fromRGB(200, 255, 100),  -- Gelbgrün
                    Color3.fromRGB(150, 200, 255)   -- Hellblau
                }
                
                for i = 1, 60 do
                    local successParticle = Instance.new("Part")
                    successParticle.Shape = Enum.PartType.Ball
                    successParticle.Size = Vector3.new(0.2, 0.2, 0.2)
                    successParticle.Position = Vector3.new(5, 0, 15)
                    successParticle.Anchored = true
                    successParticle.CanCollide = false
                    successParticle.Material = Enum.Material.Neon
                    successParticle.Color = particleColors[math.random(1, #particleColors)]
                    successParticle.Transparency = 0
                    successParticle.Parent = worldModel
                    
                    -- Verbesserte Partikelanimation mit verschiedenen Bewegungsmustern
                    task.spawn(function()
                        local speed = math.random(5, 20) / 10
                        local pattern = math.random(1, 3)
                        local direction
                        
                        if pattern == 1 then
                            -- Standard-Explosion
                            direction = Vector3.new(
                                math.random(-100, 100) / 100,
                                math.random(-100, 100) / 100,
                                math.random(-100, 100) / 100
                            ).Unit
                        elseif pattern == 2 then
                            -- Spiralmuster
                            local angle = math.rad(math.random(0, 360))
                            direction = Vector3.new(
                                math.cos(angle),
                                math.sin(angle),
                                math.random(-50, 50) / 100
                            ).Unit
                        else
                            -- Fontänenmuster
                            direction = Vector3.new(
                                math.random(-70, 70) / 100,
                                math.random(50, 100) / 100,
                                math.random(-70, 70) / 100
                            ).Unit
                        end
                        
                        local lifetime = math.random(20, 40)
                        
                        for j = 1, lifetime do
                            if pattern == 2 then
                                -- Für Spiralmuster: Richtung ändern
                                local t = j / lifetime
                                local angle = math.rad(j * 12) -- Winkel ändert sich mit der Zeit
                                direction = Vector3.new(
                                    math.cos(angle) * (1 - t * 0.5),
                                    math.sin(angle) * (1 - t * 0.5),
                                    direction.Z
                                ).Unit
                            end
                            
                            successParticle.Position = successParticle.Position + direction * speed
                            
                            -- Bei manchen Partikeln Größe ändern
                            if j % 5 == 0 and math.random(1, 3) == 1 then
                                local pulseSize = math.random(80, 120) / 100
                                successParticle.Size = Vector3.new(0.2, 0.2, 0.2) * pulseSize
                            end
                            
                            -- Transparenz über die Zeit erhöhen
                            successParticle.Transparency = j / lifetime
                            
                            task.wait()
                        end
                        
                        successParticle:Destroy()
                    end)
                    
                    -- Zeitversetzung für einen kontinuierlichen Strom von Partikeln
                    if i % 10 == 0 then
                        task.wait(0.02)
                    end
                end

                -- Erfolgsanimation mit pulsierendem Text
                loginButton.Text = "VERIFIED!"
                tweenProperty(loginButton, "BackgroundColor3", Color3.fromRGB(70, 200, 120), 0.3)
                
                -- Pulsierender Erfolgstext
                task.spawn(function()
                    for i = 1, 3 do
                        tweenProperty(loginButton, "TextSize", 20, 0.2)
                        task.wait(0.2)
                        tweenProperty(loginButton, "TextSize", 18, 0.2)
                        task.wait(0.2)
                    end
                end)
                
                -- Animierter Status mit Schreibeffekt
                animateStatus("Key accepted! Loading MythHub...", Color3.fromRGB(100, 255, 150))
                
                -- Speichere den validierten Key
                getgenv().MythHubKey = inputKey
                key = inputKey
                keyVerified = true
                
                -- Ausblenden mit Animation
                task.wait(1)
                
                -- Celebrate with fireworks before closing
                for i = 1, 5 do
                    task.spawn(function()
                        local basePosition = Vector3.new(
                            math.random(-15, 15),
                            math.random(5, 15),
                            20
                        )
                        
                        -- Firework trail
                        for j = 1, 20 do
                            local trail = Instance.new("Part")
                            trail.Shape = Enum.PartType.Ball
                            trail.Size = Vector3.new(0.2, 0.2, 0.2)
                            trail.Position = basePosition - Vector3.new(0, j/5, 0)
                            trail.Anchored = true
                            trail.CanCollide = false
                            trail.Material = Enum.Material.Neon
                            trail.Color = Color3.fromRGB(255, 200, 100)
                            trail.Transparency = j/20
                            trail.Parent = worldModel
                            
                            task.delay(0.5, function()
                                trail:Destroy()
                            end)
                        end
                        
                        task.wait(0.5)
                        
                        -- Explosion
                        local colors = {
                            Color3.fromRGB(255, 50, 50),
                            Color3.fromRGB(50, 255, 50),
                            Color3.fromRGB(50, 50, 255),
                            Color3.fromRGB(255, 255, 50),
                            Color3.fromRGB(255, 50, 255),
                            Color3.fromRGB(50, 255, 255)
                        }
                        
                        local color = colors[math.random(1, #colors)]
                        
                        -- Explosion light
                        local explosionLight = Instance.new("PointLight")
                        explosionLight.Color = color
                        explosionLight.Range = 20
                        explosionLight.Brightness = 5
                        explosionLight.Position = basePosition
                        explosionLight.Parent = worldModel
                        
                        for j = 1, 30 do
                            local spark = Instance.new("Part")
                            spark.Shape = Enum.PartType.Ball
                            spark.Size = Vector3.new(0.3, 0.3, 0.3)
                            spark.Position = basePosition
                            spark.Anchored = true
                            spark.CanCollide = false
                            spark.Material = Enum.Material.Neon
                            spark.Color = color
                            spark.Transparency = 0
                            spark.Parent = worldModel
                            
                            task.spawn(function()
                                local dir = Vector3.new(
                                    math.random(-100, 100),
                                    math.random(-100, 100),
                                    math.random(-50, 50)
                                ).Unit
                                
                                local speed = math.random(10, 30) / 10
                                
                                for k = 1, 20 do
                                    spark.Position = spark.Position + dir * speed
                                    spark.Transparency = k/20
                                    task.wait()
                                end
                                
                                spark:Destroy()
                            end)
                        end
                        
                        task.delay(1, function()
                            tweenProperty(explosionLight, "Brightness", 0, 0.5)
                            task.delay(0.5, function()
                                explosionLight:Destroy()
                            end)
                        end)
                    end)
                    
                    task.wait(math.random(20, 40) / 100)
                end
                
                tweenProperty(mainContainer, "Position", UDim2.new(0.5, 0, 1.5, 0), 1, Enum.EasingStyle.Back, Enum.EasingDirection.In)
                tweenProperty(blurEffect, "Size", 0, 1)
                tweenProperty(bloomEffect, "Intensity", 0, 1)
                tweenProperty(backgroundFrame, "BackgroundTransparency", 1, 1)
                
                task.wait(1.2)
                
                -- Clean up 3D models
                if keyModel and keyModel.Parent then keyModel:Destroy() end
                if lockModel and lockModel.Parent then lockModel:Destroy() end
                for i = 1, 3 do
                    local tooth = worldModel:FindFirstChild("KeyTooth" .. i)
                    if tooth then tooth:Destroy() end
                end
                if keyhole and keyhole.Parent then keyhole:Destroy() end
                
                -- UI entfernen
                if blurEffect and blurEffect.Parent then blurEffect:Destroy() end
                if bloomEffect and bloomEffect.Parent then bloomEffect:Destroy() end
                if screenGui and screenGui.Parent then screenGui:Destroy() end
            else
                -- Failed key animation
                -- Error effect in the 3D world
                local errorShake = Instance.new("Part")
                errorShake.Name = "ErrorShake"
                errorShake.Size = Vector3.new(15, 15, 1)
                errorShake.Position = Vector3.new(0, 0, 14)
                errorShake.Anchored = true
                errorShake.CanCollide = false
                errorShake.Material = Enum.Material.Neon
                errorShake.Color = Color3.fromRGB(255, 50, 50)
                errorShake.Transparency = 0.8
                errorShake.Parent = worldModel
                
                -- Red warning flash
                local redLight = Instance.new("PointLight")
                redLight.Color = Color3.fromRGB(255, 0, 0)
                redLight.Range = 20
                redLight.Brightness = 5
                redLight.Parent = errorShake
                
                -- Shake animation
                for i = 1, 5 do
                    errorShake.Position = Vector3.new(math.random(-10, 10)/10, math.random(-10, 10)/10, 14)
                    errorShake.Rotation = Vector3.new(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5))
                    task.wait(0.05)
                end
                
                -- Fade out
                for i = 1, 10 do
                    errorShake.Transparency = 0.8 + (i/50)
                    redLight.Brightness = 5 - (i/2)
                    task.wait(0.05)
                end
                
                errorShake:Destroy()
                
                -- Break the key
                task.spawn(function()
                    -- Split the key into pieces
                    for i = 1, 5 do
                        local keyPiece = Instance.new("Part")
                        keyPiece.Size = Vector3.new(math.random(3, 8)/10, math.random(3, 8)/10, math.random(3, 8)/10)
                        keyPiece.Position = keyModel.Position
                        keyPiece.Anchored = true
                        keyPiece.CanCollide = false
                        keyPiece.Material = Enum.Material.Metal
                        keyPiece.Color = Color3.fromRGB(220, 220, 255)
                        keyPiece.Parent = worldModel
                        
                        -- Animation
                        task.spawn(function()
                            local dir = Vector3.new(
                                math.random(-100, 100)/100,
                                math.random(-100, 100)/100,
                                math.random(-20, 20)/100
                            ).Unit
                            
                            local rotSpeed = Vector3.new(
                                math.random(-30, 30),
                                math.random(-30, 30),
                                math.random(-30, 30)
                            )
                            
                            for j = 1, 30 do
                                keyPiece.Position = keyPiece.Position + dir * 0.2
                                keyPiece.Orientation = keyPiece.Orientation + rotSpeed * 0.1
                                keyPiece.Transparency = j/30
                                task.wait()
                            end
                            
                            keyPiece:Destroy()
                        end)
                    end
                    
                    -- Hide original key
                    keyModel.Transparency = 1
                    for j = 1, 3 do
                        local tooth = worldModel:FindFirstChild("KeyTooth" .. j)
                        if tooth then tooth.Transparency = 1 end
                    end
                end)

                -- Fehler-Animation
                animateStatus("Invalid key!", Color3.fromRGB(255, 100, 100))
                
                -- Shake-Animation für den Button
                local originalPos = loginButton.Position
                for i = 1, 4 do
                    tweenProperty(loginButton, "Position", UDim2.new(originalPos.X.Scale, originalPos.X.Offset + (i % 2 == 0 and 10 or -10), originalPos.Y.Scale, originalPos.Y.Offset), 0.08)
                    task.wait(0.08)
                end
                tweenProperty(loginButton, "Position", originalPos, 0.1)
                
                -- Input leeren
                task.wait(0.3)
                keyInput.Text = ""
            end
        else
            animateStatus("Please enter your key", Color3.fromRGB(255, 150, 50))
            
            -- Error-Animation für leeren Input
            game:GetService("TweenService"):Create(keyInput, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, 2, true), {
                Size = UDim2.new(0.91, 0, 0, 50)
            }):Play()
        end
    end)
    
    getKeyButton.MouseButton1Click:Connect(function()
        animateStatus("Link copied to clipboard!", Color3.fromRGB(0, 200, 255))
        setclipboard(keyLink)
        
        -- Kopier-Animation
        game:GetService("TweenService"):Create(getKeyButton, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(0, 150, 200)
        }):Play()
        
        wait(0.4)
        
        game:GetService("TweenService"):Create(getKeyButton, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(60, 60, 80)
        }):Play()
    end)
    
    -- Schließen-Button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 40, 0, 40)
    closeButton.Position = UDim2.new(1, -20, 0, 20)
    closeButton.AnchorPoint = Vector2.new(1, 0)
    closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    closeButton.BackgroundTransparency = 0.3
    closeButton.BorderSizePixel = 0
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.Font = Enum.Font.GothamBold
    closeButton.TextSize = 20
    closeButton.Parent = screenGui
    
    -- Runde Ecken für den Schließen-Button
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(1, 0) -- Kreisform
    closeCorner.Parent = closeButton
    
    closeButton.MouseButton1Click:Connect(function()
        -- Sofort Zustand als "wird geschlossen" markieren
        local isClosing = true
        
        -- Direkte visuelles Feedback für bessere User Experience
        closeButton.TextColor3 = Color3.fromRGB(255, 50, 50)
        closeButton.TextSize = 26
        
        -- Sichere Funktion für Destroy-Operationen
        local function safeDestroy(instance)
            if instance and typeof(instance) == "Instance" and instance.Parent then
                pcall(function() instance:Destroy() end)
            end
        end
        
        -- Sofort alle Partikel stoppen
        pcall(function()
            for _, particle in pairs(particles or {}) do
                safeDestroy(particle)
            end
            particles = {}
        end)
        
        -- Bereinige worldModel
        pcall(function() 
            if worldModel and worldModel.Parent then
                for _, child in pairs(worldModel:GetChildren()) do
                    safeDestroy(child)
                end
                
                if worldModel ~= (logo3D and logo3D.Scene) then
                    safeDestroy(worldModel)
                end
            end
        end)
        
        -- Click-Animationseffekt
        pcall(function()
            local clickRipple = Instance.new("Frame")
            clickRipple.Size = UDim2.new(0, 10, 0, 10)
            clickRipple.Position = UDim2.new(0.5, 0, 0.5, 0)
            clickRipple.AnchorPoint = Vector2.new(0.5, 0.5)
            clickRipple.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
            clickRipple.BackgroundTransparency = 0.2
            clickRipple.BorderSizePixel = 0
            clickRipple.ZIndex = 11
            
            local rippleCorner = Instance.new("UICorner")
            rippleCorner.CornerRadius = UDim.new(1, 0)
            rippleCorner.Parent = clickRipple
            
            clickRipple.Parent = closeButton
            
            -- Animiere den Ripple-Effekt
            pcall(function()
                tweenProperty(clickRipple, "Size", UDim2.new(0, 50, 0, 50), 0.3)
                tweenProperty(clickRipple, "BackgroundTransparency", 1, 0.3)
            end)
        end)
        
        -- Ausblendungsanimationen starten mit Fehlerbehandlung
        pcall(function()
            if blurEffect and blurEffect.Parent then
                tweenProperty(blurEffect, "Size", 0, 0.6)
            end
            
            if bloomEffect and bloomEffect.Parent then
                tweenProperty(bloomEffect, "Intensity", 0, 0.6)
            end
            
            if backgroundFrame and backgroundFrame.Parent then
                tweenProperty(backgroundFrame, "BackgroundTransparency", 1, 0.6)
            end
            
            if mainContainer and mainContainer.Parent then
                tweenProperty(mainContainer, "Position", UDim2.new(0.5, 0, 1.5, 0), 0.8, Enum.EasingStyle.Back, Enum.EasingDirection.In)
            end
        end)
        
        -- UI nach kurzer Verzögerung entfernen
        task.delay(0.6, function()
            if not isClosing then return end
            
            -- Zuerst das Logo3D entfernen, was alle 3D-Objekte entfernt
            if logo3D then pcall(function() logo3D:Destroy() end) end
            
            -- Dann die restlichen UI-Elemente
            safeDestroy(blurEffect)
            safeDestroy(bloomEffect)
            safeDestroy(screenGui)
            
            -- Sicherstellen, dass alle Lighting-Effekte entfernt werden
            for _, effect in pairs(game:GetService("Lighting"):GetChildren()) do
                if string.find(effect.Name, "MythHub") then
                    safeDestroy(effect)
                end
            end
            
            -- Bereinige alle Workspace-Objekte
            for _, obj in pairs(workspace:GetChildren()) do
                if string.match(obj.Name, "Hologram_") or obj.Name == "WorldModel" then
                    safeDestroy(obj)
                end
            end
        end)
        
        -- Failsafe - falls nach 1.5 Sekunden die UI noch existiert
        task.delay(1.5, function()
            safeDestroy(screenGui)
            
            -- Letzte Bereinigung
            for _, obj in pairs(workspace:GetChildren()) do
                if string.match(obj.Name, "Hologram_") or 
                   string.match(obj.Name, "WorldModel") or
                   string.match(obj.Name, "MythHub") then
                    safeDestroy(obj)
                end
            end
        end)
    end)
    
    -- Add resize functionality
    local resizeHandle = Instance.new("TextButton")
    resizeHandle.Name = "ResizeHandle"
    resizeHandle.Size = UDim2.new(0, 20, 0, 20)
    resizeHandle.Position = UDim2.new(1, -10, 1, -10)
    resizeHandle.AnchorPoint = Vector2.new(1, 1)
    resizeHandle.BackgroundTransparency = 1
    resizeHandle.Text = "⟨⟩"
    resizeHandle.TextColor3 = Color3.fromRGB(150, 150, 200)
    resizeHandle.TextSize = 14
    resizeHandle.Font = Enum.Font.GothamBold
    resizeHandle.Rotation = 45
    resizeHandle.Parent = keyPanel
    
    -- Resize functionality
    local resizing = false
    local resizeInput
    local resizeStart
    local startSize
    
    local function updateResize(input)
        local delta = input.Position - resizeStart
        local newSize = UDim2.new(startSize.X.Scale, math.clamp(startSize.X.Offset + delta.X, 300, 600), 
                                 startSize.Y.Scale, math.clamp(startSize.Y.Offset + delta.Y, 200, 400))
        keyPanel.Size = newSize
    end
    
    resizeHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            resizing = true
            resizeStart = input.Position
            startSize = keyPanel.Size
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    resizing = false
                end
            end)
        end
    end)
    
    resizeHandle.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            resizeInput = input
        end
    end)
    
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if input == resizeInput and resizing then
            updateResize(input)
        end
    end)

    -- Mobile-friendly UI adjustments
    local isMobile = game:GetService("UserInputService").TouchEnabled and 
                    not game:GetService("UserInputService").KeyboardEnabled
    
    if isMobile then
        -- Increase button and input sizes for touch
        loginButton.Size = UDim2.new(0.8, 0, 0, 60)
        inputContainer.Size = UDim2.new(0.9, 0, 0, 60)
        keyInput.TextSize = 18
        loginButton.TextSize = 20
    end
    
    -- Erstelle worldModel für 3D-Elemente, falls es nicht existiert
    local worldModel = logo3D and logo3D.Scene or Instance.new("Model")
    if not logo3D or not logo3D.Scene then
        worldModel.Name = "WorldModel"
        worldModel.Parent = workspace
    end
    
    -- Enhanced 3D particles
    local particles = {}
    for i = 1, 10 do
        pcall(function()
            local hologram = Instance.new("Part")
            hologram.Name = "Hologram_" .. i
            hologram.Shape = Enum.PartType.Ball
            hologram.Material = Enum.Material.Neon
            hologram.Size = Vector3.new(0.2, 0.2, 0.2)
            hologram.Position = Vector3.new(math.random(-5, 5), math.random(-5, 5), math.random(5, 15))
            hologram.Anchored = true
            hologram.CanCollide = false
            hologram.Transparency = 0.5
            hologram.Color = Color3.fromRGB(70, 120, 255)
            hologram.Parent = worldModel
            
            table.insert(particles, hologram)
            
            -- Orbit pattern around the logo
            task.spawn(function()
                local radius = math.random(3, 7)
                local speed = math.random(10, 20) / 100
                local height = math.random(-3, 3)
                local offset = math.random(0, 360)
                
                while task.wait() do
                    if not hologram or not hologram.Parent then break end
                    
                    local angle = (tick() * speed * 60 + offset) % 360
                    local rad = math.rad(angle)
                    
                    hologram.Position = Vector3.new(
                        math.sin(rad) * radius,
                        height + math.sin(tick() * 0.5) * 0.5,
                        math.cos(rad) * radius + 10
                    )
                end
            end)
        end)
    end
    
    return {
        ScreenGui = screenGui,
        KeyInput = keyInput,
        StatusLabel = statusLabel,
        Logo3D = logo3D,
        BlurEffect = blurEffect,
        BloomEffect = bloomEffect,
        WorldModel = worldModel,
        Particles = particles,
        
        Destroy = function()
            local function safeDestroy(instance)
                if instance and typeof(instance) == "Instance" and instance.Parent then
                    pcall(function() instance:Destroy() end)
                end
            end
            
            -- Zuerst alle Partikel entfernen
            for _, particle in pairs(particles or {}) do
                safeDestroy(particle)
            end
            
            -- Cleanup worldModel falls es existiert und nicht Teil von logo3D ist
            if worldModel and worldModel ~= (logo3D and logo3D.Scene) then
                pcall(function()
                    for _, child in pairs(worldModel:GetChildren()) do
                        safeDestroy(child)
                    end
                    safeDestroy(worldModel)
                end)
            end
            
            -- Zuerst 3D-Logo zerstören
            if logo3D then
                pcall(function() logo3D:Destroy() end)
            end
            
            -- Dann Effekte entfernen
            safeDestroy(blurEffect)
            safeDestroy(bloomEffect)
            
            -- Zum Schluss die UI entfernen
            safeDestroy(screenGui)
            
            -- Aufräumen von verbleibenden Effekten
            for _, effect in pairs(game:GetService("Lighting"):GetChildren()) do
                if string.match(effect.Name, "MythHub") then
                    safeDestroy(effect)
                end
            end
            
            -- Entferne alle Partikel aus workspace, die möglicherweise übrig geblieben sind
            for _, obj in pairs(workspace:GetChildren()) do
                if obj.Name:match("^Hologram_") or obj.Name == "WorldModel" then
                    safeDestroy(obj)
                end
            end
        end
    }
end 

function Myth3DUI.Engine.Object3D:CreateLightEffects()
	local lightEffects = Instance.new("Model")
	lightEffects.Name = "PremiumLighting"
	lightEffects.Parent = self.Scene
	
	-- Hauptlichtquelle
	local mainLight = Instance.new("PointLight")
	mainLight.Name = "MainLight"
	mainLight.Range = 20
	mainLight.Brightness = 0.8
	mainLight.Color = Color3.fromRGB(255, 200, 180)
	mainLight.Position = Vector3.new(5, 7, 5)
	mainLight.Parent = lightEffects
	
	-- Atmosphärisches Licht
	local ambientLight = Instance.new("PointLight")
	ambientLight.Name = "AmbientLight"
	ambientLight.Range = 30
	ambientLight.Brightness = 0.3
	ambientLight.Color = Color3.fromRGB(180, 200, 255)
	ambientLight.Position = Vector3.new(-5, 5, -5)
	ambientLight.Parent = lightEffects
	
	-- Akzentbeleuchtung
	local accentLight = Instance.new("SpotLight")
	accentLight.Name = "AccentLight"
	accentLight.Range = 15
	accentLight.Brightness = 0.5
	accentLight.Color = Color3.fromRGB(255, 220, 180)
	accentLight.Position = Vector3.new(0, 8, 0)
	accentLight.Face = Enum.NormalId.Bottom
	accentLight.Angle = 45
	accentLight.Parent = lightEffects
	
	-- Dynamische Beleuchtungsanimation
	self:AddAnimation("LightingDynamics", function(progress)
		local t = time()
		
		-- Sanfte Bewegung der Hauptlichtquelle
		mainLight.Position = Vector3.new(
			5 + math.sin(t * 0.2) * 2,
			7 + math.sin(t * 0.3) * 0.5,
			5 + math.cos(t * 0.2) * 2
		)
		
		-- Pulsierender Effekt für das ambiente Licht
		ambientLight.Brightness = 0.3 + math.sin(t * 0.4) * 0.1
		ambientLight.Color = Color3.fromRGB(
			180 + math.sin(t * 0.2) * 20,
			200 + math.sin(t * 0.3) * 20,
			255 + math.sin(t * 0.25) * 20
		)
		
		-- Akzentlicht-Animation
		accentLight.Position = Vector3.new(
			math.sin(t * 0.1) * 3,
			8,
			math.cos(t * 0.1) * 3
		)
		accentLight.Brightness = 0.5 + math.sin(t * 0.3) * 0.2
	end, 0.05, nil, true)
	
	return lightEffects
end

function Myth3DUI.Engine.Object3D:ApplyPremiumEffects(object)
	-- Rekursive Anwendung auf alle Kinder
	if object:IsA("Model") or object:IsA("Folder") then
		for _, child in pairs(object:GetChildren()) do
			self:ApplyPremiumEffects(child)
		end
		return
	end
	
	-- Nur auf Parts anwenden
	if not object:IsA("BasePart") then
		return
	end
	
	-- Verbesserte Materialien basierend auf Namen und Funktion
	if object.Name:match("Frame") or object.Name:match("Panel") then
		object.Material = Enum.Material.SmoothPlastic
		object.Reflectance = 0.05
		
		-- Ermöglicht ein leichtes Glühen an den Kanten
		if not object:FindFirstChild("SurfaceLight") then
			local edgeLight = Instance.new("SurfaceLight")
			edgeLight.Face = Enum.NormalId.Front
			edgeLight.Range = 1
			edgeLight.Brightness = 0.05
			edgeLight.Color = Color3.new(1, 1, 1)
			edgeLight.Parent = object
		end
	elseif object.Name:match("Button") then
		object.Material = Enum.Material.SmoothPlastic
		object.Reflectance = 0.1
		
		-- Interaktives Glühen für Knöpfe
		if not object:FindFirstChild("PointLight") then
			local buttonGlow = Instance.new("PointLight")
			buttonGlow.Range = 2
			buttonGlow.Brightness = 0.2
			buttonGlow.Color = object.Color:Lerp(Color3.new(1, 1, 1), 0.3)
			buttonGlow.Parent = object
		end
	elseif object.Name:match("Glass") or object.Name:match("Window") then
		object.Material = Enum.Material.Glass
		object.Reflectance = 0.2
		object.Transparency = 0.5
	elseif object.Name:match("Display") or object.Name:match("Screen") then
		object.Material = Enum.Material.Neon
		object.Reflectance = 0.1
		object.Transparency = 0.1
		
		-- Leuchtendes Display
		if not object:FindFirstChild("SurfaceLight") then
			local screenGlow = Instance.new("SurfaceLight")
			screenGlow.Face = Enum.NormalId.Front
			screenGlow.Range = 5
			screenGlow.Brightness = 0.3
			screenGlow.Color = object.Color
			screenGlow.Parent = object
		end
	end
	
	-- Spezielle Behandlung für Neon-Materialien
	if object.Material == Enum.Material.Neon then
		-- Verstärkt den Leuchteffekt
		if not object:FindFirstChild("PointLight") then
			local glowEffect = Instance.new("PointLight")
			glowEffect.Range = 5
			glowEffect.Brightness = 0.5
			glowEffect.Color = object.Color
			glowEffect.Parent = object
		end
	end
	
	return object
end

function Myth3DUI.Engine.Object3D:CreateReflectionSystem()
	local reflectionSystem = Instance.new("Model")
	reflectionSystem.Name = "ReflectionSystem"
	reflectionSystem.Parent = self.Scene
	
	-- Haupt-Reflexionsebene
	local reflectionPlane = Instance.new("Part")
	reflectionPlane.Name = "MainReflectionSurface"
	reflectionPlane.Anchored = true
	reflectionPlane.CanCollide = false
	reflectionPlane.Size = Vector3.new(20, 0.05, 20)
	reflectionPlane.Position = Vector3.new(0, -3, 0)
	reflectionPlane.Material = Enum.Material.SmoothPlastic
	reflectionPlane.Reflectance = 0.8
	reflectionPlane.Transparency = 0.3
	reflectionPlane.Color = Color3.fromRGB(20, 20, 40)
	reflectionPlane.Parent = reflectionSystem
	
	-- Glanz-Effekt hinzufügen
	local surfaceLight = Instance.new("SurfaceLight")
	surfaceLight.Face = Enum.NormalId.Top
	surfaceLight.Range = 10
	surfaceLight.Brightness = 0.3
	surfaceLight.Color = Color3.fromRGB(180, 200, 255)
	surfaceLight.Parent = reflectionPlane
	
	-- Ambiente Reflexionseffekte
	for i = 1, 4 do
		local reflectionPanelSide = Instance.new("Part")
		reflectionPanelSide.Name = "ReflectionPanel" .. i
		reflectionPanelSide.Anchored = true
		reflectionPanelSide.CanCollide = false
		reflectionPanelSide.Size = Vector3.new(20, 10, 0.05)
		reflectionPanelSide.Material = Enum.Material.Glass
		reflectionPanelSide.Reflectance = 0.4
		reflectionPanelSide.Transparency = 0.8
		reflectionPanelSide.Color = Color3.fromRGB(200, 220, 255)
		
		-- Positionierung der Seitenwände für Umgebungsreflexionen
		local angle = math.rad(90 * i)
		reflectionPanelSide.Position = Vector3.new(math.sin(angle) * 10, 2, math.cos(angle) * 10)
		reflectionPanelSide.CFrame = CFrame.new(reflectionPanelSide.Position, Vector3.new(0, 0, 0))
		
		reflectionPanelSide.Parent = reflectionSystem
	end
	
	-- Dynamische Reflexionsanimation
	self:AddAnimation("Reflections", function(progress)
		local t = time()
		
		-- Sanfte Bewegung des Hauptreflexionsplanes
		reflectionPlane.CFrame = CFrame.new(
			0, -3 + math.sin(t * 0.2) * 0.1, 0
		) * CFrame.Angles(
			math.sin(t * 0.1) * 0.03,
			t * 0.02,
			math.cos(t * 0.15) * 0.03
		)
		
		-- Anpassung der Reflexionsstärke für einen dynamischen Effekt
		reflectionPlane.Reflectance = 0.7 + math.sin(t * 0.3) * 0.1
		
		-- Animation der Seitenreflexionen
		for i = 1, 4 do
			local panel = reflectionSystem:FindFirstChild("ReflectionPanel" .. i)
			if panel then
				local angle = math.rad(90 * i) + t * 0.05
				local distance = 10 + math.sin(t * 0.1 + i) * 0.5
				
				panel.Position = Vector3.new(
					math.sin(angle) * distance, 
					2 + math.sin(t * 0.2 + i) * 0.5, 
					math.cos(angle) * distance
				)
				panel.CFrame = CFrame.new(panel.Position, Vector3.new(0, 0, 0))
				
				-- Leichtes Pulsieren der Transparenz
				panel.Transparency = 0.7 + math.sin(t * 0.2 + i * 0.5) * 0.1
			end
		end
		
		-- Animation des Oberflächenlichts
		surfaceLight.Brightness = 0.2 + math.sin(t * 0.4) * 0.1
		surfaceLight.Color = Color3.fromRGB(
			180 + math.sin(t * 0.2) * 20, 
			200 + math.sin(t * 0.3) * 20, 
			255 + math.sin(t * 0.5) * 20
		)
	end, 0.02, nil, true)
	
	return reflectionSystem
end

-- Hauptfunktion, die alle Premium-Effekte zusammenfasst
function Myth3DUI.Engine.Object3D:EnablePremiumRendering()
	-- Aktiviere hochwertige Rendering-Qualität
	local camera = workspace.CurrentCamera
	if camera then
		-- Effekte einstellen
		local depth = Instance.new("DepthOfFieldEffect")
		depth.FarIntensity = 0.15
		depth.FocusDistance = 10
		depth.InFocusRadius = 20
		depth.NearIntensity = 0
		depth.Parent = camera
		
		-- Verbesserte Lichteffekte für die Szene
		local ambientLight = Instance.new("ColorCorrectionEffect")
		ambientLight.Name = "AmbientEnhancement"
		ambientLight.Brightness = 0.02
		ambientLight.Contrast = 0.05
		ambientLight.Saturation = 0.1
		ambientLight.TintColor = Color3.fromRGB(250, 250, 255)
		ambientLight.Parent = camera
		
		-- Sanfter Bloom-Effekt
		local bloom = Instance.new("BloomEffect")
		bloom.Intensity = 0.2
		bloom.Size = 15
		bloom.Threshold = 0.95
		bloom.Parent = camera
	end
	
	-- Erzeuge Lichteffekte
	self:CreateLightEffects()
	
	-- Reflexionssystem erstellen
	self:CreateReflectionSystem()
	
	-- Anwenden von Premium-Effekten auf alle Objekte
	if self.Scene then
		self:ApplyPremiumEffects(self.Scene)
	end
	
	-- Dynamisches Hintergrundfeld
	local backgroundField = Instance.new("Part")
	backgroundField.Name = "DynamicBackgroundField"
	backgroundField.Anchored = true
	backgroundField.CanCollide = false
	backgroundField.Size = Vector3.new(40, 30, 40)
	backgroundField.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0)
	backgroundField.Material = Enum.Material.Neon
	backgroundField.Transparency = 0.97
	backgroundField.Color = Color3.fromRGB(20, 30, 80)
	backgroundField.Parent = self.Scene
	
	-- Hintergrundanimation
	self:AddAnimation("BackgroundEffect", function(progress)
		local t = time()
		backgroundField.CFrame = CFrame.new(0, 0, 0) * CFrame.Angles(
			math.sin(t * 0.1) * 0.05, 
			t * 0.03, 
			math.sin(t * 0.15) * 0.05
		)
		
		-- Leichte Farbänderungen
		backgroundField.Color = Color3.fromRGB(
			20 + math.sin(t * 0.2) * 10,
			30 + math.sin(t * 0.3) * 15,
			80 + math.sin(t * 0.25) * 20
		)
	end, 0.05, nil, true)
	
	return self
end

-- Configuration Section (neu hinzugefügt)
Tabs.MiscTab:Section({ Title = "Configuration" })

local currentConfigFileName = "DefaultSettings" -- Default filename
local configFilesDropdown = nil -- Placeholder for dropdown object
_G.AutoLoadConfigEnabled = false -- Default state for the toggle

-- Define which settings to manage
local SettingsToManage = {
    { Name = "AntiAFK", GVar = "_G.AntiAFK" },
    { Name = "FPSBoost", GVar = "_G.FPSBoost" }, 
    { Name = "DisableParticles", GVar = "_G.DisableParticles" },
    { Name = "WebhookEnabled", GVar = "_G.WebhookEnabled" },
    { Name = "WebhookURL", GVar = "_G.WebhookURL" },
    { Name = "WebhookInterval", GVar = "_G.WebhookInterval" },
    { Name = "AutoLoadConfigEnabled", GVar = "_G.AutoLoadConfigEnabled" } -- Add the new toggle state
}

-- Function to apply loaded settings (updates _G vars, TODO: update UI)
local function ApplyLoadedSettings(loadedData)
    if not loadedData then return end
    print("Applying loaded settings...")
    for _, setting in ipairs(SettingsToManage) do
        if loadedData[setting.Name] ~= nil then
            local valueToSet = loadedData[setting.Name]
            local gVarName = setting.GVar:gsub("_G.", "")
            _G[gVarName] = valueToSet
            print("- " .. setting.Name .. " = " .. tostring(valueToSet))
            -- TODO: Update the actual UI Toggle/Input state here if possible/needed!
            -- Requires having access to the UI objects (e.g., storing them in a table).
            
            -- Spezieller Fall für Anti-AFK - Verbindung aktivieren, wenn die Einstellung aktiviert wird
            if setting.Name == "AntiAFK" and valueToSet == true then
                if not _G.AntiAFKConnection then
                    _G.AntiAFKConnection = game:GetService("Players").LocalPlayer.Idled:Connect(function()
                        -- Simuliere Bewegung, um AFK-Kick zu verhindern
                        local VirtualUser = game:GetService("VirtualUser")
                        VirtualUser:CaptureController()
                        VirtualUser:ClickButton2(Vector2.new())
                        
                        -- Benachrichtigung
                        WindUI:Notify({
                            Title = "Anti-AFK",
                            Content = "AFK detection prevented",
                            Duration = 2,
                            Icon = "shield"
                        })
                    end)
                    
                    -- Benachrichtigung beim Aktivieren
                    WindUI:Notify({
                        Title = "Anti-AFK",
                        Content = "Anti-AFK protection enabled",
                        Duration = 3,
                        Icon = "user-check"
                    })
                end
            end
        end
    end
    print("Finished applying settings.")
end

-- UI Elements
local autoLoadToggle = Tabs.MiscTab:Toggle({
    Title = "Auto Load Default Settings on Start",
    Default = _G.AutoLoadConfigEnabled,
    Callback = function(state)
        _G.AutoLoadConfigEnabled = state
        print("Auto Load Config Enabled: " .. tostring(state))
    end
})

Tabs.MiscTab:Input({
    Title = "Config File Name",
    PlaceholderText = "Enter name (e.g., default)",
    Default = currentConfigFileName,
    Callback = function(text)
        currentConfigFileName = text
    end
})

Tabs.MiscTab:Button({
    Title = "Save Settings",
    Icon = "save",
    Callback = function()
        local settingsData = {}
        for _, setting in ipairs(SettingsToManage) do
            local gVarName = setting.GVar:gsub("_G.", "")
            if _G[gVarName] ~= nil then
                 settingsData[setting.Name] = _G[gVarName]
            else
                 print("Warning: Global variable " .. setting.GVar .. " not found for saving.")
            end
        end
        if SaveConfigToFile(currentConfigFileName, settingsData) then
             if configFilesDropdown then 
                 configFilesDropdown:Refresh(ListConfigFiles())
             end
        end
    end
})

configFilesDropdown = Tabs.MiscTab:Dropdown({
    Title = "Load/Overwrite Settings",
    AllowNone = true,
    Values = ListConfigFiles(),
    Callback = function(selectedFile)
        currentConfigFileName = selectedFile -- Update filename for Load/Overwrite
        if selectedFile and selectedFile ~= "" then
             local loadedData = LoadConfigFromFile(selectedFile)
             ApplyLoadedSettings(loadedData)
             -- Update the Auto Load toggle's visual state after loading
             if _G.AutoLoadConfigEnabled ~= nil then
                 autoLoadToggle:SetValue(_G.AutoLoadConfigEnabled)
             end
         end
    end
})

Tabs.MiscTab:Button({
    Title = "Refresh List",
    Icon = "refresh-cw",
    Callback = function()
        if configFilesDropdown then
            configFilesDropdown:Refresh(ListConfigFiles())
        end
    end
})

-- Auto-Load Logic (Runs once after UI is likely initialized)
spawn(function()
    wait(3) -- Wait a bit for UI elements to potentially be ready
    print("Checking for Auto Load...")
    -- Try loading the default settings file silently to check AutoLoad status
    local defaultData = LoadConfigFromFile("DefaultSettings") 
    if defaultData and defaultData.AutoLoadConfigEnabled == true then
        print("Auto Load enabled in DefaultSettings.json. Applying settings...")
        ApplyLoadedSettings(defaultData)
        -- Ensure the toggle reflects the loaded state
        autoLoadToggle:SetValue(true)
    else
        print("Auto Load not enabled or DefaultSettings.json not found/configured.")
        -- Ensure the toggle reflects the default state (false)
        autoLoadToggle:SetValue(false)
    end
end)
