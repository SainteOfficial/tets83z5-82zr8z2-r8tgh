-- Verbesserter Mob Attack Script mit Hitbox Expander
-- Version 4.0 mit schnelleren Reaktionszeiten und besserer Positionierung
-- Erweitert: Bessere Überlebenschancen, Ausweichmechanismus und Vorausberechnung

-- Services laden (mit Fehlerprüfung)
local Players = game:GetService("Players") or error("Players service nicht verfügbar")
local RunService = game:GetService("RunService") or error("RunService nicht verfügbar")
local UserInputService = game:GetService("UserInputService") or error("UserInputService nicht verfügbar")
local VirtualInputManager = game:GetService("VirtualInputManager") or error("VirtualInputManager nicht verfügbar")
local TweenService = game:GetService("TweenService") or error("TweenService nicht verfügbar")
local ReplicatedStorage = game:GetService("ReplicatedStorage") or error("ReplicatedStorage nicht verfügbar")

-- Player und wichtige Variablen (mit Fehlerprüfung)
local Player = Players.LocalPlayer 
if not Player then
    error("LocalPlayer nicht gefunden - Script kann nicht fortfahren")
    return -- Beende Script
end

-- Erweiterte Konfiguration
local CONFIG = {
    HOVER_HEIGHT = 13,            -- Erhöht für bessere Sicht und Angriffswinkel
    ATTACK_DISTANCE = 90,         -- Erhöht für früheres Erkennen von Mobs
    ATTACK_INTERVAL = 0.03,       -- Stark reduziert für schnellere Angriffe
    HITBOX_SIZE_MULTIPLIER = 4,   -- Größere Hitbox für bessere Trefferchancen
    POSITION_SPEED = 0.05,        -- Verkürzte Positionierungszeit
    AUTO_DODGE = true,            -- Neue Funktion: Automatisches Ausweichen
    DODGE_THRESHOLD = 40,         -- HP-Schwelle für Ausweichmanöver
    PREDICT_MOVEMENT = true,      -- Neue Funktion: Vorhersage der Mob-Bewegung
    PRIORITY_TARGETING = true,    -- Neue Funktion: Priorisierte Ziele
    DEBUG_ENABLED = true          -- Auf false setzen, um Debug-Prints zu deaktivieren
}

-- Erweiterte Statusvariablen
local STATE = {
    isAttacking = false,
    isHitboxExpanded = false,
    selectedMob = nil,
    noClipEnabled = false,
    mobAttackCooldown = {},
    mobHealthCache = {},          -- Neu: Cache für Mob-Gesundheit
    playerMaxHealth = 0,          -- Neu: Speichert maximale Gesundheit des Spielers
    lastAttackTime = 0,           -- Neu: Zeitpunkt des letzten Angriffs
    dodgeInProgress = false,      -- Neu: Status des Ausweichmanövers
    mobPriorities = {},           -- Neu: Mobs nach Priorität
    nearbyPlayerCount = 0,        -- Neu: Anzahl der Spieler in der Nähe
    connections = {},
    guiElements = {}
}

-- Debug Funktion mit Sicherheitscheck
local function DebugPrint(message)
    if CONFIG.DEBUG_ENABLED and message then
        local timeStamp = os.date("%H:%M:%S")
        print("[" .. timeStamp .. "] [MOB ATTACKER] " .. tostring(message))
    end
end

DebugPrint("Script wird initialisiert...")

-- Character-Setup mit vollständiger Fehlerprüfung
local Character, Humanoid, HumanoidRootPart

local function SetupCharacter(char)
    if not char then
        DebugPrint("WARNUNG: SetupCharacter aufgerufen mit nil character")
        return false
    end
    
    Character = char
    
    -- Auf Humanoid warten mit kürzerem Timeout
    local startTime = tick()
    while not Character:FindFirstChild("Humanoid") and tick() - startTime < 3 do
        wait(0.05) -- Schnelleres Polling
    end
    
    Humanoid = Character:FindFirstChild("Humanoid")
    if not Humanoid then
        DebugPrint("FEHLER: Humanoid nicht gefunden nach Timeout")
        return false
    end
    
    -- Maximale Gesundheit speichern
    STATE.playerMaxHealth = Humanoid.MaxHealth
    
    -- Auf HumanoidRootPart warten mit kürzerem Timeout
    startTime = tick()
    while not Character:FindFirstChild("HumanoidRootPart") and tick() - startTime < 3 do
        wait(0.05) -- Schnelleres Polling
    end
    
    HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then
        DebugPrint("FEHLER: HumanoidRootPart nicht gefunden nach Timeout")
        return false
    end
    
    DebugPrint("Character erfolgreich eingerichtet")
    
    -- Gesundheitsüberwachung für Ausweichmechanismus
    if Humanoid then
        local healthChangedConn = Humanoid.HealthChanged:Connect(function(health)
            -- Ausweichen bei niedriger Gesundheit
            if CONFIG.AUTO_DODGE and health < (STATE.playerMaxHealth * (CONFIG.DODGE_THRESHOLD / 100)) 
                and not STATE.dodgeInProgress then
                PerformEmergencyDodge()
            end
        end)
        table.insert(STATE.connections, healthChangedConn)
    end
    
    return true
end

-- Verbindung hinzufügen mit Prüfung
local function AddConnection(connection)
    if connection then
        table.insert(STATE.connections, connection)
        return connection
    end
    DebugPrint("WARNUNG: Versuch, eine nil Connection hinzuzufügen")
    return nil
end

-- Neuer Notfall-Ausweichmechanismus
local function PerformEmergencyDodge()
    if STATE.dodgeInProgress or not HumanoidRootPart or not Humanoid then return end
    
    STATE.dodgeInProgress = true
    DebugPrint("⚠️ KRITISCHER GESUNDHEITSSTATUS: Starte Notfall-Ausweichmanöver!")
    
    -- Status-Update
    if STATE.guiElements.StatusLabel then
        STATE.guiElements.StatusLabel.Text = "⚠️ AUSWEICHMANÖVER!"
    end
    
    -- Temporär Angriff pausieren
    local wasAttacking = STATE.isAttacking
    STATE.isAttacking = false
    
    -- Ausweichmanöver mit zufälliger Richtung
    pcall(function()
        -- Aktuelle Position merken
        local currentPos = HumanoidRootPart.Position
        
        -- Zufällige Ausweichrichtung
        local dodgeDistance = 50 -- 50 Studs Ausweichdistanz
        local randomAngle = math.random() * math.pi * 2
        local dodgeOffset = Vector3.new(
            math.cos(randomAngle) * dodgeDistance,
            30, -- Nach oben ausweichen
            math.sin(randomAngle) * dodgeDistance
        )
        
        -- Schnelles Ausweichen mit Tween
        local dodgeTween = TweenService:Create(
            HumanoidRootPart, 
            TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
            {CFrame = CFrame.new(currentPos + dodgeOffset)}
        )
        
        -- Ausweichen starten
        dodgeTween:Play()
        
        -- Warten auf Abschluss des Ausweichens
        dodgeTween.Completed:Wait()
        
        -- Kurze Erholungszeit
        wait(1.5)
        
        -- Angriffsmodus wiederherstellen
        STATE.isAttacking = wasAttacking
        STATE.dodgeInProgress = false
        
        if STATE.guiElements.StatusLabel then
            STATE.guiElements.StatusLabel.Text = STATE.isAttacking and "Suche Mobs..." or "Bereit"
        end
        
        DebugPrint("Ausweichmanöver abgeschlossen!")
    end)
end

-- GUI erstellen mit Fehlerbehandlung und erweiterten Informationen
local function CreateGUI()
    DebugPrint("Erstelle GUI...")
    
    -- Prüfe, ob GUI bereits existiert
    if Player:FindFirstChild("PlayerGui") and Player.PlayerGui:FindFirstChild("MobAttackerGUI") then
        Player.PlayerGui.MobAttackerGUI:Destroy()
        DebugPrint("Alte GUI entfernt")
    end
    
    -- Schütze vor Fehlern
    local success, result = pcall(function()
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "MobAttackerGUI"
        ScreenGui.ResetOnSpawn = false
        ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        
        -- Für DisplayGuiWithOldBehavior
        pcall(function()
            ScreenGui.DisplayOrder = 999
        end)
        
        -- GUI an korrektem Ort platzieren
        if Player:FindFirstChild("PlayerGui") then
            ScreenGui.Parent = Player.PlayerGui
        else
            DebugPrint("PlayerGui nicht gefunden, wechsle zu CoreGui")
            -- Versuche Backup-Plan
            pcall(function()
                ScreenGui.Parent = game:GetService("CoreGui")
            end)
        end
        
        -- Hauptrahmen
        local MainFrame = Instance.new("Frame")
        MainFrame.Name = "ControlFrame"
        MainFrame.Size = UDim2.new(0, 220, 0, 170) -- Vergrößert für zusätzliche Info
        MainFrame.Position = UDim2.new(0.85, -110, 0.8, -85)
        MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        MainFrame.BackgroundTransparency = 0.2
        MainFrame.BorderSizePixel = 0
        MainFrame.Parent = ScreenGui
        
        -- Abgerundete Ecken
        local UICorner = Instance.new("UICorner")
        UICorner.CornerRadius = UDim.new(0, 10)
        UICorner.Parent = MainFrame
        
        -- Titel
        local Title = Instance.new("TextLabel")
        Title.Name = "TitleLabel"
        Title.Size = UDim2.new(1, 0, 0, 30)
        Title.BackgroundTransparency = 1
        Title.Text = "Mob Controller v4.0"
        Title.Font = Enum.Font.GothamBold
        Title.TextSize = 18
        Title.TextColor3 = Color3.fromRGB(255, 255, 255)
        Title.Parent = MainFrame
        
        -- Status-Anzeige
        local StatusLabel = Instance.new("TextLabel")
        StatusLabel.Name = "StatusLabel"
        StatusLabel.Size = UDim2.new(1, 0, 0, 20)
        StatusLabel.Position = UDim2.new(0, 0, 0.19, 0)
        StatusLabel.BackgroundTransparency = 1
        StatusLabel.Text = "Bereit"
        StatusLabel.Font = Enum.Font.Gotham
        StatusLabel.TextSize = 14
        StatusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        StatusLabel.Parent = MainFrame
        
        -- Mob Info Label (NEU)
        local MobInfoLabel = Instance.new("TextLabel")
        MobInfoLabel.Name = "MobInfoLabel"
        MobInfoLabel.Size = UDim2.new(1, 0, 0, 20)
        MobInfoLabel.Position = UDim2.new(0, 0, 0.31, 0)
        MobInfoLabel.BackgroundTransparency = 1
        MobInfoLabel.Text = "Kein Mob ausgewählt"
        MobInfoLabel.Font = Enum.Font.Gotham
        MobInfoLabel.TextSize = 12
        MobInfoLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        MobInfoLabel.Parent = MainFrame
        
        -- Angriff-Knopf
        local AttackButton = Instance.new("TextButton")
        AttackButton.Name = "AttackButton"
        AttackButton.Size = UDim2.new(0.85, 0, 0, 35)
        AttackButton.Position = UDim2.new(0.075, 0, 0.45, 0)
        AttackButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
        AttackButton.Text = "Angriff: AUS"
        AttackButton.Font = Enum.Font.GothamSemibold
        AttackButton.TextSize = 16
        AttackButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        AttackButton.ClipsDescendants = true
        AttackButton.Parent = MainFrame
        
        -- Button-Rundung
        local AttackCorner = Instance.new("UICorner")
        AttackCorner.CornerRadius = UDim.new(0, 6)
        AttackCorner.Parent = AttackButton
        
        -- Hitbox-Knopf
        local HitboxButton = Instance.new("TextButton")
        HitboxButton.Name = "HitboxButton"
        HitboxButton.Size = UDim2.new(0.85, 0, 0, 35)
        HitboxButton.Position = UDim2.new(0.075, 0, 0.67, 0)
        HitboxButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
        HitboxButton.Text = "Hitbox: AUS"
        HitboxButton.Font = Enum.Font.GothamSemibold
        HitboxButton.TextSize = 16
        HitboxButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        HitboxButton.Parent = MainFrame
        
        -- Button-Rundung
        local HitboxCorner = Instance.new("UICorner")
        HitboxCorner.CornerRadius = UDim.new(0, 6)
        HitboxCorner.Parent = HitboxButton
        
        -- Ausweichen-Knopf (NEU)
        local DodgeButton = Instance.new("TextButton")
        DodgeButton.Name = "DodgeButton"
        DodgeButton.Size = UDim2.new(0.85, 0, 0, 30)
        DodgeButton.Position = UDim2.new(0.075, 0, 0.87, 0)
        DodgeButton.BackgroundColor3 = Color3.fromRGB(50, 120, 220)
        DodgeButton.Text = "Ausweichen"
        DodgeButton.Font = Enum.Font.GothamSemibold
        DodgeButton.TextSize = 14
        DodgeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        DodgeButton.Parent = MainFrame
        
        -- Button-Rundung
        local DodgeCorner = Instance.new("UICorner")
        DodgeCorner.CornerRadius = UDim.new(0, 6)
        DodgeCorner.Parent = DodgeButton
        
        -- Button-Click-Effekte
        AttackButton.MouseButton1Click:Connect(function()
            STATE.isAttacking = not STATE.isAttacking
            
            -- Visuelles Feedback
            local goalColor = STATE.isAttacking and Color3.fromRGB(50, 180, 50) or Color3.fromRGB(220, 50, 50)
            local buttonTween = TweenService:Create(AttackButton, TweenInfo.new(0.3), {BackgroundColor3 = goalColor})
            buttonTween:Play()
            
            AttackButton.Text = STATE.isAttacking and "Angriff: AN" or "Angriff: AUS"
            StatusLabel.Text = STATE.isAttacking and "Suche Mobs..." or "Bereit"
            
            -- Einfacher Ripple-Effekt
            local ripple = Instance.new("Frame")
            ripple.Name = "Ripple"
            ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            ripple.BackgroundTransparency = 0.7
            ripple.BorderSizePixel = 0
            ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
            ripple.AnchorPoint = Vector2.new(0.5, 0.5)
            ripple.Size = UDim2.new(0, 0, 0, 0)
            ripple.ZIndex = 2
            
            -- Rundung für Ripple
            local rippleCorner = Instance.new("UICorner")
            rippleCorner.CornerRadius = UDim.new(1, 0)
            rippleCorner.Parent = ripple
            
            ripple.Parent = AttackButton
            
            local targetSize = UDim2.new(2, 0, 2, 0)
            local rippleTween = TweenService:Create(ripple, TweenInfo.new(0.5), {Size = targetSize, BackgroundTransparency = 1})
            rippleTween:Play()
            
            delay(0.5, function()
                ripple:Destroy()
            end)
            
            -- Bei Aktivierung Fly-Modus aktivieren
            if STATE.isAttacking then
                EnableImprovedFly()
            end
            
            DebugPrint("Angriffsmodus: " .. tostring(STATE.isAttacking))
        end)
        
        HitboxButton.MouseButton1Click:Connect(function()
            STATE.isHitboxExpanded = not STATE.isHitboxExpanded
            
            -- Visuelles Feedback
            local goalColor = STATE.isHitboxExpanded and Color3.fromRGB(50, 180, 50) or Color3.fromRGB(220, 50, 50)
            local buttonTween = TweenService:Create(HitboxButton, TweenInfo.new(0.3), {BackgroundColor3 = goalColor})
            buttonTween:Play()
            
            HitboxButton.Text = STATE.isHitboxExpanded and "Hitbox: AN" or "Hitbox: AUS"
            
            -- Einfacher Ripple-Effekt
            local ripple = Instance.new("Frame")
            ripple.Name = "Ripple"
            ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            ripple.BackgroundTransparency = 0.7
            ripple.BorderSizePixel = 0
            ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
            ripple.AnchorPoint = Vector2.new(0.5, 0.5)
            ripple.Size = UDim2.new(0, 0, 0, 0)
            ripple.ZIndex = 2
            
            -- Rundung für Ripple
            local rippleCorner = Instance.new("UICorner")
            rippleCorner.CornerRadius = UDim.new(1, 0)
            rippleCorner.Parent = ripple
            
            ripple.Parent = HitboxButton
            
            local targetSize = UDim2.new(2, 0, 2, 0)
            local rippleTween = TweenService:Create(ripple, TweenInfo.new(0.5), {Size = targetSize, BackgroundTransparency = 1})
            rippleTween:Play()
            
            delay(0.5, function()
                if ripple and ripple.Parent then
                    ripple:Destroy()
                end
            end)
            
            -- Hitboxen aktivieren/deaktivieren
            ToggleHitboxes(STATE.isHitboxExpanded)
            
            DebugPrint("Hitbox-Modus: " .. tostring(STATE.isHitboxExpanded))
        end)
        
        -- NEU: Ausweichbutton-Effekt
        DodgeButton.MouseButton1Click:Connect(function()
            PerformEmergencyDodge()
            
            -- Visuelles Feedback
            local origColor = DodgeButton.BackgroundColor3
            local buttonTween = TweenService:Create(DodgeButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(100, 200, 255)})
            buttonTween:Play()
            
            local ripple = Instance.new("Frame")
            ripple.Name = "DodgeRipple"
            ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            ripple.BackgroundTransparency = 0.7
            ripple.BorderSizePixel = 0
            ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
            ripple.AnchorPoint = Vector2.new(0.5, 0.5)
            ripple.Size = UDim2.new(0, 0, 0, 0)
            ripple.ZIndex = 2
            
            local rippleCorner = Instance.new("UICorner")
            rippleCorner.CornerRadius = UDim.new(1, 0)
            rippleCorner.Parent = ripple
            
            ripple.Parent = DodgeButton
            
            local targetSize = UDim2.new(2, 0, 2, 0)
            local rippleTween = TweenService:Create(ripple, TweenInfo.new(0.5), {Size = targetSize, BackgroundTransparency = 1})
            rippleTween:Play()
            
            delay(0.5, function()
                ripple:Destroy()
                TweenService:Create(DodgeButton, TweenInfo.new(0.3), {BackgroundColor3 = origColor}):Play()
            end)
        end)
        
        -- Elemente speichern
        return {
            ScreenGui = ScreenGui, 
            StatusLabel = StatusLabel,
            MobInfoLabel = MobInfoLabel,
            AttackButton = AttackButton,
            HitboxButton = HitboxButton,
            DodgeButton = DodgeButton
        }
    end)
    
    if success and result then
        DebugPrint("GUI erfolgreich erstellt")
        STATE.guiElements = result
        return result
    else
        DebugPrint("FEHLER bei GUI-Erstellung: " .. tostring(result))
        -- Fallback minimale GUI
        local minGui = Instance.new("ScreenGui")
        minGui.Name = "MinimalMobAttackerGUI"
        pcall(function() minGui.Parent = Player.PlayerGui end)
        
        local minButton = Instance.new("TextButton")
        minButton.Text = "MOB CONTROL v4"
        minButton.Size = UDim2.new(0, 100, 0, 40)
        minButton.Position = UDim2.new(0.9, -50, 0.9, -20)
        minButton.Parent = minGui
        
        return {ScreenGui = minGui, StatusLabel = nil}
    end
end

-- Berechne Mob-Priorität (NEU)
local function CalculateMobPriority(mob)
    if not mob then return 0 end
    
    local priority = 0
    local mobHumanoid = mob:FindFirstChild("Humanoid")
    
    -- Grundpriorität basierend auf Name (für bestimmte Mobtypen)
    local name = mob.Name:lower()
    if name:find("boss") then 
        priority = priority + 20
    elseif name:find("elite") then
        priority = priority + 10
    elseif name:find("rare") then 
        priority = priority + 15
    end
    
    -- Priorisiere schwächere Mobs für schnelle Erfolge
    if mobHumanoid then
        local healthPercentage = mobHumanoid.Health / mobHumanoid.MaxHealth
        -- Niedrigere Gesundheit = höhere Priorität
        priority = priority + (20 * (1 - healthPercentage))
    end
    
    return priority
end

-- Verbesserte Mob-Suche mit Prioritäten und Vorhersage
local function FindClosestMob()
    -- Sicherheitschecks
    if not Character or not HumanoidRootPart then
        DebugPrint("FEHLER: Character oder HumanoidRootPart nicht verfügbar bei Mob-Suche")
        return nil
    end

    -- Mobs-Ordner finden
    local Mobs = workspace:FindFirstChild("Mobs")
    if not Mobs then
        DebugPrint("FEHLER: Mobs-Ordner nicht gefunden in workspace")
        return nil
    end
    
    local candidates = {}
    local playerPosition = HumanoidRootPart.Position
    
    -- Sichere Iteration durch Mobs
    for _, mob in pairs(Mobs:GetChildren()) do
        if mob and mob:IsA("Model") then
            local mobRoot = mob:FindFirstChild("HumanoidRootPart")
            local mobHumanoid = mob:FindFirstChild("Humanoid")
            
            if mobRoot and mobHumanoid and mobHumanoid.Health > 0 then
                -- Distanz mit pcall berechnen
                local success, distance = pcall(function()
                    return (playerPosition - mobRoot.Position).Magnitude
                end)
                
                if success and distance < CONFIG.ATTACK_DISTANCE then
                    -- Cooldown-Check
                    local onCooldown = false
                    if STATE.mobAttackCooldown[mob] and tick() - STATE.mobAttackCooldown[mob] < 1.5 then
                        onCooldown = true
                    end
                    
                    if not onCooldown then
                        -- Mob-Bewegung vorhersagen
                        local predictedPosition = mobRoot.Position
                        
                        if CONFIG.PREDICT_MOVEMENT then
                            -- Einfache lineare Vorhersage basierend auf aktueller Geschwindigkeit
                            if mobRoot.Velocity.Magnitude > 1 then
                                predictedPosition = mobRoot.Position + (mobRoot.Velocity * 0.2)
                            end
                        end
                        
                        -- Berechnete Distanz zur vorhergesagten Position
                        local predictedDistance = (playerPosition - predictedPosition).Magnitude
                        
                        -- Mob-Priorität berechnen
                        local priority = CONFIG.PRIORITY_TARGETING and CalculateMobPriority(mob) or 0
                        
                        -- Auf die Kandidatenliste setzen
                        table.insert(candidates, {
                            mob = mob,
                            distance = predictedDistance,
                            priority = priority,
                            health = mobHumanoid.Health,
                            maxHealth = mobHumanoid.MaxHealth,
                            position = predictedPosition
                        })
                    end
                end
            end
        end
    end
    
    -- Keine Mobs gefunden
    if #candidates == 0 then
        return nil
    end
    
    -- Mobs nach kombinierten Faktoren sortieren (Distanz & Priorität)
    table.sort(candidates, function(a, b)
        -- Priorisiere nach einer Kombination aus Distanz und Priorität
        local scoreA = a.distance - (a.priority * 5)
        local scoreB = b.distance - (b.priority * 5)
        return scoreA < scoreB
    end)
    
    -- Besten Mob auswählen
    local bestCandidate = candidates[1]
    
    -- Mob-Info für GUI aktualisieren
    if STATE.guiElements.MobInfoLabel then
        STATE.guiElements.MobInfoLabel.Text = bestCandidate.mob.Name .. 
            " | HP: " .. math.floor(bestCandidate.health) .. "/" .. math.floor(bestCandidate.maxHealth) ..
            " | " .. math.floor(bestCandidate.distance) .. "m"
    end
    
    -- Aktualisiere Mob-Gesundheitscache
    STATE.mobHealthCache[bestCandidate.mob] = bestCandidate.health
    
    if bestCandidate.mob then
        DebugPrint("Mob gefunden: " .. bestCandidate.mob.Name .. 
                   " | Distanz: " .. math.floor(bestCandidate.distance) .. 
                   " | Priorität: " .. bestCandidate.priority)
    end
    
    return bestCandidate.mob, bestCandidate.position
end

-- Hitbox-Funktion mit Fehlerprüfung und verbesserter Visualisierung
local function ToggleHitboxes(enabled)
    -- Sicherstellen, dass der Parameter korrekt ist
    enabled = (enabled == true)
    
    local Mobs = workspace:FindFirstChild("Mobs")
    if not Mobs then
        DebugPrint("FEHLER: Mobs-Ordner nicht gefunden")
        return
    end
    
    DebugPrint("Hitboxen werden " .. (enabled and "aktiviert" : "deaktiviert"))
    
    for _, mob in pairs(Mobs:GetChildren()) do
        -- Sichere Verarbeitung jedes Mobs
        if mob and mob:IsA("Model") then
            pcall(function()
                local mobRoot = mob:FindFirstChild("HumanoidRootPart")
                if mobRoot then
                    -- Ursprüngliche Größe wiederherstellen
                    if not enabled then
                        local originalSize = mobRoot:FindFirstChild("OriginalSize")
                        -- Fortsetzung der ToggleHitboxes Funktion
                        if originalSize then
                            -- Ursprüngliche Größe zurücksetzen
                            mobRoot.Size = originalSize.Value
                            originalSize:Destroy()
                        end
                        
                        -- Hitbox-Visualisierung entfernen
                        local visualizer = mobRoot:FindFirstChild("HitboxVisualizer")
                        if visualizer then
                            visualizer:Destroy()
                        end
                    else
                        -- Originalgröße speichern, falls noch nicht geschehen
                        if not mobRoot:FindFirstChild("OriginalSize") then
                            local originalSize = Instance.new("Vector3Value")
                            originalSize.Name = "OriginalSize"
                            originalSize.Value = mobRoot.Size
                            originalSize.Parent = mobRoot
                        end
                        
                        -- Hitbox vergrößern
                        mobRoot.Size = mobRoot.Size * CONFIG.HITBOX_SIZE_MULTIPLIER
                        
                        -- Visualisierung hinzufügen, wenn sie nicht existiert
                        if not mobRoot:FindFirstChild("HitboxVisualizer") then
                            local visualizer = Instance.new("SelectionBox")
                            visualizer.Name = "HitboxVisualizer"
                            visualizer.Adornee = mobRoot
                            visualizer.Color3 = Color3.fromRGB(255, 50, 50)
                            visualizer.LineThickness = 0.02
                            visualizer.Transparency = 0.7
                            visualizer.Parent = mobRoot
                        end
                    end
                    
                    -- Keine Kollision mit Spieler
                    if mobRoot:FindFirstChild("CanCollide") then
                        mobRoot.CanCollide = not enabled
                    end
                end
            end)
        end
    end
    
    DebugPrint("Hitbox-Änderungen abgeschlossen")
end

-- Verbesserter Flug-Modus
local function EnableImprovedFly()
    if not HumanoidRootPart or STATE.noClipEnabled then
        return
    end
    
    STATE.noClipEnabled = true
    DebugPrint("Verbesserter Flug-Modus aktiviert")
    
    -- NoClip-Verbindung erstellen
    local noClipConn = RunService.Stepped:Connect(function()
        if not HumanoidRootPart then
            return
        end
        
        pcall(function()
            -- NoClip für alle Character-Teile aktivieren
            for _, part in pairs(Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end)
    
    table.insert(STATE.connections, noClipConn)
end

-- Verbesserte Mob-Angriffslogik
local function AttackMob(mob, predictedPosition)
    if not mob or not HumanoidRootPart or not Character then
        return false
    end
    
    -- Mob-Komponenten finden
    local mobRoot = mob:FindFirstChild("HumanoidRootPart")
    if not mobRoot then 
        return false 
    end
    
    -- Positionierung über dem Mob mit Tween
    local targetPosition = mobRoot.Position + Vector3.new(0, CONFIG.HOVER_HEIGHT, 0)
    
    -- Bei Vorhersage anpassen
    if predictedPosition then
        targetPosition = predictedPosition + Vector3.new(0, CONFIG.HOVER_HEIGHT, 0)
    end
    
    -- Geschmeidigere Bewegung zum Ziel
    local moveTween = TweenService:Create(
        HumanoidRootPart, 
        TweenInfo.new(CONFIG.POSITION_SPEED, Enum.EasingStyle.Quad), 
        {CFrame = CFrame.new(targetPosition, mobRoot.Position)}
    )
    
    moveTween:Play()
    
    -- Angriffsversuch mit Error-Handling
    pcall(function()
        -- Angriffsanimation aktivieren
        if Humanoid and Humanoid:FindFirstChildOfClass("Animator") then
            local animator = Humanoid:FindFirstChildOfClass("Animator")
            local animations = animator:GetPlayingAnimationTracks()
            
            -- Bereits spielende Angriffsanimation stoppen
            for _, anim in pairs(animations) do
                if anim.Name:find("Attack") then
                    anim:Stop()
                end
            end
        end
        
        -- Werkzeug zum Angriff nutzen
        local tool = Character:FindFirstChildOfClass("Tool")
        if tool then
            -- Angriffsfunktion aufrufen
            local attackFunction = tool:FindFirstChild("Attack") or 
                                   tool:FindFirstChild("AttackFunction") or
                                   tool:FindFirstChild("Combat")
                                   
            if attackFunction and attackFunction:IsA("RemoteEvent") then
                attackFunction:FireServer()
                STATE.lastAttackTime = tick()
                
                -- Mob in Cooldown setzen
                STATE.mobAttackCooldown[mob] = tick()
                
                return true
            end
            
            -- Alternative: Aktiviere Werkzeug direkt
            tool:Activate()
            STATE.lastAttackTime = tick()
            
            -- Mob in Cooldown setzen
            STATE.mobAttackCooldown[mob] = tick()
            
            return true
        else
            -- Kein Werkzeug gefunden, versuche direkte Kampfmethode
            local combatRemote = ReplicatedStorage:FindFirstChild("CombatRemote") or
                                 ReplicatedStorage:FindFirstChild("Combat") or
                                 ReplicatedStorage:FindFirstChild("AttackEvent")
                                 
            if combatRemote and combatRemote:IsA("RemoteEvent") then
                combatRemote:FireServer(mob)
                STATE.lastAttackTime = tick()
                
                -- Mob in Cooldown setzen
                STATE.mobAttackCooldown[mob] = tick()
                
                return true
            end
        end
    end)
    
    return false
end

-- Main-Loop mit verbessertem Error-Handling
local function StartMainLoop()
    DebugPrint("Starte Hauptprozess...")
    
    -- Hauptschleife
    local mainLoopConn = RunService.Heartbeat:Connect(function()
        pcall(function()
            -- Prüfe Character-Status
            if not Character or not Character.Parent or not Humanoid or not HumanoidRootPart then
                -- Charakter verloren, versuche Neueinrichtung
                if Player.Character and Player.Character ~= Character then
                    DebugPrint("Charakter hat sich geändert, richte neu ein...")
                    SetupCharacter(Player.Character)
                end
                return
            end
            
            -- Mob-Angriff
            if STATE.isAttacking then
                -- Angriffsintervall einhalten
                if tick() - STATE.lastAttackTime >= CONFIG.ATTACK_INTERVAL then
                    -- Nächstes Ziel finden
                    local targetMob, predictedPosition = FindClosestMob()
                    
                    if targetMob then
                        STATE.selectedMob = targetMob
                        AttackMob(targetMob, predictedPosition)
                    else
                        -- Kein Mob gefunden
                        STATE.selectedMob = nil
                        if STATE.guiElements.MobInfoLabel then
                            STATE.guiElements.MobInfoLabel.Text = "Kein Mob in Reichweite"
                        end
                    end
                end
            end
        end)
    end)
    
    table.insert(STATE.connections, mainLoopConn)
end

-- Aufräumfunktion
local function CleanUp()
    DebugPrint("Aufräumen gestartet...")
    
    -- Verbindungen trennen
    for _, connection in pairs(STATE.connections) do
        if typeof(connection) == "RBXScriptConnection" and connection.Connected then
            connection:Disconnect()
        end
    end
    
    -- Hitboxen zurücksetzen
    ToggleHitboxes(false)
    
    -- GUI entfernen
    if STATE.guiElements.ScreenGui then
        STATE.guiElements.ScreenGui:Destroy()
    end
    
    -- Status zurücksetzen
    STATE.isAttacking = false
    STATE.isHitboxExpanded = false
    STATE.noClipEnabled = false
    STATE.selectedMob = nil
    STATE.connections = {}
    STATE.guiElements = {}
    
    DebugPrint("Aufräumen abgeschlossen")
end

-- Tastenbindungen einrichten
local function SetupKeybinds()
    DebugPrint("Richte Tastenbindungen ein...")
    
    local keybindConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Enum.KeyCode.T then
            -- T-Taste: Angriffsmodus umschalten
            STATE.isAttacking = not STATE.isAttacking
            
            if STATE.guiElements.AttackButton then
                STATE.guiElements.AttackButton.Text = STATE.isAttacking and "Angriff: AN" or "Angriff: AUS"
                STATE.guiElements.AttackButton.BackgroundColor3 = STATE.isAttacking and 
                    Color3.fromRGB(50, 180, 50) or Color3.fromRGB(220, 50, 50)
            end
            
            if STATE.guiElements.StatusLabel then
                STATE.guiElements.StatusLabel.Text = STATE.isAttacking and "Suche Mobs..." or "Bereit"
            end
            
            DebugPrint("Angriffsmodus umgeschaltet: " .. tostring(STATE.isAttacking))
            
            -- Bei Aktivierung Fly-Modus starten
            if STATE.isAttacking and not STATE.noClipEnabled then
                EnableImprovedFly()
            end
        elseif input.KeyCode == Enum.KeyCode.H then
            -- H-Taste: Hitbox-Modus umschalten
            STATE.isHitboxExpanded = not STATE.isHitboxExpanded
            
            if STATE.guiElements.HitboxButton then
                STATE.guiElements.HitboxButton.Text = STATE.isHitboxExpanded and "Hitbox: AN" or "Hitbox: AUS"
                STATE.guiElements.HitboxButton.BackgroundColor3 = STATE.isHitboxExpanded and 
                    Color3.fromRGB(50, 180, 50) or Color3.fromRGB(220, 50, 50)
            end
            
            ToggleHitboxes(STATE.isHitboxExpanded)
            DebugPrint("Hitbox-Modus umgeschaltet: " .. tostring(STATE.isHitboxExpanded))
        elseif input.KeyCode == Enum.KeyCode.R then
            -- R-Taste: Notfallausweichen
            PerformEmergencyDodge()
        end
    end)
    
    table.insert(STATE.connections, keybindConn)
end

-- INITIALISIERUNG 

-- Character einrichten, wenn schon vorhanden
if Player.Character then
    SetupCharacter(Player.Character)
end

-- Character-Added-Event
local characterAddedConn = Player.CharacterAdded:Connect(function(char)
    DebugPrint("Neuer Character erkannt, richte ein...")
    SetupCharacter(char)
end)

table.insert(STATE.connections, characterAddedConn)

-- GUI erstellen
CreateGUI()

-- Tastenbindungen einrichten
SetupKeybinds()

-- Main-Loop starten
StartMainLoop()

-- Beenden bei Skript-Neustart oder Entfernung
local function OnScriptEnd()
    CleanUp()
    DebugPrint("Script wurde beendet.")
end

-- Skript-Beendigungserkennung
local scriptCon
scriptCon = game:GetService("RunService").Heartbeat:Connect(function()
    if not script.Parent then
        scriptCon:Disconnect()
        OnScriptEnd()
    end
end)

DebugPrint("Mob Attack Script v4.0 erfolgreich initialisiert!")

-- Script-Ende
