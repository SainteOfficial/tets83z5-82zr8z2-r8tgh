--[[
    MythHub Premium
    Game: Anime Card Clash
    Created by: MythTeam
    
    Features:
    - Dashboard mit Informationen und Statistiken
    - AutoFarm für Gegner aus allen Welten
    - Tower-Automatisierung für Battle und Infinite Towers
    - Raid-Unterstützung und Automatisierung
    - Explorations-Management
    - Shop-Automatisierung
    - Verschiedene Utilities wie Auto-Pickup, Auto-Merge und mehr
    
    Zuletzt aktualisiert: Mai 2025
]]

print("Nothing to see here :O")

-- Load Luna Interface Library
local Luna = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/refs/heads/main/source.lua", true))()

-- Initialize Window without Key System
local Window = Luna:CreateWindow({
    Name = "MythHub Premium",
    Subtitle = "Anime Card Clash",
    LogoID = "134758479713826", -- MythHub logo ID
    LoadingEnabled = true,
    LoadingTitle = "MythHub Premium",
    LoadingSubtitle = "Anime Card Clash Edition",
    
    ConfigSettings = {
        RootFolder = "MythHub",
        ConfigFolder = "AnimeCardClash"
    },
    
    KeySystem = false
})

-- Utility Functions
local Utilities = {}

-- Füge eine sicherere WaitForChild-Funktion mit Timeout hinzu
Utilities.SafeWaitForChild = function(parent, childName, timeout)
    timeout = timeout or 10 -- Standard-Timeout von 10 Sekunden
    
    local startTime = os.time()
    local child = nil
    
    -- Versuche das Kind zu finden, bis es gefunden wird oder das Timeout erreicht ist
    while not child and os.time() - startTime < timeout do
        child = parent:FindFirstChild(childName)
        if child then
            return child
        end
        wait(0.1) -- Kurz warten, um nicht zu viel CPU zu verbrauchen
    end
    
    -- Wenn das Kind nicht gefunden wurde, gib eine Warnung aus
    if not child then
        warn("SafeWaitForChild: Konnte " .. childName .. " in " .. parent.Name .. " nicht finden (Timeout nach " .. timeout .. " Sekunden)")
        return nil
    end
    
    return child
end

-- Function to summon an enemy for battle
Utilities.SummonEnemy = function(enemyName)
    if not enemyName then
        return false
    end
    
    local success, result = pcall(function()
        local args = {
            [1] = enemyName
        }
        
        local replicatedStorage = game:GetService("ReplicatedStorage")
        -- Verwende SafeWaitForChild statt WaitForChild, um Infinite Yield zu vermeiden
        local childkQR = Utilities.SafeWaitForChild(replicatedStorage, "kQR", 5)
        if not childkQR then
            return false
        end
        
        local battleRemote = Utilities.SafeWaitForChild(childkQR, "8a63919a-217b-436a-9cfa-4b472d213bbb", 3)
        if not battleRemote then
            return false
        end
        
        battleRemote:FireServer(unpack(args))
        return true
    end)
    
    if not success then
        warn("SummonEnemy fehlgeschlagen: " .. tostring(result))
        return false
    end
    
    return true
end

-- Function to get local player
Utilities.GetLocalPlayer = function()
    return game:GetService("Players").LocalPlayer
end

-- Function to check if a player is in game
Utilities.IsInGame = function()
    return game:IsLoaded() and Utilities.GetLocalPlayer() ~= nil
end

-- Function to create notifications
Utilities.Notify = function(title, content, icon)
    Luna:Notification({
        Title = title or "MythHub Notification",
        Content = content or "Action completed successfully",
        Icon = icon or "notifications_active",
        ImageSource = "Material"
    })
end

-- Function to get Battle Tower level
Utilities.GetBattleTowerLevel = function()
    local success, result = pcall(function()
        local replicatedStorage = game:GetService("ReplicatedStorage")
        local TS = Utilities.SafeWaitForChild(replicatedStorage, "TS", 5)
        if not TS then return 1 end
        
        local user = Utilities.SafeWaitForChild(TS, "user", 3)
        if not user then return 1 end
        
        local localFolder = Utilities.SafeWaitForChild(user, "local", 3)
        if not localFolder then return 1 end
        
        local LocalUserModule = Utilities.SafeWaitForChild(localFolder, "local-user", 3)
        if not LocalUserModule then return 1 end
        
        local LocalUser = require(LocalUserModule).LocalUser
        local battleTowerWave = LocalUser.metadata:getAsNumber("battle_tower_wave")
        return battleTowerWave or 1
    end)
    
    if success then
        return result
    else
        return 1
    end
end

-- Function to get Infinite Tower floor
Utilities.GetInfiniteTowerFloor = function()
    local success, result = pcall(function()
        local LocalUser = require(game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        
        if LocalUser and LocalUser.infiniteTower then
            local document = LocalUser.infiniteTower:getDocument()
            if document and document.floor then
                return document.floor
            end
        end
        return 1
    end)
    
    if success and result then
        return result
    else
        return 1
    end
end

-- Function to get available upgrade points
Utilities.GetUpgradePoints = function()
    local success, result = pcall(function()
        local LocalUser = require(game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        return LocalUser.upgrades:getCards()
    end)
    
    if success then
        return result
    else
        return 0
    end
end

-- Function to check if player is in battle
Utilities.IsInBattle = function()
    local success, result = pcall(function()
        local localPlayer = Utilities.GetLocalPlayer()
        if localPlayer and localPlayer.PlayerGui then
            -- Prüft, ob eine der Kampf-GUIs existiert
            local hasBattleGui = localPlayer.PlayerGui:FindFirstChild("battle") ~= nil
            local hasHideBattleButton = localPlayer.PlayerGui:FindFirstChild("HideBattleButton") ~= nil
            
            -- Wenn eine der beiden GUIs existiert, ist der Spieler noch im Kampf
            return hasBattleGui or hasHideBattleButton
        end
        return false
    end)
    
    if success then
        return result
    else
        return false
    end
end

-- Function to check if battle just ended
Utilities.IsBattleEnded = function()
    local success, result = pcall(function()
        local localPlayer = Utilities.GetLocalPlayer()
        if localPlayer and localPlayer.PlayerGui then
            local hasBattleEndGui = localPlayer.PlayerGui:FindFirstChild("battle-end") ~= nil
            return hasBattleEndGui
        end
        return false
    end)
    
    if success then
        return result
    else
        return false
    end
end

-- Function to simulate mouse clicks (M1) in the middle-bottom of the screen
Utilities.ClickM1 = function(times)
    times = times or 10
    
    pcall(function()
        -- Get screen size
        local screenSize = workspace.CurrentCamera.ViewportSize
        local middleX = screenSize.X / 2
        local lowerY = screenSize.Y * 0.7 -- 70% down the screen (middle-bottom)
        
        for i = 1, times do
            game:GetService("VirtualInputManager"):SendMouseButtonEvent(middleX, lowerY, 0, true, game, 1)
            wait(0.1)
            game:GetService("VirtualInputManager"):SendMouseButtonEvent(middleX, lowerY, 0, false, game, 1)
            wait(0.1)
        end
    end)
end

-- Function to dismiss battle end screen
Utilities.DismissBattleEnd = function()
    -- Sicherheitsüberprüfung mit pcall
    pcall(function()
        if Utilities.IsBattleEnded() then
            wait(3)
            
            -- Klicke M1 wiederholt, bis der Endbildschirm weg ist
            local maxAttempts = 30 -- Maximale Versuche, um Endlosschleifen zu vermeiden
            local attempts = 0
            
            while Utilities.IsBattleEnded() and attempts < maxAttempts do
                -- Versuche, mit M1 zu klicken
                pcall(function()
                    Utilities.ClickM1(3)
                end)
                wait(0.5)
                attempts = attempts + 1
            end
            
            -- Etwas länger warten, um sicherzustellen, dass alles geschlossen ist
            wait(1)
        end
    end)
end

-- AutoFarm Configuration
local AutoFarmConfig = {
    Enabled = false,
    CurrentWorld = "Ninja Village",
    CurrentEnemy = "unstoppable_fist",
    AutoCollect = false,
    AutoMerge = false,
    AutoFarmAllWorldBosses = false,
    AutoFarmAllEnemies = false,
    SelectedWorlds = {"Ninja Village"},
    SelectedEnemies = {"unstoppable_fist"},
    WorldBosses = {
        "bijuu_beast",           -- Naruto Rage Mode
        "awakened_galactic_tyrant", -- Frieza
        "king_of_curses",        -- Sukuna
        "combat_giant",          -- Eren
        "awakened_pale_demon_lord", -- Muzan
        "soul_queen",            -- Big Mom
        "awakened_shadow_monarch"  -- Sung Jinwoo
    },
    AllEnemies = {
        -- Ninja Village
        "unstoppable_fist", -- Rock Lee
        "copy_ninja", -- Kakashi
        "awakened_dark_avenger", -- Sasuke
        "awakened_promised_child", -- Naruto Sage Mode
        "six_paths_of_pain", -- Pain
        "bijuu_beast", -- Naruto Rage Mode (Boss)
        
        -- Green Village
        "ultimate_warrior", -- Son Gohan
        "body_switcher", -- Captain Ginyu
        "namekian_sage", -- Piccolo
        "awakened_prideful_prince", -- Vegeta
        "awakened_earth_strongest", -- Goku
        "awakened_galactic_tyrant", -- Frieza (Boss)
        
        -- Shibuya Station
        "cursed_doll", -- Nobara
        "awakened_shadow_summoner", -- Megumi
        "cursed_fist", -- Yuji
        "rika_blessing", -- Yuta
        "limitless_master", -- Gojo
        "king_of_curses", -- Sukuna (Boss)
        
        -- Titans City
        "survey_commander", -- Erwin
        "blade_warrior", -- Mikasa
        "armored_giant", -- Reiner
        "beast_giant", -- Zeke
        "blade_captain", -- Levi
        "combat_giant", -- Eren (Boss)
        
        -- Dimensional Fortress
        "thunder_demon", -- Kaigaku
        "childish_demon", -- Hantengu
        "compass_demon", -- Akaza
        "awakened_frost_demon", -- Doma
        "awakened_six_eyed_slayer", -- Kokushibo
        "awakened_pale_demon_lord", -- Muzan (Boss)
        
        -- Candy Island
        "genie_commander", -- Daifuku
        "candy_master", -- Perospero
        "biscuit_warrior", -- Cracker
        "juice_queen", -- Smoothie
        "mochi_emperor", -- Katakuri
        "soul_queen", -- Big Mom (Boss)
        
        -- Solo City
        "light_saintess", -- Cha Hae-In
        "the_goliath", -- Thomas Andre
        "shadow_bear", -- Tank
        "shadow_commander", -- Igris
        "shadow_ant", -- Beru
        "awakened_shadow_monarch" -- Sung Jinwoo (Boss)
    },
    Interval = 10 * 60, -- 10 minutes cooldown
    Connections = {},
    EnemyCooldowns = {} -- Stellen wir sicher, dass dies als leeres Table initialisiert wird
}

-- Funktion, um sicherzustellen, dass EnemyCooldowns existiert
Utilities.EnsureEnemyCooldownsInitialized = function()
    if not AutoFarmConfig.EnemyCooldowns then
        AutoFarmConfig.EnemyCooldowns = {}
    end
end

-- Function to handle battle flow and start next battle
Utilities.StartNextBattle = function(enemyName)
    -- Sicherheitsüberprüfung für nil
    if not enemyName then
        return false
    end
    
    -- Stellen wir sicher, dass EnemyCooldowns existiert
    Utilities.EnsureEnemyCooldownsInitialized()
    
    -- Cooldown-Überprüfung mit Fehlerbehandlung
    local onCooldown = false
    pcall(function()
        local currentTime = os.time()
        if enemyName and AutoFarmConfig.EnemyCooldowns[enemyName] and AutoFarmConfig.EnemyCooldowns[enemyName] > currentTime then
            onCooldown = true
        end
    end)
    
    if onCooldown then
        return false
    end
    
    -- Überprüfung des Spielstatus mit Fehlerbehandlung
    local inBattle = Utilities.IsInBattle()
    local battleEnded = Utilities.IsBattleEnded()
    
    if inBattle then
        return false -- Bereits im Kampf, kann keinen neuen starten
    end
    
    if battleEnded then
        pcall(function()
            Utilities.DismissBattleEnd()
        end)
        wait(1) -- Kurz warten, um sicherzustellen, dass der Endbildschirm weg ist
        return false
    end
    
    -- Erneute Überprüfung, ob wir den Kampf starten können
    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
        local success = false
        
        -- Versuche, den Gegner zu beschwören
        pcall(function()
            local args = {
                [1] = enemyName
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
            success = true
        end)
        
        if success then
            -- Warten, damit der Kampf gestartet werden kann
            wait(2)
            
            -- Prüfen, ob wir im Kampf sind
            if Utilities.IsInBattle() then
                return true
            else
                -- Wenn wir nicht im Kampf sind, obwohl wir den Gegner beschworen haben, könnte er auf Cooldown sein
                pcall(function()
                    if enemyName and not (enemyName == "eternal_dragon" or enemyName == "shadow_dragon") then
                        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + AutoFarmConfig.Interval
                    end
                end)
                return false
            end
        end
        
        return success
    end
    
    return false
end

-- Function to mark an enemy as defeated (sets its cooldown)
Utilities.MarkEnemyDefeated = function(enemyName)
    if not enemyName then
        return
    end
    
    -- Check if enemy is a raid boss (eternal_dragon or shadow_dragon) or world boss
    local isRaidBoss = (enemyName == "eternal_dragon" or enemyName == "shadow_dragon")
    local isWorldBoss = false
    
    -- Check if it's a world boss
    for _, boss in ipairs(AutoFarmConfig.WorldBosses) do
        if enemyName == boss then
            isWorldBoss = true
            break
        end
    end
    
    -- Only set cooldown if it's not a raid boss
    if isRaidBoss then
        return
    elseif isWorldBoss then
        -- Still apply cooldown for world bosses (not raid bosses)
        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + 600
    else
        -- Set cooldown to exactly 10 minutes (600 seconds) for regular enemies
        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + 600
    end
end

-- Enemy display names mapping
local EnemyDisplayNames = {
    -- Ninja Village
    unstoppable_fist = "Rock Lee",
    copy_ninja = "Kakashi",
    awakened_dark_avenger = "Sasuke",
    awakened_promised_child = "Naruto Sage Mode",
    six_paths_of_pain = "Pain",
    bijuu_beast = "Naruto Rage Mode (Boss)",
    
    -- Green Village
    ultimate_warrior = "Son Gohan",
    body_switcher = "Captain Ginyu",
    namekian_sage = "Piccolo",
    awakened_prideful_prince = "Vegeta",
    awakened_earth_strongest = "Goku",
    awakened_galactic_tyrant = "Frieza (Boss)",
    
    -- Shibuya Station
    cursed_doll = "Nobara",
    awakened_shadow_summoner = "Megumi",
    cursed_fist = "Yuji",
    rika_blessing = "Yuta",
    limitless_master = "Gojo",
    king_of_curses = "Sukuna (Boss)",
    
    -- Titans City
    survey_commander = "Erwin",
    blade_warrior = "Mikasa",
    armored_giant = "Reiner",
    beast_giant = "Zeke",
    blade_captain = "Levi",
    combat_giant = "Eren (Boss)",
    
    -- Dimensional Fortress
    thunder_demon = "Kaigaku",
    childish_demon = "Hantengu",
    compass_demon = "Akaza",
    awakened_frost_demon = "Doma",
    awakened_six_eyed_slayer = "Kokushibo",
    awakened_pale_demon_lord = "Muzan (Boss)",
    
    -- Candy Island
    genie_commander = "Daifuku",
    candy_master = "Perospero",
    biscuit_warrior = "Cracker",
    juice_queen = "Smoothie",
    mochi_emperor = "Katakuri",
    soul_queen = "Big Mom (Boss)",
    
    -- Solo City
    light_saintess = "Cha Hae-In",
    the_goliath = "Thomas Andre",
    shadow_bear = "Tank",
    shadow_commander = "Igris",
    shadow_ant = "Beru",
    awakened_shadow_monarch = "Sung Jinwoo (Boss)"
}

-- Function to generate enemy display options for dropdown
local function getEnemyDisplayOptions(enemies)
    local displayOptions = {}
    for _, enemyCode in ipairs(enemies) do
        table.insert(displayOptions, EnemyDisplayNames[enemyCode] .. " (" .. enemyCode .. ")")
    end
    return displayOptions
end

-- Function to extract enemy code from display option
local function getEnemyCodeFromDisplayOption(displayOption)
    return string.match(displayOption, "%(([^%)]+)%)")
end

-- Initialize Tabs
local TabDashboard = Window:CreateTab({
    Name = "Dashboard",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabAutoFarm = Window:CreateTab({
    Name = "AutoFarm",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabTowers = Window:CreateTab({
    Name = "Towers",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabRaids = Window:CreateTab({
    Name = "Raids",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabExploration = Window:CreateTab({
    Name = "Exploration",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabShop = Window:CreateTab({
    Name = "Shop",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabMisc = Window:CreateTab({
    Name = "Misc",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabSettings = Window:CreateTab({
    Name = "Settings",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

-- Create Home Tab with information dashboard
Window:CreateHomeTab({
    SupportedExecutors = {}, -- Kein Executor-Check, damit der Script für alle funktioniert
    DiscordInvite = "MythHubDiscord",
    Icon = 2
})

-- Dashboard Tab
TabDashboard:CreateParagraph({
    Title = "Welcome to MythHub Premium - Anime Card Clash",
    Text = "Thank you for choosing MythHub Premium for Anime Card Clash. This script offers a comprehensive suite of features to enhance your gameplay experience. Our premium features are optimized for the best executors on the market."
})

TabDashboard:CreateSection("Player Statistics")

local stats_section = TabDashboard:CreateParagraph({
    Title = "Your Statistics",
    Text = "Loading player statistics..."
})

-- Update player stats periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            local tower_level = Utilities.GetBattleTowerLevel()
            local infinite_floor = Utilities.GetInfiniteTowerFloor()
            local upgrade_points = Utilities.GetUpgradePoints()
            
            stats_section:Set({
                Text = "Battle Tower Level: " .. tower_level .. 
                      "\nInfinite Tower Floor: " .. infinite_floor .. 
                      "\nAvailable Upgrade Points: " .. upgrade_points
            })
        end
    end
end)

TabDashboard:CreateDivider()

-- Add executor compatibility warning
TabDashboard:CreateSection("Executor Compatibility")

TabDashboard:CreateParagraph({
    Title = "Free Executor Limitations",
    Text = "Please note that free executors may not support all features due to their limitations. Specifically:\n\n• Battle Tower automation will not work properly\n• Stat Points features are incompatible with free executors\n\nOther features like AutoFarm and basic automation should function normally. For the best experience, we recommend using premium executors such as Synapse X, Script-Ware, or Fluxus."
})

TabDashboard:CreateDivider()

TabDashboard:CreateSection("Latest Updates")

TabDashboard:CreateParagraph({
    Title = "Recent Changes",
    Text = "• Added Auto Raid function with boss detection\n• Improved AutoFarm efficiency and stability\n• Added Auto-Merge functionality\n• Fixed issues with Tower automation\n• Improved UI responsiveness"
})

-- Add premium features highlight
TabDashboard:CreateDivider()

TabDashboard:CreateSection("Premium Features")

TabDashboard:CreateParagraph({
    Title = "MythHub Premium Advantages",
    Text = "• Advanced Battle Tower automation (Premium executors only)\n• Stat Points optimization system\n• Multi-world boss farming\n• Intelligent cooldown management\n• Automatic exploration team management\n• Premium support via our Discord"
})

-- AutoFarm Tab
TabAutoFarm:CreateSection("Enemy Farm Configuration")

-- World selection
local world_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select Worlds",
    Description = "Choose the worlds to farm enemies from",
    Options = {"Ninja Village", "Green Village", "Shibuya Station", "Titans City", "Dimensional Fortress", "Candy Island", "Solo City"},
    CurrentOption = {"Ninja Village"},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Option)
        AutoFarmConfig.SelectedWorlds = Option
        -- Update enemy dropdown based on selected worlds
        updateEnemyDropdown(Option)
    end
}, "WorldSelection")

-- Enemy dropdown (will be updated based on world selection)
local enemy_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select Enemies",
    Description = "Choose the enemies to farm",
    Options = getEnemyDisplayOptions({"unstoppable_fist", "copy_ninja", "awakened_dark_avenger", "awakened_promised_child", "six_paths_of_pain", "bijuu_beast"}),
    CurrentOption = {EnemyDisplayNames["unstoppable_fist"] .. " (unstoppable_fist)"},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Option)
        local selectedEnemies = {}
        for _, displayOption in ipairs(Option) do
            local enemyCode = getEnemyCodeFromDisplayOption(displayOption)
            if enemyCode then
                table.insert(selectedEnemies, enemyCode)
            end
        end
        AutoFarmConfig.SelectedEnemies = selectedEnemies
        AutoFarmConfig.CurrentEnemy = selectedEnemies[1] or "unstoppable_fist"
    end
}, "EnemySelection")

-- Function to update enemy dropdown based on world selection
function updateEnemyDropdown(worlds)
    local allEnemies = {}
    local enemyCodes = {}
    
    -- If no worlds selected, default to Ninja Village
    if #worlds == 0 then
        worlds = {"Ninja Village"}
    end
    
    for _, world in ipairs(worlds) do
        if world == "Ninja Village" then
            for _, enemy in ipairs({"unstoppable_fist", "copy_ninja", "awakened_dark_avenger", "awakened_promised_child", "six_paths_of_pain", "bijuu_beast"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Green Village" then
            for _, enemy in ipairs({"ultimate_warrior", "body_switcher", "namekian_sage", "awakened_prideful_prince", "awakened_earth_strongest", "awakened_galactic_tyrant"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Shibuya Station" then
            for _, enemy in ipairs({"cursed_doll", "awakened_shadow_summoner", "cursed_fist", "rika_blessing", "limitless_master", "king_of_curses"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Titans City" then
            for _, enemy in ipairs({"survey_commander", "blade_warrior", "armored_giant", "beast_giant", "blade_captain", "combat_giant"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Dimensional Fortress" then
            for _, enemy in ipairs({"thunder_demon", "childish_demon", "compass_demon", "awakened_frost_demon", "awakened_six_eyed_slayer", "awakened_pale_demon_lord"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Candy Island" then
            for _, enemy in ipairs({"genie_commander", "candy_master", "biscuit_warrior", "juice_queen", "mochi_emperor", "soul_queen"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Solo City" then
            for _, enemy in ipairs({"light_saintess", "the_goliath", "shadow_bear", "shadow_commander", "shadow_ant", "awakened_shadow_monarch"}) do
                enemyCodes[enemy] = true
            end
        end
    end
    
    -- Convert to array
    for enemyCode, _ in pairs(enemyCodes) do
        table.insert(allEnemies, enemyCode)
    end
    
    -- Get display options
    local displayOptions = getEnemyDisplayOptions(allEnemies)
    
    -- Update dropdown
    enemy_dropdown:Set({
        Options = displayOptions,
        CurrentOption = {displayOptions[1]}
    })
    
    -- Update selected enemies
    AutoFarmConfig.SelectedEnemies = {allEnemies[1] or "unstoppable_fist"}
    AutoFarmConfig.CurrentEnemy = allEnemies[1] or "unstoppable_fist"
end

TabAutoFarm:CreateDivider()
TabAutoFarm:CreateSection("World Bosses")

-- World Boss section (moved from Raid tab)
local world_boss_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select World Boss",
    Description = "Choose a world boss to battle",
    Options = {
        "Naruto Rage Mode (bijuu_beast)",
        "Frieza (awakened_galactic_tyrant)",
        "Sukuna (king_of_curses)",
        "Eren (combat_giant)",
        "Muzan (awakened_pale_demon_lord)",
        "Big Mom (soul_queen)",
        "Sung Jinwoo (awakened_shadow_monarch)"
    },
    CurrentOption = {"Naruto Rage Mode (bijuu_beast)"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        -- Nothing needed here, will be used in the button below
    end
}, "WorldBossSelection")

TabAutoFarm:CreateButton({
    Name = "Fight Selected Boss",
    Description = "Start a battle against the selected world boss",
    Callback = function()
        local boss = world_boss_dropdown.CurrentOption
        if type(boss) == "table" then
            boss = boss[1]
        end
        
        local bossCode = getEnemyCodeFromDisplayOption(boss)
        if bossCode then
            Utilities.SummonEnemy(bossCode)
        end
    end
})

TabAutoFarm:CreateDivider()
TabAutoFarm:CreateSection("Auto Farm Options")

-- Auto Farm All World Bosses toggle
local autofarm_all_bosses_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm All World Bosses",
    Description = "Automatically cycles through all world bosses",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoFarmAllWorldBosses = Value
        
        if Value then
            -- Start auto farm all bosses
            Utilities.Notify("Auto Farm", "Started auto farming all world bosses", "auto_mode")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoFarmAllBosses then
                AutoFarmConfig.Connections.AutoFarmAllBosses:Disconnect()
            end
            
            -- Create new auto farm loop
            AutoFarmConfig.Connections.AutoFarmAllBosses = spawn(function()
                local currentBossIndex = 1
                local currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex] or "bijuu_beast"
                
                while AutoFarmConfig.AutoFarmAllWorldBosses do
                    -- Check if we need to update the current boss (for bosses not on cooldown)
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Try to find a boss that's not on cooldown
                        local allOnCooldown = true
                        local startingIndex = currentBossIndex
                        
                        for i = 1, #AutoFarmConfig.WorldBosses do
                            -- Calculate the next boss index with wrap-around
                            local nextIndex = (startingIndex + i - 1) % #AutoFarmConfig.WorldBosses + 1
                            local nextBoss = AutoFarmConfig.WorldBosses[nextIndex]
                            
                            -- Check if this boss is on cooldown
                            local currentTime = os.time()
                            if not AutoFarmConfig.EnemyCooldowns[nextBoss] or AutoFarmConfig.EnemyCooldowns[nextBoss] <= currentTime then
                                currentBossIndex = nextIndex
                                currentBoss = nextBoss
                                allOnCooldown = false
                                break
                            end
                        end
                        
                        if allOnCooldown then
                            -- All bosses are on cooldown, find the one with the shortest remaining cooldown
                            local shortestCooldown = math.huge
                            local shortestIndex = 1
                            
                            for i = 1, #AutoFarmConfig.WorldBosses do
                                local boss = AutoFarmConfig.WorldBosses[i]
                                local remainingCooldown = (AutoFarmConfig.EnemyCooldowns[boss] or 0) - currentTime
                                
                                if remainingCooldown < shortestCooldown then
                                    shortestCooldown = remainingCooldown
                                    shortestIndex = i
                                end
                            end
                            
                            currentBossIndex = shortestIndex
                            currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex]
                            
                            wait(math.min(5, math.max(1, shortestCooldown))) -- Wait at least 1 second, at most 5 seconds
                        else
                            -- Try to start battle with current boss (which is not on cooldown)
                            Utilities.StartNextBattle(currentBoss)
                        end
                    elseif Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        
                        -- Once battle is dismissed, mark the boss as defeated and move to next
                        if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(currentBoss)
                            
                            -- Move to next boss for next iteration
                            currentBossIndex = currentBossIndex % #AutoFarmConfig.WorldBosses + 1
                            currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex]
                        end
                    end
                    
                    -- Wait 1 second before next check
                    wait(1)
                end
            end)
        else
            -- Stop auto farm all bosses
            Utilities.Notify("Auto Farm", "Stopped auto farming all world bosses", "stop_circle")
            
            -- Disconnect auto farm loop
            if AutoFarmConfig.Connections.AutoFarmAllBosses then
                AutoFarmConfig.Connections.AutoFarmAllBosses:Disconnect()
                AutoFarmConfig.Connections.AutoFarmAllBosses = nil
            end
        end
    end
}, "AutoFarmAllEnemiesToggle")

-- Auto Farm Toggle
local autofarm_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm Selected Enemy",
    Description = "Automatically spawns the currently selected enemy after cooldown",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.Enabled = Value
        
        if Value then
            Utilities.Notify("Auto Farm", "Started auto farming " .. AutoFarmConfig.CurrentEnemy .. " in " .. table.concat(AutoFarmConfig.SelectedWorlds, ", "), "auto_mode")
            
            if AutoFarmConfig.Connections.AutoFarm then
                AutoFarmConfig.Connections.AutoFarm:Disconnect()
            end
            
            AutoFarmConfig.Connections.AutoFarm = spawn(function()
                while AutoFarmConfig.Enabled do
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local currentTime = os.time()
                        if AutoFarmConfig.CurrentEnemy and AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] and AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] > currentTime then
                            local remainingCooldown = math.ceil(AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] - currentTime)
                            wait(math.min(5, remainingCooldown))
                        else
                            Utilities.StartNextBattle(AutoFarmConfig.CurrentEnemy)
                        end
                    elseif Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        
                        if AutoFarmConfig.CurrentEnemy and not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(AutoFarmConfig.CurrentEnemy)
                        end
                    end
                    
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Farm", "Stopped auto farming", "stop_circle")
            
            if AutoFarmConfig.Connections.AutoFarm then
                AutoFarmConfig.Connections.AutoFarm:Disconnect()
                AutoFarmConfig.Connections.AutoFarm = nil
            end
        end
    end
}, "AutoFarmToggle")

-- Auto collect loop ändern (langsamerer Tween)
local autocollect_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Collect Items",
    Description = "Automatically collects dropped items",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoCollect = Value
        
        if Value then
            -- Start auto collect
            Utilities.Notify("Auto Collect", "Started auto collecting items", "inventory_2")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoCollect then
                AutoFarmConfig.Connections.AutoCollect:Disconnect()
            end
            
            -- Create new auto collect loop
            AutoFarmConfig.Connections.AutoCollect = spawn(function()
                while AutoFarmConfig.AutoCollect do
                    pcall(function()
                        local items = workspace.Folder:GetChildren()
                        
                        for _, item in pairs(items) do
                            if item:IsA("Model") and AutoFarmConfig.AutoCollect then
                                -- Get item position
                                local itemPosition = item:GetPivot().Position
                                
                                -- Get player's character and humanoid root part
                                local character = Utilities.GetLocalPlayer().Character
                                if character and character:FindFirstChild("HumanoidRootPart") then
                                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                                    
                                    -- Tween to the item (langsamerer Tween: 2.0 statt 0.5 Sekunden)
                                    local tweenService = game:GetService("TweenService")
                                    local tweenInfo = TweenInfo.new(2.0, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                                    
                                    local tween = tweenService:Create(
                                        humanoidRootPart,
                                        tweenInfo,
                                        {CFrame = CFrame.new(itemPosition)}
                                    )
                                    
                                    tween:Play()
                                    tween.Completed:Wait()
                                    
                                    -- Wait a bit to ensure item is collected
                                    wait(0.5)
                                end
                            end
                        end
                    end)
                    
                    wait(1) -- Wait before checking for new items
                end
            end)
        else
            -- Stop auto collect
            Utilities.Notify("Auto Collect", "Stopped auto collecting items", "stop_circle")
            
            -- Disconnect auto collect loop
            if AutoFarmConfig.Connections.AutoCollect then
                AutoFarmConfig.Connections.AutoCollect:Disconnect()
                AutoFarmConfig.Connections.AutoCollect = nil
            end
        end
    end
}, "AutoCollectToggle")

-- Auto merge toggle
local automerge_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Merge Units",
    Description = "Automatically merges your units",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoMerge = Value
        
        if Value then
            -- Start auto merge
            Utilities.Notify("Auto Merge", "Started auto merging units", "merge")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoMerge then
                AutoFarmConfig.Connections.AutoMerge:Disconnect()
            end
            
            -- Create new auto merge loop
            AutoFarmConfig.Connections.AutoMerge = spawn(function()
                while AutoFarmConfig.AutoMerge do
                    pcall(function()
                        -- Example auto merge code
                        local args = {
                            [1] = 0,
                            [2] = "light_admiral",
                            [3] = 200,
                            [4] = false
                        }
                        
                        game:GetService("ReplicatedStorage"):WaitForChild("noV"):WaitForChild("b57b2bf9-5561-408a-8668-8d7afa1b05f0"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Wait before attempting to merge again
                end
            end)
        else
            -- Stop auto merge
            Utilities.Notify("Auto Merge", "Stopped auto merging units", "stop_circle")
            
            -- Disconnect auto merge loop
            if AutoFarmConfig.Connections.AutoMerge then
                AutoFarmConfig.Connections.AutoMerge:Disconnect()
                AutoFarmConfig.Connections.AutoMerge = nil
            end
        end
    end
}, "AutoMergeToggle")

-- Auto Farm All Enemies in Order toggle
local autofarm_all_enemies_inorder_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm All Enemies (In Order)",
    Description = "Automatically cycles through all enemies in the exact order from the list",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoFarmAllEnemies = Value
        
        if Value then
            Utilities.Notify("Auto Farm", "Started auto farming all enemies in exact order", "auto_mode")
            
            if AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder then
                AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder:Disconnect()
            end
            
            AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder = spawn(function()
                local enemyIndex = 1
                
                -- Liste aller Gegner in exakter Reihenfolge
                local allEnemiesInOrder = {
                    -- Ninja Village
                    "unstoppable_fist", -- Rock Lee
                    "copy_ninja", -- Kakashi
                    "awakened_dark_avenger", -- Sasuke
                    "awakened_promised_child", -- Naruto Sage Mode
                    "six_paths_of_pain", -- Pain
                    "bijuu_beast", -- Naruto Rage Mode (Boss)
                    
                    -- Green Village
                    "ultimate_warrior", -- Son Gohan
                    "body_switcher", -- Captain Ginyu
                    "namekian_sage", -- Piccolo
                    "awakened_prideful_prince", -- Vegeta
                    "awakened_earth_strongest", -- Goku
                    "awakened_galactic_tyrant", -- Frieza (Boss)
                    
                    -- Shibuya Station
                    "cursed_doll", -- Nobara
                    "awakened_shadow_summoner", -- Megumi
                    "cursed_fist", -- Yuji
                    "rika_blessing", -- Yuta
                    "limitless_master", -- Gojo
                    "king_of_curses", -- Sukuna (Boss)
                    
                    -- Titans City
                    "survey_commander", -- Erwin
                    "blade_warrior", -- Mikasa
                    "armored_giant", -- Reiner
                    "beast_giant", -- Zeke
                    "blade_captain", -- Levi
                    "combat_giant", -- Eren (Boss)
                    
                    -- Dimensional Fortress
                    "thunder_demon", -- Kaigaku
                    "childish_demon", -- Hantengu
                    "compass_demon", -- Akaza
                    "awakened_frost_demon", -- Doma
                    "awakened_six_eyed_slayer", -- Kokushibo
                    "awakened_pale_demon_lord", -- Muzan (Boss)
                    
                    -- Candy Island
                    "genie_commander", -- Daifuku
                    "candy_master", -- Perospero
                    "biscuit_warrior", -- Cracker
                    "juice_queen", -- Smoothie
                    "mochi_emperor", -- Katakuri
                    "soul_queen", -- Big Mom (Boss)
                    
                    -- Solo City
                    "light_saintess", -- Cha Hae-In
                    "the_goliath", -- Thomas Andre
                    "shadow_bear", -- Tank
                    "shadow_commander", -- Igris
                    "shadow_ant", -- Beru
                    "awakened_shadow_monarch" -- Sung Jinwoo (Boss)
                }
                
                while AutoFarmConfig.AutoFarmAllEnemies do
                    local currentEnemy = allEnemiesInOrder[enemyIndex]
                    
                    -- Prüfen, ob wir in einem Kampf sind
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Prüfen, ob der aktuelle Gegner auf Cooldown ist
                        local currentTime = os.time()
                        if not AutoFarmConfig.EnemyCooldowns[currentEnemy] or AutoFarmConfig.EnemyCooldowns[currentEnemy] <= currentTime then
                            -- Versuchen, den Kampf zu starten
                            Utilities.StartNextBattle(currentEnemy)
                            
                            -- Wenn der Kampf nicht gestartet werden konnte, zum nächsten Gegner wechseln
                            if not Utilities.IsInBattle() then
                                enemyIndex = (enemyIndex % #allEnemiesInOrder) + 1
                            end
                        else
                            -- Gegner ist auf Cooldown, zum nächsten wechseln
                            enemyIndex = (enemyIndex % #allEnemiesInOrder) + 1
                        end
                    elseif Utilities.IsInBattle() then
                        -- Wir sind in einem Kampf, warten
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        -- Kampf ist beendet, Endbildschirm schließen
                        Utilities.DismissBattleEnd()
                        
                        -- Nach dem Schließen des Endbildschirms den Gegner als besiegt markieren
                        if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(currentEnemy)
                            
                            -- Move to next enemy for next iteration
                            enemyIndex = (enemyIndex % #allEnemiesInOrder) + 1
                        end
                    end
                    
                    -- Kurz warten vor der nächsten Überprüfung
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Farm", "Stopped auto farming all enemies in order", "stop_circle")
            
            if AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder then
                AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder:Disconnect()
                AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder = nil
            end
        end
    end
}, "AutoFarmAllEnemiesInOrderToggle")

-- Towers Tab
TabTowers:CreateSection("Battle Tower")

-- Battle Tower level display
local battle_tower_level = TabTowers:CreateLabel({
    Text = "Current Battle Tower Level: " .. Utilities.GetBattleTowerLevel(),
    Style = 1
})

-- Update Battle Tower level periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            battle_tower_level:Set({
                Text = "Current Battle Tower Level: " .. Utilities.GetBattleTowerLevel()
            })
        end
    end
end)

-- Tower Level Config
local TowerConfig = {
    BattleTowerLevel = 1,
    AutoContinuousLevel = false,
    AutoHighestLevel = false,
    Connections = {}
}

-- Battle Tower Level Dropdown instead of Input
local battle_tower_dropdown = TabTowers:CreateDropdown({
    Name = "Select Battle Tower Level",
    Description = "Choose a Tower Level (1-100)",
    Options = {"1", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50", 
               "55", "60", "65", "70", "75", "80", "85", "90", "95", "100"},
    CurrentOption = {"1"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        local level = tonumber(Option[1])
        if level then
            TowerConfig.BattleTowerLevel = level
        end
    end
}, "BattleTowerLevelDropdown")

-- Button to start the selected level
TabTowers:CreateButton({
    Name = "Start Battle Tower Level Once",
    Description = "Start the selected Battle Tower level",
    Callback = function()
        local level = TowerConfig.BattleTowerLevel
        
        if level and level >= 1 and level <= 100 then
            local args = {
                [1] = level
            }
            
            local success, result = pcall(function()
                local replicatedStorage = game:GetService("ReplicatedStorage")
                local childkQR = Utilities.SafeWaitForChild(replicatedStorage, "kQR", 5)
                if not childkQR then
                    Utilities.Notify("Fehler", "Konnte kQR in ReplicatedStorage nicht finden", "error")
                    return false
                end
                
                local towerRemote = Utilities.SafeWaitForChild(childkQR, "1457e535-9d02-4014-9883-7618f41bed84", 3)
                if not towerRemote then
                    Utilities.Notify("Fehler", "Konnte Tower-Remote in kQR nicht finden", "error")
                    return false
                end
                
                towerRemote:FireServer(unpack(args))
                return true
            end)
            
            if success and result then
                Utilities.Notify("Battle Tower", "Battle Tower started at level " .. level, "castle")
            else
                Utilities.Notify("Fehler", "Battle Tower konnte nicht gestartet werden", "error")
            end
        else
            Utilities.Notify("Fehler", "Bitte wähle ein Level zwischen 1 und 100", "error")
        end
    end
})

-- Toggle for continuous level
local continuous_tower_toggle = TabTowers:CreateToggle({
    Name = "Auto Continuous Battle Tower",
    Description = "Continuously starts the selected Battle Tower level",
    CurrentValue = false,
    Callback = function(Value)
        TowerConfig.AutoContinuousLevel = Value
        
        if Value then
            -- Activate auto continuous level
            Utilities.Notify("Battle Tower", "Auto Continuous Battle Tower activated for level " .. TowerConfig.BattleTowerLevel, "castle")
            
            -- Remove previous connections
            if TowerConfig.Connections.AutoContinuous then
                TowerConfig.Connections.AutoContinuous:Disconnect()
            end
            
            -- Create new auto continuous loop
            TowerConfig.Connections.AutoContinuous = spawn(function()
                while TowerConfig.AutoContinuousLevel do
                    -- Only start Battle Tower if we're not in a battle
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local args = {
                            [1] = TowerConfig.BattleTowerLevel
                        }
                        
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("1457e535-9d02-4014-9883-7618f41bed84"):FireServer(unpack(args))
                        end)
                        
                        Utilities.DebugPrint("Auto Continuous Battle Tower - Level " .. TowerConfig.BattleTowerLevel .. " started")
                    end
                    
                    wait(5) -- Check every 5 seconds
                end
            end)
        else
            -- Deactivate auto continuous level
            Utilities.Notify("Battle Tower", "Auto Continuous Battle Tower deactivated", "stop_circle")
            
            -- End loop
            if TowerConfig.Connections.AutoContinuous then
                TowerConfig.Connections.AutoContinuous:Disconnect()
                TowerConfig.Connections.AutoContinuous = nil
            end
        end
    end
}, "AutoContinuousTowerToggle")

-- Toggle for automatic highest level
local highest_tower_toggle = TabTowers:CreateToggle({
    Name = "Auto Highest Battle Tower",
    Description = "Automatically starts the highest possible Battle Tower level",
    CurrentValue = false,
    Callback = function(Value)
        TowerConfig.AutoHighestLevel = Value
        
        if Value then
            -- Activate auto highest level
            Utilities.Notify("Battle Tower", "Auto Highest Battle Tower activated", "castle")
            
            -- Remove previous connections
            if TowerConfig.Connections.AutoHighest then
                TowerConfig.Connections.AutoHighest:Disconnect()
            end
            
            -- Create new auto highest loop
            TowerConfig.Connections.AutoHighest = spawn(function()
                while TowerConfig.AutoHighestLevel do
                    -- Only start Battle Tower if we're not in a battle
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local currentLevel = Utilities.GetBattleTowerLevel()
                        
                        local args = {
                            [1] = currentLevel
                        }
                        
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("1457e535-9d02-4014-9883-7618f41bed84"):FireServer(unpack(args))
                        end)
                        
                        Utilities.DebugPrint("Auto Highest Battle Tower - Level " .. currentLevel .. " started")
                    end
                    
                    wait(5) -- Check every 5 seconds
                end
            end)
        else
            -- Deactivate auto highest level
            Utilities.Notify("Battle Tower", "Auto Highest Battle Tower deactivated", "stop_circle")
            
            -- End loop
            if TowerConfig.Connections.AutoHighest then
                TowerConfig.Connections.AutoHighest:Disconnect()
                TowerConfig.Connections.AutoHighest = nil
            end
        end
    end
}, "AutoHighestTowerToggle")

-- Infinite Tower Tab
TabTowers:CreateSection("Infinite Tower")

-- Infinite Tower floor display
local infinite_tower_floor = TabTowers:CreateLabel({
    Text = "Current Infinite Tower Floor: " .. Utilities.GetInfiniteTowerFloor(),
    Style = 1
})

-- Update Infinite Tower floor periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            infinite_tower_floor:Set({
                Text = "Current Infinite Tower Floor: " .. Utilities.GetInfiniteTowerFloor()
            })
        end
    end
end)

-- Infinite Tower control buttons
TabTowers:CreateButton({
    Name = "Start Infinite Tower",
    Description = "Begin the Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("60ed7d69-2cac-467c-9695-6ab3e77159b9"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Started Infinite Tower challenge", "castle")
        else
            Utilities.Notify("Error", "Failed to start Infinite Tower", "error")
        end
    end
})

TabTowers:CreateButton({
    Name = "Pause Infinite Tower",
    Description = "Pause the current Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("5bdb0ab8-610f-4823-9e57-4cd48a5c4eb8"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Paused Infinite Tower challenge", "pause")
        else
            Utilities.Notify("Error", "Failed to pause Infinite Tower", "error")
        end
    end
})

TabTowers:CreateButton({
    Name = "End Infinite Tower",
    Description = "End the current Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("23fb560d-73d0-404a-8dda-bf8088b08f0a"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Ended Infinite Tower challenge", "stop_circle")
        else
            Utilities.Notify("Error", "Failed to end Infinite Tower", "error")
        end
    end
})

-- Raids Tab
TabRaids:CreateSection("Raid Management")

TabRaids:CreateParagraph({
    Title = "Raid Information",
    Text = "Raids offer exclusive rewards and powerful units. You can start a raid against the Eternal Dragon or other powerful bosses."
})

-- Auto Raid Configuration
local RaidConfig = {
    AutoSummonEternalDragon = false,
    AutoSummonShadowDragon = false,
    Connections = {}
}

-- Auto Summon Eternal Dragon toggle
local auto_summon_dragon_toggle = TabRaids:CreateToggle({
    Name = "Auto Fight Eternal Dragon",
    Description = "Automatically fights the Eternal Dragon at regular intervals",
    CurrentValue = false,
    Callback = function(Value)
        RaidConfig.AutoSummonEternalDragon = Value
        
        if Value then
            Utilities.Notify("Auto Raid", "Started auto fighting Eternal Dragon", "security")
            
            if RaidConfig.Connections.AutoSummonDragon then
                RaidConfig.Connections.AutoSummonDragon:Disconnect()
            end
            
            RaidConfig.Connections.AutoSummonDragon = spawn(function()
                while RaidConfig.AutoSummonEternalDragon do
                    if Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        wait(1)
                    else
                        pcall(function()
                            local args = {
                                [1] = "eternal_dragon"
                            }
                            
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
                        end)
                        wait(3)
                    end
                    
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Raid", "Stopped auto fighting Eternal Dragon", "stop_circle")
            
            if RaidConfig.Connections.AutoSummonDragon then
                RaidConfig.Connections.AutoSummonDragon:Disconnect()
                RaidConfig.Connections.AutoSummonDragon = nil
            end
        end
    end
}, "AutoSummonDragonToggle")

TabRaids:CreateButton({
    Name = "Fight Eternal Dragon Once",
    Description = "Start a raid against the Eternal Dragon immediately",
    Callback = function()
        local success, result = pcall(function()
            local args = {
                [1] = "eternal_dragon"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Raid Started", "Successfully started fight with Eternal Dragon", "security")
        else
            Utilities.Notify("Error", "Failed to start raid", "error")
        end
    end
})

-- Auto Summon Shadow Dragon toggle
local auto_summon_shadow_dragon_toggle = TabRaids:CreateToggle({
    Name = "Auto Fight Shadow Dragon",
    Description = "Automatically fights the Shadow Dragon at regular intervals",
    CurrentValue = false,
    Callback = function(Value)
        RaidConfig.AutoSummonShadowDragon = Value
        
        if Value then
            Utilities.Notify("Auto Raid", "Started auto fighting Shadow Dragon", "security")
            
            if RaidConfig.Connections.AutoSummonShadowDragon then
                RaidConfig.Connections.AutoSummonShadowDragon:Disconnect()
            end
            
            RaidConfig.Connections.AutoSummonShadowDragon = spawn(function()
                while RaidConfig.AutoSummonShadowDragon do
                    if Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        wait(1)
                    else
                        pcall(function()
                            local args = {
                                [1] = "shadow_dragon"
                            }
                            
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
                        end)
                        wait(3)
                    end
                    
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Raid", "Stopped auto fighting Shadow Dragon", "stop_circle")
            
            if RaidConfig.Connections.AutoSummonShadowDragon then
                RaidConfig.Connections.AutoSummonShadowDragon:Disconnect()
                RaidConfig.Connections.AutoSummonShadowDragon = nil
            end
        end
    end
}, "AutoSummonShadowDragonToggle")

TabRaids:CreateButton({
    Name = "Fight Shadow Dragon Once",
    Description = "Start a raid against the Shadow Dragon immediately",
    Callback = function()
        local success, result = pcall(function()
            local args = {
                [1] = "shadow_dragon"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Raid Started", "Successfully started fight with Shadow Dragon", "security")
        else
            Utilities.Notify("Error", "Failed to start raid", "error")
        end
    end
})

-- Exploration Tab
TabExploration:CreateSection("Exploration Management")

-- Exploration team configuration
local exploration_difficulty = TabExploration:CreateDropdown({
    Name = "Exploration Difficulty",
    Description = "Select the difficulty level for exploration",
    Options = {"easy", "medium", "hard", "extreme", "nightmare"},
    CurrentOption = {"easy"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        -- Nothing needed here, will be used in other functions
    end
}, "ExploreDifficulty")

-- Unit selection for exploration
local exploration_units = TabExploration:CreateInput({
    Name = "Exploration Units",
    Description = "Enter 4 unit names separated by commas",
    PlaceholderText = "e.g., dark_avenger,black_swordsman,dark_avenger,dark_avenger",
    CurrentValue = "dark_avenger,black_swordsman,dark_avenger,dark_avenger",
    Numeric = false,
    MaxCharacters = 100,
    Enter = false,
    Callback = function(Text)
        -- Nothing needed here, will be used in the deploy button
    end
}, "ExploreUnits")

TabExploration:CreateButton({
    Name = "Deploy Exploration Team",
    Description = "Send your selected units on an exploration mission",
    Callback = function()
        local difficulty = exploration_difficulty.CurrentOption
        if type(difficulty) == "table" then
            difficulty = difficulty[1]
        end
        
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = difficulty,
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("4971f60f-90ff-4142-bf88-5395122136c2"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for " .. difficulty .. " exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

TabExploration:CreateDivider()

TabExploration:CreateSection("Claim Rewards")

-- Exploration Claim Config
local ExplorationConfig = {
    AutoClaimEasy = false,
    AutoClaimMedium = false,
    AutoClaimHard = false,
    AutoClaimExtreme = false,
    AutoClaimNightmare = false,
    Connections = {}
}

-- Auto Claim Easy Toggle
local auto_claim_easy_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Easy Exploration Rewards",
    Description = "Automatically claims rewards from easy difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimEasy = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Easy Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimEasy then
                ExplorationConfig.Connections.AutoClaimEasy:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimEasy = spawn(function()
                while ExplorationConfig.AutoClaimEasy do
                    local args = {
                        [1] = "easy"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    Utilities.DebugPrint("Auto Claiming Easy Exploration Rewards")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Easy Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimEasy then
                ExplorationConfig.Connections.AutoClaimEasy:Disconnect()
                ExplorationConfig.Connections.AutoClaimEasy = nil
            end
        end
    end
}, "AutoClaimEasyToggle")

-- Auto Claim Medium Toggle
local auto_claim_medium_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Medium Exploration Rewards",
    Description = "Automatically claims rewards from medium difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimMedium = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Medium Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimMedium then
                ExplorationConfig.Connections.AutoClaimMedium:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimMedium = spawn(function()
                while ExplorationConfig.AutoClaimMedium do
                    local args = {
                        [1] = "medium"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    Utilities.DebugPrint("Auto Claiming Medium Exploration Rewards")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Medium Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimMedium then
                ExplorationConfig.Connections.AutoClaimMedium:Disconnect()
                ExplorationConfig.Connections.AutoClaimMedium = nil
            end
        end
    end
}, "AutoClaimMediumToggle")

-- Auto Claim Hard Toggle
local auto_claim_hard_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Hard Exploration Rewards",
    Description = "Automatically claims rewards from hard difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimHard = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Hard Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimHard then
                ExplorationConfig.Connections.AutoClaimHard:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimHard = spawn(function()
                while ExplorationConfig.AutoClaimHard do
                    local args = {
                        [1] = "hard"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Hard Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimHard then
                ExplorationConfig.Connections.AutoClaimHard:Disconnect()
                ExplorationConfig.Connections.AutoClaimHard = nil
            end
        end
    end
}, "AutoClaimHardToggle")

-- Auto Claim Extreme Toggle
local auto_claim_extreme_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Extreme Exploration Rewards",
    Description = "Automatically claims rewards from extreme difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimExtreme = Value
        
        if Value then
            Utilities.Notify("Exploration", "Auto Claim Extreme Rewards activated", "redeem")
            
            if ExplorationConfig.Connections.AutoClaimExtreme then
                ExplorationConfig.Connections.AutoClaimExtreme:Disconnect()
            end
            
            ExplorationConfig.Connections.AutoClaimExtreme = spawn(function()
                while ExplorationConfig.AutoClaimExtreme do
                    local args = {
                        [1] = "extreme"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Exploration", "Auto Claim Extreme Rewards deactivated", "stop_circle")
            
            if ExplorationConfig.Connections.AutoClaimExtreme then
                ExplorationConfig.Connections.AutoClaimExtreme:Disconnect()
                ExplorationConfig.Connections.AutoClaimExtreme = nil
            end
        end
    end
}, "AutoClaimExtremeToggle")

-- Auto Claim Nightmare Toggle
local auto_claim_nightmare_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Nightmare Exploration Rewards",
    Description = "Automatically claims rewards from nightmare difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimNightmare = Value
        
        if Value then
            Utilities.Notify("Exploration", "Auto Claim Nightmare Rewards activated", "redeem")
            
            if ExplorationConfig.Connections.AutoClaimNightmare then
                ExplorationConfig.Connections.AutoClaimNightmare:Disconnect()
            end
            
            ExplorationConfig.Connections.AutoClaimNightmare = spawn(function()
                while ExplorationConfig.AutoClaimNightmare do
                    local args = {
                        [1] = "nightmare"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Exploration", "Auto Claim Nightmare Rewards deactivated", "stop_circle")
            
            if ExplorationConfig.Connections.AutoClaimNightmare then
                ExplorationConfig.Connections.AutoClaimNightmare:Disconnect()
                ExplorationConfig.Connections.AutoClaimNightmare = nil
            end
        end
    end
}, "AutoClaimNightmareToggle")

-- Explore Deployment for extreme
TabExploration:CreateDivider()
TabExploration:CreateSection("Extreme & Nightmare Exploration")

TabExploration:CreateButton({
    Name = "Deploy Extreme Exploration Team",
    Description = "Send your selected units on an extreme exploration mission",
    Callback = function()
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = "extreme",
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("4971f60f-90ff-4142-bf88-5395122136c2"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for extreme exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

TabExploration:CreateButton({
    Name = "Deploy Nightmare Exploration Team",
    Description = "Send your selected units on a nightmare exploration mission",
    Callback = function()
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = "nightmare",
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("4971f60f-90ff-4142-bf88-5395122136c2"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for nightmare exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

-- Shop Tab
TabShop:CreateSection("Shop Management")

TabShop:CreateParagraph({
    Title = "Shop Information",
    Text = "Purchase various items from the shop to enhance your gameplay experience."
})

-- Shop items
TabShop:CreateButton({
    Name = "Buy Luck Potion (Small)",
    Description = "Purchase a small luck potion",
    Callback = function()
        Utilities.BuyShopItem("small_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Luck Potion (Medium)",
    Description = "Purchase a medium luck potion",
    Callback = function()
        Utilities.BuyShopItem("medium_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Luck Potion (Large)",
    Description = "Purchase a large luck potion",
    Callback = function()
        Utilities.BuyShopItem("large_luck_potion", 1)
    end
})

TabShop:CreateDivider()

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Small)",
    Description = "Purchase a small cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("small_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Medium)",
    Description = "Purchase a medium cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("medium_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Large)",
    Description = "Purchase a large cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("large_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateDivider()

TabShop:CreateButton({
    Name = "Buy Raid Luck Potion",
    Description = "Purchase a raid luck potion",
    Callback = function()
        Utilities.BuyShopItem("raid_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Border Chance Potion",
    Description = "Purchase a raid border chance potion",
    Callback = function()
        Utilities.BuyShopItem("raid_border_chance_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Cooldown Potion",
    Description = "Purchase a raid cooldown potion",
    Callback = function()
        Utilities.BuyShopItem("raid_cooldown_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Boss Chance Potion",
    Description = "Purchase a raid boss chance potion",
    Callback = function()
        Utilities.BuyShopItem("raid_boss_chance_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Moon Cycle Reroll Potion",
    Description = "Purchase a raid moon cycle reroll potion",
    Callback = function()
        Utilities.BuyShopItem("raid_moon_cycle_reroll_potion", 1)
    end
})

-- Misc Tab
TabMisc:CreateSection("Miscellaneous Features")

-- BillboardGui text modification (Hide Name feature)
local NameHideConfig = {
    Enabled = false,
    OriginalTexts = {},
    OriginalColors = {}
}

-- Function to toggle name hiding
Utilities.ToggleNameHide = function(value)
    NameHideConfig.Enabled = value
    
    if value then
        -- Save original values first (only if not already saved)
        if #NameHideConfig.OriginalTexts == 0 then
            pcall(function()
                -- First TextLabel (which will be changed to "JOIN DC")
                local joinLabel = workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2]
                if joinLabel and joinLabel:IsA("TextLabel") then
                    NameHideConfig.OriginalTexts[joinLabel] = joinLabel.Text
                    NameHideConfig.OriginalColors[joinLabel] = joinLabel.TextColor3
                    
                    -- Change to "JOIN DC" in white
                    joinLabel.Text = "JOIN DC"
                    joinLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- White
                end
                
                -- Second TextLabel (which will be changed to "MYTHHUB")
                local mythLabel = workspace.rswhshj.Head.BillboardGui.Frame.TextLabel
                if mythLabel and mythLabel:IsA("TextLabel") then
                    NameHideConfig.OriginalTexts[mythLabel] = mythLabel.Text
                    NameHideConfig.OriginalColors[mythLabel] = mythLabel.TextColor3
                    
                    -- Change to "MYTHHUB" in #11189D (dark blue)
                    mythLabel.Text = "MYTHHUB"
                    mythLabel.TextColor3 = Color3.fromRGB(17, 24, 157) -- #11189D in RGB
                end
            end)
        else
            -- Apply saved changes (in case they were reverted)
            pcall(function()
                workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2].Text = "JOIN DC"
                workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2].TextColor3 = Color3.fromRGB(255, 255, 255)
                
                workspace.rswhshj.Head.BillboardGui.Frame.TextLabel.Text = "MYTHHUB"
                workspace.rswhshj.Head.BillboardGui.Frame.TextLabel.TextColor3 = Color3.fromRGB(17, 24, 157)
            end)
        end
    else
        -- Restore original values
        for label, originalText in pairs(NameHideConfig.OriginalTexts) do
            pcall(function()
                label.Text = originalText
                label.TextColor3 = NameHideConfig.OriginalColors[label]
            end)
        end
    end
end

-- Add Hide Name toggle
local hide_name_toggle = TabMisc:CreateToggle({
    Name = "Hide Name",
    Description = "Replaces the name with MYTHHUB and JOIN DC text",
    CurrentValue = false,
    Callback = function(Value)
        Utilities.ToggleNameHide(Value)
        
        if Value then
            Utilities.Notify("Name Hider", "Name hidden with custom text", "person")
        else
            Utilities.Notify("Name Hider", "Original name restored", "person")
        end
    end
}, "HideNameToggle")

-- Remove the "Enemy Cooldown Information" section and replace with a detailed cooldown display
TabMisc:CreateSection("Enemy Cooldown Information")

-- Create a function to display enemy cooldowns
local function createCooldownDisplay()
    -- Create the main paragraph for cooldowns
    local cooldownParagraph = TabMisc:CreateParagraph({
        Title = "Current Enemy Cooldowns",
        Text = "Checking cooldowns..."
    })
    
    -- Update function that will be called periodically
    local function updateCooldowns()
        local text = ""
        local currentTime = os.time()
        local hasCooldowns = false
        
        -- Check existence of EnemyCooldowns table
        if not AutoFarmConfig.EnemyCooldowns then
            AutoFarmConfig.EnemyCooldowns = {}
        end
        
        -- Boss names
        local worldBosses = {
            bijuu_beast = "Naruto Rage Mode",
            awakened_galactic_tyrant = "Frieza",
            king_of_curses = "Sukuna",
            combat_giant = "Eren",
            awakened_pale_demon_lord = "Muzan",
            soul_queen = "Big Mom",
            awakened_shadow_monarch = "Sung Jinwoo"
        }
        
        -- Regular enemy names
        local regularEnemies = {
            -- Ninja Village
            unstoppable_fist = "Rock Lee",
            copy_ninja = "Kakashi",
            awakened_dark_avenger = "Sasuke",
            awakened_promised_child = "Naruto Sage Mode",
            six_paths_of_pain = "Pain",
            
            -- Green Village
            ultimate_warrior = "Son Gohan",
            body_switcher = "Captain Ginyu",
            namekian_sage = "Piccolo",
            awakened_prideful_prince = "Vegeta",
            awakened_earth_strongest = "Goku",
            
            -- Shibuya Station
            cursed_doll = "Nobara",
            awakened_shadow_summoner = "Megumi",
            cursed_fist = "Yuji",
            rika_blessing = "Yuta",
            limitless_master = "Gojo",
            
            -- Titans City
            survey_commander = "Erwin",
            blade_warrior = "Mikasa",
            armored_giant = "Reiner",
            beast_giant = "Zeke",
            blade_captain = "Levi",
            
            -- Dimensional Fortress
            thunder_demon = "Kaigaku",
            childish_demon = "Hantengu",
            compass_demon = "Akaza",
            awakened_frost_demon = "Doma",
            awakened_six_eyed_slayer = "Kokushibo",
            
            -- Candy Island
            genie_commander = "Daifuku",
            candy_master = "Perospero",
            biscuit_warrior = "Cracker",
            juice_queen = "Smoothie",
            mochi_emperor = "Katakuri",
            
            -- Solo City
            light_saintess = "Cha Hae-In",
            the_goliath = "Thomas Andre",
            shadow_bear = "Tank",
            shadow_commander = "Igris",
            shadow_ant = "Beru"
        }
        
        -- Add world bosses to cooldown display
        text = text .. "--- World Bosses ---\n"
        for enemyCode, bossName in pairs(worldBosses) do
            local cooldownTime = AutoFarmConfig.EnemyCooldowns[enemyCode]
            if cooldownTime and cooldownTime > currentTime then
                local remainingTime = cooldownTime - currentTime
                local minutes = math.floor(remainingTime / 60)
                local seconds = remainingTime % 60
                text = text .. bossName .. ": " .. string.format("%02d:%02d", minutes, seconds) .. "\n"
                hasCooldowns = true
            else
                text = text .. bossName .. ": Ready\n"
            end
        end
        
        -- Add regular enemies to cooldown display
        text = text .. "\n--- Regular Enemies ---\n"
        for enemyCode, enemyName in pairs(regularEnemies) do
            local cooldownTime = AutoFarmConfig.EnemyCooldowns[enemyCode]
            if cooldownTime and cooldownTime > currentTime then
                local remainingTime = cooldownTime - currentTime
                local minutes = math.floor(remainingTime / 60)
                local seconds = remainingTime % 60
                text = text .. enemyName .. ": " .. string.format("%02d:%02d", minutes, seconds) .. "\n"
                hasCooldowns = true
            end
        end
        
        if not hasCooldowns then
            text = text .. "No enemies on cooldown."
        end
        
        -- Update the paragraph text
        cooldownParagraph:Set({
            Text = text
        })
    end
    
    -- Initial update
    updateCooldowns()
    
    -- Start a timer to update the cooldowns every second
    spawn(function()
        while wait(1) do
            updateCooldowns()
        end
    end)
end

-- Create the cooldown display
createCooldownDisplay()

TabMisc:CreateDivider()

-- Create a section for Performance Optimization in the Misc Tab
TabMisc:CreateSection("Performance Optimization")

-- FPS Boost
TabMisc:CreateToggle({
    Name = "FPS Boost",
    Description = "Reduces graphics quality to increase performance",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            -- Enable FPS Boost
            pcall(function()
                -- Reduce graphics quality
                local lighting = game:GetService("Lighting")
                lighting.GlobalShadows = false
                lighting.ShadowSoftness = 0
                lighting.Technology = Enum.Technology.Compatibility
                
                -- Disable unnecessary rendering
                settings().Rendering.QualityLevel = 1
                
                -- Reduce terrain quality
                workspace.Terrain.WaterWaveSize = 0
                workspace.Terrain.WaterWaveSpeed = 0
                workspace.Terrain.WaterReflectance = 0
                workspace.Terrain.WaterTransparency = 0
                
                -- Disable textures and effects
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Trail") or v:IsA("Smoke") or v:IsA("Fire") then
                        v.Enabled = false
                    end
                end
                
                Utilities.Notify("Performance", "FPS Boost enabled", "speed")
            end)
        else
            -- Restore default settings
            pcall(function()
                -- Reset graphics quality
                local lighting = game:GetService("Lighting")
                lighting.GlobalShadows = true
                lighting.ShadowSoftness = 0.5
                lighting.Technology = Enum.Technology.Future
                
                -- Reset rendering
                settings().Rendering.QualityLevel = 7
                
                -- Reset terrain
                workspace.Terrain.WaterWaveSize = 0.3
                workspace.Terrain.WaterWaveSpeed = 10
                workspace.Terrain.WaterReflectance = 1
                workspace.Terrain.WaterTransparency = 0.6
                
                Utilities.Notify("Performance", "FPS Boost disabled", "speed")
            end)
        end
    end
})

-- Reduce Particles
TabMisc:CreateToggle({
    Name = "Reduce Particles",
    Description = "Disables particle effects for better performance",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            -- Disable particles
            pcall(function()
                for _, v in pairs(game:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Beam") or v:IsA("Trail") or v:IsA("Smoke") or v:IsA("Fire") then
                        v.Enabled = false
                    end
                end
                
                -- Connect to DescendantAdded to disable new particles
                if not Utilities.ParticleConnection then
                    Utilities.ParticleConnection = game.DescendantAdded:Connect(function(descendant)
                        if descendant:IsA("ParticleEmitter") or descendant:IsA("Beam") or descendant:IsA("Trail") or descendant:IsA("Smoke") or descendant:IsA("Fire") then
                            descendant.Enabled = false
                        end
                    end)
                end
                
                Utilities.Notify("Performance", "Particles reduced", "blur_off")
            end)
        else
            -- Enable particles again
            pcall(function()
                if Utilities.ParticleConnection then
                    Utilities.ParticleConnection:Disconnect()
                    Utilities.ParticleConnection = nil
                end
                
                Utilities.Notify("Performance", "Particles enabled", "blur_on")
            end)
        end
    end
})

-- Remove Shadows
TabMisc:CreateToggle({
    Name = "Remove Shadows",
    Description = "Disables shadows for better performance",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            pcall(function()
                game:GetService("Lighting").GlobalShadows = false
                game:GetService("Lighting").ShadowSoftness = 0
                Utilities.Notify("Performance", "Shadows disabled", "visibility_off")
            end)
        else
            pcall(function()
                game:GetService("Lighting").GlobalShadows = true
                game:GetService("Lighting").ShadowSoftness = 0.5
                Utilities.Notify("Performance", "Shadows enabled", "visibility")
            end)
        end
    end
})

TabMisc:CreateDivider()
TabMisc:CreateSection("Auto Stats Upgrade")

-- Auto Stats Configuration
local AutoStatsConfig = {
    AutoUpgradeLuck = false,
    AutoUpgradeCooldownReduction = false,
    AutoUpgradePotionDuration = false,
    AutoUpgradeBorderChance = false,
    AutoUpgradeBossChance = false,
    Connections = {}
}

-- Auto Upgrade Luck toggle
local auto_upgrade_luck_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Luck",
    Description = "Automatically upgrades your luck stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeLuck = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Luck stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeLuck then
                AutoStatsConfig.Connections.AutoUpgradeLuck:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeLuck = spawn(function()
                while AutoStatsConfig.AutoUpgradeLuck do
                    Utilities.UpgradeStat("LUCK")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Luck stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeLuck then
                AutoStatsConfig.Connections.AutoUpgradeLuck:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeLuck = nil
            end
        end
    end
}, "AutoUpgradeLuckToggle")

-- Auto Upgrade Cooldown Reduction toggle
local auto_upgrade_cooldown_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Cooldown Reduction",
    Description = "Automatically upgrades your cooldown reduction stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeCooldownReduction = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Cooldown Reduction stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeCooldownReduction then
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeCooldownReduction = spawn(function()
                while AutoStatsConfig.AutoUpgradeCooldownReduction do
                    Utilities.UpgradeStat("COOLDOWN_REDUCTION")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Cooldown Reduction stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeCooldownReduction then
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction = nil
            end
        end
    end
}, "AutoUpgradeCooldownToggle")

-- Auto Upgrade Potion Duration toggle
local auto_upgrade_potion_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Potion Duration",
    Description = "Automatically upgrades your potion duration stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradePotionDuration = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Potion Duration stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradePotionDuration then
                AutoStatsConfig.Connections.AutoUpgradePotionDuration:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradePotionDuration = spawn(function()
                while AutoStatsConfig.AutoUpgradePotionDuration do
                    Utilities.UpgradeStat("POTION_DURATION")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Potion Duration stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradePotionDuration then
                AutoStatsConfig.Connections.AutoUpgradePotionDuration:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradePotionDuration = nil
            end
        end
    end
}, "AutoUpgradePotionToggle")

-- Auto Upgrade Border Chance toggle
local auto_upgrade_border_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Border Chance",
    Description = "Automatically upgrades your border chance stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeBorderChance = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Border Chance stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeBorderChance then
                AutoStatsConfig.Connections.AutoUpgradeBorderChance:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeBorderChance = spawn(function()
                while AutoStatsConfig.AutoUpgradeBorderChance do
                    Utilities.UpgradeStat("BORDER_CHANCE")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Border Chance stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeBorderChance then
                AutoStatsConfig.Connections.AutoUpgradeBorderChance:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeBorderChance = nil
            end
        end
    end
}, "AutoUpgradeBorderToggle")

-- Auto Upgrade Boss Chance toggle
local auto_upgrade_boss_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Boss Chance",
    Description = "Automatically upgrades your boss chance stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeBossChance = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Boss Chance stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeBossChance then
                AutoStatsConfig.Connections.AutoUpgradeBossChance:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeBossChance = spawn(function()
                while AutoStatsConfig.AutoUpgradeBossChance do
                    Utilities.UpgradeStat("BOSS_CHANCE")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Boss Chance stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeBossChance then
                AutoStatsConfig.Connections.AutoUpgradeBossChance:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeBossChance = nil
            end
        end
    end
}, "AutoUpgradeBossToggle")

-- Theme and Config sections
TabSettings:BuildThemeSection()
TabSettings:BuildConfigSection()

-- Enable autoload config
Luna:LoadAutoloadConfig()

-- Remove Debug Console creation
Utilities.CreateDebugConsole = nil

-- Remove Debug Console toggle from settings
TabSettings:CreateButton({
    Name = "Toggle Debug Console",
    Description = "Show or hide the debug console",
    Callback = function()
        -- Do nothing, debug console removed
    end
})

-- Add global battle end detection loop
spawn(function()
    while true do
        wait(1)
        
        if Utilities.IsBattleEnded() then
            Utilities.DismissBattleEnd()
            
            if not AutoFarmConfig.Enabled and not AutoFarmConfig.AutoFarmAllWorldBosses and not AutoFarmConfig.AutoFarmAllEnemiesInSelectedWorlds then
                local possibleLastEnemy = nil
                
                if game.PlaceId == 9230754391 then
                    possibleLastEnemy = "eternal_dragon"
                else
                    possibleLastEnemy = AutoFarmConfig.CurrentEnemy
                end
                
                if possibleLastEnemy then
                    Utilities.MarkEnemyDefeated(possibleLastEnemy)
                end
            end
        end
    end
end)

-- Enable autoload config
Luna:LoadAutoloadConfig()

-- Add Anti-AFK function
spawn(function()
    local VirtualUser = game:GetService("VirtualUser")
    
    Utilities.GetLocalPlayer().Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
end)

-- Function to upgrade stats
Utilities.UpgradeStat = function(statType)
    if not statType then return end
    
    local args = {
        [1] = statType
    }
    
    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("a0d1432a-262d-4b0a-9173-ee8b1dcfb69c"):FireServer(unpack(args))
    end)
end

-- Function to buy shop items
Utilities.BuyShopItem = function(itemName, amount)
    if not itemName or not amount then return end
    
    local args = {
        [1] = itemName,
        [2] = amount
    }
    
    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("41ccb1a6-1009-4e2f-924e-1b71f8020e9b"):FireServer(unpack(args))
    end)
end

--[[
    ÄNDERUNGSPROTOKOLL - MAI 2025
    
    - Remote-Pfade von "3aA" auf "kQR" aktualisiert
    - Remote-IDs für alle Funktionen aktualisiert:
      * SummonEnemy: 8a63919a-217b-436a-9cfa-4b472d213bbb
      * Battle Tower: 1457e535-9d02-4014-9883-7618f41bed84
      * Infinite Tower (Start): 60ed7d69-2cac-467c-9695-6ab3e77159b9
      * Infinite Tower (Ende): 23fb560d-73d0-404a-8dda-bf8088b08f0a
      * Infinite Tower (Pause): 5bdb0ab8-610f-4823-9e57-4cd48a5c4eb8
      * Exploration (Deploy): 4971f60f-90ff-4142-bf88-5395122136c2
      * Exploration (Claim): e82eeec1-ca38-4f7b-bf14-4b85df674c7b
      * Shop: 41ccb1a6-1009-4e2f-924e-1b71f8020e9b
      * Stats Upgrade: a0d1432a-262d-4b0a-9173-ee8b1dcfb69c
    - Auto-Farm, Raid und Infinite Tower Funktionen angepasst
    - Unterstützung für neue Enemy IDs und Endpoints hinzugefügt
]]

TabMisc:CreateDivider()
TabMisc:CreateSection("Auto-Execute")

-- Auto-Execute nach Teleport
TabMisc:CreateToggle({
    Name = "Auto-Execute nach Teleport",
    Description = "Führt das Skript automatisch nach einem Teleport im Spiel erneut aus",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            -- Code zum Speichern des Skripts für Auto-Execute
            local queueOnTeleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
            
            if queueOnTeleport then
                -- Das aktuelle Skript für die Ausführung nach dem Teleport in die Warteschlange stellen
                local scriptURL = "https://raw.githubusercontent.com/MythTeam/AnimeCardClash/main/RobloxScriptHubMythHub.lua"
                
                queueOnTeleport([[
                    -- Warte, bis das Spiel geladen ist
                    repeat wait() until game:IsLoaded()
                    wait(3)
                    
                    -- Führe das Skript aus
                    loadstring(game:HttpGet("]] .. scriptURL .. [[", true))()
                ]])
                
                -- Verbindung zum TeleportService herstellen
                local teleportService = game:GetService("TeleportService")
                local connection
                
                connection = teleportService.TeleportInitFailed:Connect(function(player, teleportResult, errorMessage)
                    if player == Utilities.GetLocalPlayer() then
                        Utilities.Notify("Auto-Execute", "Fehler beim Teleport: " .. errorMessage, "error")
                        -- Versuche es erneut
                        queueOnTeleport([[
                            -- Warte, bis das Spiel geladen ist
                            repeat wait() until game:IsLoaded()
                            wait(5)
                            
                            -- Führe das Skript aus
                            loadstring(game:HttpGet("]] .. scriptURL .. [[", true))()
                        ]])
                    end
                end)
                
                spawn(function()
                    -- Prüfe regelmäßig, ob wir uns noch im selben Spiel befinden
                    local currentGameId = game.PlaceId
                    while true do
                        wait(5)
                        if game.PlaceId ~= currentGameId then
                            -- Wir wurden bereits teleportiert, also die Verbindung trennen
                            if connection then
                                connection:Disconnect()
                                connection = nil
                            end
                            break
                        end
                    end
                end)
                
                Utilities.Notify("Auto-Execute", "Nach dem nächsten Teleport wird das Skript automatisch ausgeführt", "sync")
            else
                Utilities.Notify("Fehler", "Dein Executor unterstützt diese Funktion nicht", "error")
                return false
            end
        else
            -- Auto-Execute deaktivieren
            local queueOnTeleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
            
            if queueOnTeleport then
                queueOnTeleport("")
                Utilities.Notify("Auto-Execute", "Auto-Execute nach Teleport deaktiviert", "stop_circle")
            end
        end
    end
}, "AutoExecuteToggle")

-- Auto-Reconnect Funktion (speichert Konfiguration)
TabMisc:CreateToggle({
    Name = "Auto-Reconnect",
    Description = "Speichert die aktuelle Konfiguration und führt das Skript nach einem Neustart des Spiels aus",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            -- Aktuellen Executor prüfen
            local saveInstance = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
            
            if saveInstance then
                -- Aktuelle Konfiguration speichern
                local config = {}
                config.AutoFarm = AutoFarmConfig.Enabled
                config.CurrentEnemy = AutoFarmConfig.CurrentEnemy
                config.AutoCollect = AutoFarmConfig.AutoCollect
                config.AutoMerge = AutoFarmConfig.AutoMerge
                config.AutoFarmWorldBosses = AutoFarmConfig.AutoFarmAllWorldBosses
                config.TowerLevel = TowerConfig.BattleTowerLevel
                config.AutoContinuousTower = TowerConfig.AutoContinuousLevel
                config.AutoHighestTower = TowerConfig.AutoHighestLevel
                config.AutoSummonEternalDragon = RaidConfig.AutoSummonEternalDragon
                config.AutoSummonShadowDragon = RaidConfig.AutoSummonShadowDragon
                config.AutoClaimEasy = ExplorationConfig.AutoClaimEasy
                config.AutoClaimMedium = ExplorationConfig.AutoClaimMedium
                config.AutoClaimHard = ExplorationConfig.AutoClaimHard
                config.AutoClaimExtreme = ExplorationConfig.AutoClaimExtreme
                config.AutoClaimNightmare = ExplorationConfig.AutoClaimNightmare
                
                -- Als Datei speichern
                if writefile then
                    writefile("MythHubConfig.json", game:GetService("HttpService"):JSONEncode(config))
                end
                
                -- Auto-Execute mit Konfiguration
                local scriptURL = "https://raw.githubusercontent.com/MythTeam/AnimeCardClash/main/RobloxScriptHubMythHub.lua"
                
                saveInstance([[
                    -- Warte, bis das Spiel geladen ist
                    repeat wait() until game:IsLoaded()
                    wait(5)
                    
                    -- Skript laden
                    loadstring(game:HttpGet("]] .. scriptURL .. [[", true))()
                    
                    -- Konfiguration wiederherstellen
                    wait(3)
                    if readfile and isfile and isfile("MythHubConfig.json") then
                        local config = game:GetService("HttpService"):JSONDecode(readfile("MythHubConfig.json"))
                        -- Hier wird die Skriptkonfiguration automatisch geladen
                        -- Die Funktionen werden im nächsten Update implementiert
                    end
                ]])
                
                -- Persistent Auto-Reconnect (zwischen Spielsitzungen)
                -- Dieses Feature erfordert einen Executor, der Dateien zwischen Sitzungen speichern kann
                if isfile and writefile and readfile then
                    writefile("MythHubAutoStart.lua", [[
                        -- Warte, bis das Spiel geladen ist
                        repeat wait() until game:IsLoaded()
                        wait(5)
                        
                        -- Prüfe, ob wir im richtigen Spiel sind
                        if game.PlaceId == 16018202702 or game.PlaceId == 9230754391 then -- Anime Card Clash IDs
                            -- Skript laden
                            loadstring(game:HttpGet("]] .. scriptURL .. [[", true))()
                            
                            -- Konfiguration wiederherstellen
                            wait(3)
                            if isfile("MythHubConfig.json") then
                                -- Konfiguration wird automatisch geladen
                            end
                        end
                    ]])
                    
                    Utilities.Notify("Auto-Reconnect", "Persistente Auto-Start-Datei erstellt", "sync")
                end
                
                Utilities.Notify("Auto-Reconnect", "Konfiguration gespeichert und Auto-Execute aktiviert", "sync")
            else
                Utilities.Notify("Fehler", "Dein Executor unterstützt diese Funktion nicht", "error")
                return false
            end
        else
            -- Auto-Reconnect deaktivieren
            if isfile and isfile("MythHubConfig.json") then
                delfile("MythHubConfig.json")
            end
            
            if isfile and isfile("MythHubAutoStart.lua") then
                delfile("MythHubAutoStart.lua")
            end
            
            local queueOnTeleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
            if queueOnTeleport then
                queueOnTeleport("")
                Utilities.Notify("Auto-Reconnect", "Auto-Reconnect deaktiviert", "stop_circle")
            end
        end
    end
}, "AutoReconnectToggle")

TabMisc:CreateDivider()
TabMisc:CreateSection("Webhook Benachrichtigungen")

-- Webhook Konfiguration
local WebhookConfig = {
    Enabled = false,
    URL = "",
    NotifyRareDrops = true,
    NotifyBossFights = true,
    NotifyTowerCompletion = true,
    NotifyRaidCompletion = true,
    MinimumRarity = "legendary", -- common, rare, epic, legendary, mythic
    Connections = {}
}

-- Webhook URL Input
local webhook_url_input = TabMisc:CreateInput({
    Name = "Discord Webhook URL",
    Description = "Gib die Discord Webhook URL ein",
    PlaceholderText = "https://discord.com/api/webhooks/...",
    CurrentValue = "",
    Numeric = false,
    MaxCharacters = 500,
    Enter = true,
    Callback = function(Text)
        WebhookConfig.URL = Text
        Utilities.Notify("Webhook", "Webhook URL gespeichert", "webhook")
    end
}, "WebhookURL")

-- Webhook Toggle
local webhook_toggle = TabMisc:CreateToggle({
    Name = "Webhook Benachrichtigungen aktivieren",
    Description = "Aktiviert Benachrichtigungen über den konfigurierten Webhook",
    CurrentValue = false,
    Callback = function(Value)
        WebhookConfig.Enabled = Value
        
        if Value then
            if WebhookConfig.URL == "" then
                Utilities.Notify("Webhook", "Bitte zuerst eine Webhook URL eingeben", "error")
                return false
            end
            
            -- Test Webhook
            Utilities.SendWebhook({
                username = "MythHub",
                embeds = {{
                    title = "Webhook Test",
                    description = "Die Webhook-Verbindung wurde erfolgreich hergestellt!",
                    color = 5814783, -- Blau in Dezimal
                    fields = {{
                        name = "Spieler",
                        value = Utilities.GetLocalPlayer().Name,
                        inline = true
                    }, {
                        name = "Server ID",
                        value = game.JobId,
                        inline = true
                    }},
                    footer = {
                        text = "MythHub Premium - Anime Card Clash"
                    },
                    timestamp = DateTime.now():ToIsoDate()
                }}
            })
            
            Utilities.Notify("Webhook", "Webhook Benachrichtigungen aktiviert", "webhook")
        else
            Utilities.Notify("Webhook", "Webhook Benachrichtigungen deaktiviert", "webhook")
        end
    end
}, "WebhookToggle")

-- Benachrichtigungsoptionen
TabMisc:CreateToggle({
    Name = "Bei seltenen Drops benachrichtigen",
    Description = "Sendet eine Benachrichtigung, wenn ein seltenes Item gedroppt wird",
    CurrentValue = true,
    Callback = function(Value)
        WebhookConfig.NotifyRareDrops = Value
    end
}, "WebhookRareDrops")

TabMisc:CreateToggle({
    Name = "Bei Boss-Kämpfen benachrichtigen",
    Description = "Sendet eine Benachrichtigung, wenn ein Boss-Kampf beginnt",
    CurrentValue = true,
    Callback = function(Value)
        WebhookConfig.NotifyBossFights = Value
    end
}, "WebhookBossFights")

TabMisc:CreateToggle({
    Name = "Bei Tower-Abschluss benachrichtigen",
    Description = "Sendet eine Benachrichtigung, wenn ein Tower abgeschlossen wurde",
    CurrentValue = true,
    Callback = function(Value)
        WebhookConfig.NotifyTowerCompletion = Value
    end
}, "WebhookTowerCompletion")

TabMisc:CreateToggle({
    Name = "Bei Raid-Abschluss benachrichtigen",
    Description = "Sendet eine Benachrichtigung, wenn ein Raid abgeschlossen wurde",
    CurrentValue = true,
    Callback = function(Value)
        WebhookConfig.NotifyRaidCompletion = Value
    end
}, "WebhookRaidCompletion")

-- Rarity Dropdown
local rarity_dropdown = TabMisc:CreateDropdown({
    Name = "Minimale Drop-Seltenheit",
    Description = "Bei welcher Seltenheit soll benachrichtigt werden",
    Options = {"common", "rare", "epic", "legendary", "mythic"},
    CurrentOption = {"legendary"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        WebhookConfig.MinimumRarity = Option[1]
    end
}, "WebhookRarity")

-- Funktion zum Senden von Webhook-Benachrichtigungen
Utilities.SendWebhook = function(data)
    if not WebhookConfig.Enabled or WebhookConfig.URL == "" then
        return
    end
    
    local success, result = pcall(function()
        local HttpService = game:GetService("HttpService")
        local jsonData = HttpService:JSONEncode(data)
        
        -- HTTP-Anfrage über Executor senden
        local httpRequest = (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or request
        
        if httpRequest then
            httpRequest({
                Url = WebhookConfig.URL,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonData
            })
            return true
        else
            return false
        end
    end)
    
    if not success or not result then
        warn("Webhook-Anfrage fehlgeschlagen: " .. tostring(result))
    end
end

-- Boss-Kampf erkennung für Webhook
spawn(function()
    while wait(1) do
        if WebhookConfig.Enabled and WebhookConfig.NotifyBossFights then
            if Utilities.IsInBattle() then
                -- Prüfe, ob wir gegen einen Boss kämpfen
                local localPlayer = Utilities.GetLocalPlayer()
                if localPlayer and localPlayer.PlayerGui then
                    local battleGui = localPlayer.PlayerGui:FindFirstChild("battle")
                    if battleGui then
                        -- Versuche, den Namen des Gegners zu ermitteln
                        local enemyName = "Unbekannter Boss"
                        pcall(function()
                            -- Der genaue Pfad zum Namen des Gegners kann variieren
                            -- Je nach UI-Struktur im Spiel
                            local nameLabel = battleGui:FindFirstChild("EnemyName", true)
                            if nameLabel and nameLabel:IsA("TextLabel") then
                                enemyName = nameLabel.Text
                            end
                        end)
                        
                        -- Prüfe, ob es sich um einen Boss handelt
                        local isBoss = false
                        for _, bossName in pairs(AutoFarmConfig.WorldBosses) do
                            if string.find(enemyName:lower(), bossName:lower()) then
                                isBoss = true
                                break
                            end
                        end
                        
                        if isBoss then
                            -- Sende Webhook-Benachrichtigung für Boss-Kampf
                            Utilities.SendWebhook({
                                username = "MythHub",
                                embeds = {{
                                    title = "Boss-Kampf Begonnen",
                                    description = "Ein Boss-Kampf hat begonnen!",
                                    color = 15158332, -- Rot in Dezimal
                                    fields = {{
                                        name = "Boss",
                                        value = enemyName,
                                        inline = true
                                    }, {
                                        name = "Spieler",
                                        value = localPlayer.Name,
                                        inline = true
                                    }},
                                    footer = {
                                        text = "MythHub Premium - Anime Card Clash"
                                    },
                                    timestamp = DateTime.now():ToIsoDate()
                                }}
                            })
                            
                            -- Warte eine Weile, um wiederholte Benachrichtigungen zu vermeiden
                            wait(30)
                        end
                    end
                end
            end
        end
    end
end)

-- Item Drop Erkennung für Webhook
local function connectItemDrops()
    if WebhookConfig.Connections.ItemDrops then
        WebhookConfig.Connections.ItemDrops:Disconnect()
    end
    
    WebhookConfig.Connections.ItemDrops = workspace.ChildAdded:Connect(function(child)
        if WebhookConfig.Enabled and WebhookConfig.NotifyRareDrops then
            -- Warte kurz, bis das Objekt vollständig geladen ist
            wait(0.5)
            
            -- Prüfe, ob es sich um ein gedroptes Item handelt
            if child:IsA("Model") and child:FindFirstChild("Rarity") then
                local rarity = child.Rarity.Value
                local itemName = child.Name
                
                -- Prüfe Rarity gegen Mindestrarity
                local rarityValues = {
                    common = 1,
                    rare = 2,
                    epic = 3,
                    legendary = 4,
                    mythic = 5
                }
                
                local minRarityValue = rarityValues[WebhookConfig.MinimumRarity] or 4
                local itemRarityValue = rarityValues[rarity:lower()] or 1
                
                if itemRarityValue >= minRarityValue then
                    -- Sende Webhook-Benachrichtigung für seltenen Drop
                    Utilities.SendWebhook({
                        username = "MythHub",
                        embeds = {{
                            title = "Seltenes Item gefunden!",
                            description = "Ein seltenes Item wurde gedroppt!",
                            color = 8311585, -- Lila in Dezimal
                            fields = {{
                                name = "Item",
                                value = itemName,
                                inline = true
                            }, {
                                name = "Seltenheit",
                                value = rarity,
                                inline = true
                            }, {
                                name = "Spieler",
                                value = Utilities.GetLocalPlayer().Name,
                                inline = true
                            }},
                            footer = {
                                text = "MythHub Premium - Anime Card Clash"
                            },
                            timestamp = DateTime.now():ToIsoDate()
                        }}
                    })
                end
            end
        end
    end)
end

-- Tower Completion Erkennung für Webhook
local function checkTowerCompletion()
    if WebhookConfig.Enabled and WebhookConfig.NotifyTowerCompletion then
        -- Prüfe Battle Tower
        local battleTowerLevel = Utilities.GetBattleTowerLevel()
        local infiniteTowerFloor = Utilities.GetInfiniteTowerFloor()
        
        -- Speichern der aktuellen Level/Floors
        if not WebhookConfig.LastBattleTowerLevel then
            WebhookConfig.LastBattleTowerLevel = battleTowerLevel
        end
        
        if not WebhookConfig.LastInfiniteTowerFloor then
            WebhookConfig.LastInfiniteTowerFloor = infiniteTowerFloor
        end
        
        -- Überprüfen auf Änderungen
        if battleTowerLevel > WebhookConfig.LastBattleTowerLevel then
            -- Battle Tower Level abgeschlossen
            Utilities.SendWebhook({
                username = "MythHub",
                embeds = {{
                    title = "Battle Tower abgeschlossen!",
                    description = "Ein Battle Tower Level wurde abgeschlossen!",
                    color = 4037965, -- Grün in Dezimal
                    fields = {{
                        name = "Level",
                        value = tostring(WebhookConfig.LastBattleTowerLevel),
                        inline = true
                    }, {
                        name = "Neues Level",
                        value = tostring(battleTowerLevel),
                        inline = true
                    }, {
                        name = "Spieler",
                        value = Utilities.GetLocalPlayer().Name,
                        inline = true
                    }},
                    footer = {
                        text = "MythHub Premium - Anime Card Clash"
                    },
                    timestamp = DateTime.now():ToIsoDate()
                }}
            })
            
            WebhookConfig.LastBattleTowerLevel = battleTowerLevel
        end
        
        if infiniteTowerFloor > WebhookConfig.LastInfiniteTowerFloor then
            -- Infinite Tower Floor abgeschlossen
            Utilities.SendWebhook({
                username = "MythHub",
                embeds = {{
                    title = "Infinite Tower abgeschlossen!",
                    description = "Ein Infinite Tower Floor wurde abgeschlossen!",
                    color = 4037965, -- Grün in Dezimal
                    fields = {{
                        name = "Floor",
                        value = tostring(WebhookConfig.LastInfiniteTowerFloor),
                        inline = true
                    }, {
                        name = "Neuer Floor",
                        value = tostring(infiniteTowerFloor),
                        inline = true
                    }, {
                        name = "Spieler",
                        value = Utilities.GetLocalPlayer().Name,
                        inline = true
                    }},
                    footer = {
                        text = "MythHub Premium - Anime Card Clash"
                    },
                    timestamp = DateTime.now():ToIsoDate()
                }}
            })
            
            WebhookConfig.LastInfiniteTowerFloor = infiniteTowerFloor
        end
    end
end

-- Tower Completion Checker starten
spawn(function()
    while wait(30) do -- Alle 30 Sekunden prüfen
        pcall(checkTowerCompletion)
    end
end)

-- Raid Completion Erkennung
local function connectRaidCompletion()
    if WebhookConfig.Connections.RaidCompletion then
        WebhookConfig.Connections.RaidCompletion:Disconnect()
    end
    
    WebhookConfig.Connections.RaidCompletion = game:GetService("Players").LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
        if WebhookConfig.Enabled and WebhookConfig.NotifyRaidCompletion then
            if child.Name == "battle-end" then
                wait(1) -- Kurz warten, bis GUI vollständig geladen ist
                
                -- Versuche zu ermitteln, ob es ein Raid war
                local wasRaid = false
                local raidBoss = "Unbekannt"
                
                pcall(function()
                    -- Überprüfe Battle-End GUI auf Hinweise auf einen Raid
                    if child:FindFirstChild("RaidRewards", true) or 
                       child:FindFirstChild("DragonRewards", true) then
                        wasRaid = true
                        
                        -- Versuche, den Raid-Boss-Namen zu ermitteln
                        local bossNameLabel = child:FindFirstChild("BossName", true)
                        if bossNameLabel and bossNameLabel:IsA("TextLabel") then
                            raidBoss = bossNameLabel.Text
                        end
                    end
                end)
                
                if wasRaid then
                    -- Sende Webhook-Benachrichtigung für abgeschlossenen Raid
                    Utilities.SendWebhook({
                        username = "MythHub",
                        embeds = {{
                            title = "Raid abgeschlossen!",
                            description = "Ein Raid wurde erfolgreich abgeschlossen!",
                            color = 16766720, -- Gold in Dezimal
                            fields = {{
                                name = "Boss",
                                value = raidBoss,
                                inline = true
                            }, {
                                name = "Spieler",
                                value = Utilities.GetLocalPlayer().Name,
                                inline = true
                            }},
                            footer = {
                                text = "MythHub Premium - Anime Card Clash"
                            },
                            timestamp = DateTime.now():ToIsoDate()
                        }}
                    })
                end
            end
        end
    end)
end

-- Item Drop und Raid Completion Verbindungen initialisieren
if WebhookConfig.Enabled then
    connectItemDrops()
    connectRaidCompletion()
end

-- Webhook Verbindungen aktualisieren, wenn der Schalter umgelegt wird
WebhookConfig.UpdateConnections = function()
    if WebhookConfig.Enabled then
        connectItemDrops()
        connectRaidCompletion()
        
        -- Check if inventory webhook is enabled with continuous updates
        if WebhookConfig.InventorySendEnabled and not WebhookConfig.Connections.InventorySender then
            WebhookConfig.Connections.InventorySender = spawn(function()
                while WebhookConfig.InventorySendEnabled do
                    -- Sende/aktualisiere das Inventar 
                    Utilities.SendInventoryWebhook()
                    
                    -- Verzögerung gemäß eingestelltem Intervall
                    wait(WebhookConfig.InventoryInterval) -- Update gemäß Intervall
                end
            end)
            
            -- Debug-Info
            warn("Inventory Webhook mit Updates alle " .. (WebhookConfig.InventoryInterval/60) .. " Minuten aktiviert!")
        end
    else
        -- Verbindungen trennen, wenn deaktiviert
        if WebhookConfig.Connections.ItemDrops then
            WebhookConfig.Connections.ItemDrops:Disconnect()
            WebhookConfig.Connections.ItemDrops = nil
        end
        
        if WebhookConfig.Connections.RaidCompletion then
            WebhookConfig.Connections.RaidCompletion:Disconnect()
            WebhookConfig.Connections.RaidCompletion = nil
        end
        
        if WebhookConfig.Connections.InventorySender then
            WebhookConfig.Connections.InventorySender:Disconnect()
            WebhookConfig.Connections.InventorySender = nil
        end
    end
end

-- Webhook-Status bei Toggle aktualisieren
webhook_toggle:Set({Callback = function(Value)
    WebhookConfig.Enabled = Value
    
    if Value then
        if WebhookConfig.URL == "" then
            Utilities.Notify("Webhook", "Bitte zuerst eine Webhook URL eingeben", "error")
            return false
        end
        
        -- Test Webhook
        Utilities.SendWebhook({
            username = "MythHub",
            embeds = {{
                title = "Webhook Test",
                description = "Die Webhook-Verbindung wurde erfolgreich hergestellt!",
                color = 5814783, -- Blau in Dezimal
                fields = {{
                    name = "Spieler",
                    value = Utilities.GetLocalPlayer().Name,
                    inline = true
                }, {
                    name = "Server ID",
                    value = game.JobId,
                    inline = true
                }},
                footer = {
                    text = "MythHub Premium - Anime Card Clash"
                },
                timestamp = DateTime.now():ToIsoDate()
            }}
        })
        
        WebhookConfig.UpdateConnections()
        Utilities.Notify("Webhook", "Webhook Benachrichtigungen aktiviert", "webhook")
    else
        WebhookConfig.UpdateConnections()
        Utilities.Notify("Webhook", "Webhook Benachrichtigungen deaktiviert", "webhook")
    end
end})

-- Aktualisiere das Änderungsprotokoll
if WebhookConfig then
    local changelogText = [[
    ÄNDERUNGSPROTOKOLL - MAI 2025
    
    - Remote-Pfade von "3aA" auf "kQR" aktualisiert
    - Remote-IDs für alle Funktionen aktualisiert:
      * SummonEnemy: 8a63919a-217b-436a-9cfa-4b472d213bbb
      * Battle Tower: 1457e535-9d02-4014-9883-7618f41bed84
      * Infinite Tower (Start): 60ed7d69-2cac-467c-9695-6ab3e77159b9
      * Infinite Tower (Ende): 23fb560d-73d0-404a-8dda-bf8088b08f0a
      * Infinite Tower (Pause): 5bdb0ab8-610f-4823-9e57-4cd48a5c4eb8
      * Exploration (Deploy): 4971f60f-90ff-4142-bf88-5395122136c2
      * Exploration (Claim): e82eeec1-ca38-4f7b-bf14-4b85df674c7b
      * Shop: 41ccb1a6-1009-4e2f-924e-1b71f8020e9b
      * Stats Upgrade: a0d1432a-262d-4b0a-9173-ee8b1dcfb69c
    - Auto-Farm, Raid und Infinite Tower Funktionen angepasst
    - Unterstützung für neue Enemy IDs und Endpoints hinzugefügt
    - Auto-Execute nach Teleport hinzugefügt
    - Auto-Reconnect mit Konfigurationsspeicherung hinzugefügt
    - Discord Webhook-Integration hinzugefügt
    - Inventar-Webhook mit Live-Updates implementiert
    ]]
    
    -- Aktualisiere das Änderungsprotokoll am Ende des Skripts
    local lines = {}
    for line in changelogText:gmatch("[^\r\n]+") do
        table.insert(lines, line)
    end
    
    -- Ersetze das bestehende Änderungsprotokoll
    local script = debug.getinfo(1, "S").source:sub(2)
    local content = readfile(script)
    local startPattern = "%-%-%[%[%s*ÄNDERUNGSPROTOKOLL"
    local endPattern = "%]%]"
    
    local startPos = content:find(startPattern)
    local endPos = content:find(endPattern, startPos)
    
    if startPos and endPos then
        local preContent = content:sub(1, startPos - 1)
        local postContent = content:sub(endPos + 2)
        local newContent = preContent .. "--[[\n" .. changelogText .. "\n]]" .. postContent
        
        writefile(script, newContent)
    end
end

-- Ergänze WebhookConfig um Inventar-Funktionalität
WebhookConfig.InventorySendEnabled = false
WebhookConfig.InventoryInterval = 300 -- 5 Minuten Standardwert
WebhookConfig.LastInventorySend = 0

-- Inventar Webhook Abschnitt
TabMisc:CreateDivider()
TabMisc:CreateSection("Inventory Webhook")

-- Inventar Webhook Toggle
TabMisc:CreateToggle({
    Name = "Send Inventory via Webhook",
    Description = "Sends and continuously updates your inventory via webhook",
    CurrentValue = false,
    Callback = function(Value)
        WebhookConfig.InventorySendEnabled = Value
        
        if Value then
            if WebhookConfig.URL == "" then
                Utilities.Notify("Webhook", "Please enter a webhook URL first", "error")
                return false
            end
            
            -- Aktiviere Live-Aktualisierungen
            WebhookConfig.UpdateConnections()
            
            -- Sofort senden, wenn aktiviert
            Utilities.SendInventoryWebhook()
            
            Utilities.Notify("Webhook", "Inventory webhook enabled with live updates", "webhook")
        else
            if WebhookConfig.Connections.InventorySender then
                WebhookConfig.Connections.InventorySender:Disconnect()
                WebhookConfig.Connections.InventorySender = nil
            end
            
            Utilities.Notify("Webhook", "Inventory webhook disabled", "webhook")
        end
    end
}, "InventoryWebhookToggle")

-- Button zum sofortigen Senden
TabMisc:CreateButton({
    Name = "Send Inventory Now",
    Description = "Immediately sends your current inventory via webhook",
    Callback = function()
        if WebhookConfig.URL == "" then
            Utilities.Notify("Webhook", "Please enter a webhook URL first", "error")
            return
        end
        
        Utilities.SendInventoryWebhook()
        Utilities.Notify("Webhook", "Inventory has been sent", "webhook")
    end
})

-- Funktion zum Aufbereiten und Senden des Inventars über Webhook
Utilities.SendInventoryWebhook = function()
    if not WebhookConfig.Enabled or WebhookConfig.URL == "" then
        return
    end
    
    local success, result = pcall(function()
        -- Notwendige Module importieren
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RuntimeLib = require(ReplicatedStorage:WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
        
        -- Check if modules exist before importing
        if not ReplicatedStorage or not RuntimeLib then
            warn("Required modules not found for inventory webhook")
            return false
        end
        
        -- Safe import with error handling
        local LocalUser, ItemsWithId, ItemCategory, Rarity
        
        local importSuccess, importError = pcall(function()
            LocalUser = RuntimeLib.import(script, ReplicatedStorage, "TS", "user", "local", "local-user").LocalUser
            ItemsWithId = RuntimeLib.import(script, ReplicatedStorage, "TS", "item", "items").ItemsWithId
            ItemCategory = RuntimeLib.import(script, ReplicatedStorage, "TS", "item", "item-category").ItemCategory
            Rarity = RuntimeLib.import(script, ReplicatedStorage, "TS", "rarity").Rarity
        end)
        
        if not importSuccess then
            warn("Failed to import modules: " .. tostring(importError))
            return false
        end
        
        -- Validate imported modules
        if not LocalUser or not LocalUser.atomMap or not LocalUser.atomMap.player or not ItemsWithId then
            warn("Required game modules missing or invalid")
            return false
        end
        
        -- Category emojis
        local CATEGORY_EMOJIS = {
            POTION = "🧪",
            TRAIT = "⚛️",
            TITLE = "👑",
            EQUIPMENT = "🗡️",
            ARTIFACT = "🔮",
            INSTANT_ROLL = "🎲",
            CARD_BACK = "🎴",
            RAID = "🏯",
            MISC = "📦",
            -- Zusätzliche Varianten für verschiedene Schreibweisen
            ["Potion"] = "🧪",
            ["Trait"] = "⚛️",
            ["Title"] = "👑",
            ["Equipment"] = "🗡️",
            ["Artifact"] = "🔮",
            ["Instant Roll"] = "🎲",
            ["Card Back"] = "🎴",
            ["Raid"] = "🏯",
            ["Misc"] = "📦"
        }
        
        -- Rarity emojis
        local RARITY_EMOJIS = {
            COMMON = "⚪",
            UNCOMMON = "🟢",
            RARE = "🔷",
            EPIC = "🟣",
            LEGENDARY = "🟡",
            MYTHIC = "🔴"
        }
        
        -- Definiere RARITY_NAMES für eine bessere Anzeige
        local RARITY_NAMES = {
            COMMON = "Gewöhnlich",
            UNCOMMON = "Ungewöhnlich",
            RARE = "Selten",
            EPIC = "Episch",
            LEGENDARY = "Legendär",
            MYTHIC = "Mythisch"
        }
        
        -- Definiere Kategoriefarben für Embeds
        local categoryColors = {
            POTION = 0x3498DB,    -- Blau
            TRAIT = 0x1ABC9C,     -- Türkis
            TITLE = 0xF1C40F,     -- Gold
            EQUIPMENT = 0xE74C3C, -- Rot
            ARTIFACT = 0x9B59B6,  -- Lila
            INSTANT_ROLL = 0x2ECC71, -- Grün
            CARD_BACK = 0xE67E22, -- Orange
            RAID = 0x34495E,      -- Dunkelblau
            MISC = 0x95A5A6       -- Grau
        }
        
        -- Returns the matching emoji for a category
        local function getCategoryEmoji(categoryName)
            -- Direkte Zuordnung mit einfachen String-Checks
            local categoryLower = string.lower(tostring(categoryName or ""))
            
            if string.find(categoryLower, "potion") then
                return "🧪"
            elseif string.find(categoryLower, "trait") then
                return "⚛️"
            elseif string.find(categoryLower, "title") then
                return "👑"
            elseif string.find(categoryLower, "equipment") then
                return "🗡️"
            elseif string.find(categoryLower, "artifact") then
                return "🔮"
            elseif string.find(categoryLower, "instant") or string.find(categoryLower, "roll") then
                return "🎲"
            elseif string.find(categoryLower, "card") then
                return "🎴"
            elseif string.find(categoryLower, "raid") then
                return "🏯"
            elseif string.find(categoryLower, "misc") then
                return "📦"
            end
            
            return "❓" -- Fallback
        end
        
        -- Returns the matching emoji for a rarity
        local function getRarityEmoji(rarityName)
            if not rarityName then return "❓" end
            return RARITY_EMOJIS[rarityName] or "❓"
        end
        
        -- Hilfsfunktionen für schönere Formatierung
        local function divider(emoji)
            return string.rep(emoji or "━", 15)
        end
        
        local function formatHeader(text, emoji)
            return divider() .. "\n" .. emoji .. " **" .. text .. "** " .. emoji .. "\n" .. divider()
        end
        
        -- Safely get backpack items from the atom map
        local backpackItems = {}
        local getBackpackSuccess, getBackpackError = pcall(function()
            if LocalUser and LocalUser.atomMap and LocalUser.atomMap.player and LocalUser.atomMap.player().backpack then
                backpackItems = LocalUser.atomMap.player().backpack.items or {}
            end
        end)
        
        if not getBackpackSuccess then
            warn("Failed to get backpack items: " .. tostring(getBackpackError))
            return false
        end
        
        -- Check if items exist
        local itemCount = 0
        for _ in pairs(backpackItems) do
            itemCount = itemCount + 1
        end
        
        -- Sort items by category
        local categorizedItems = {}
        
        for itemId, itemData in pairs(backpackItems) do
            if itemId and itemData and ItemsWithId and ItemsWithId[itemId] then
                local itemInfo = ItemsWithId[itemId]
                if itemInfo then
                    local categoryName = (itemInfo.category and itemInfo.category.name) or "UNKNOWN"
                    
                    if not categorizedItems[categoryName] then
                        categorizedItems[categoryName] = {}
                    end
                    
                    table.insert(categorizedItems[categoryName], {
                        id = itemId,
                        info = itemInfo,
                        data = itemData
                    })
                end
            end
        end
        
        -- Get current timestamp and player name with spoiler tags
        local currentTime = os.time()
        local formattedTime = os.date("%Y-%m-%d %H:%M:%S", currentTime)
        
        -- Safely get player name
        local playerName = "Unknown"
        local getPlayerSuccess, getPlayerError = pcall(function()
            if Utilities and Utilities.GetLocalPlayer then
                local player = Utilities.GetLocalPlayer()
                if player and player.Name then
                    playerName = player.Name
                end
            end
        end)
        
        if not getPlayerSuccess then
            warn("Failed to get player name: " .. tostring(getPlayerError))
        end
        
        local maskedUsername = "||" .. playerName .. "||"
        
        -- Versuche, das lokale Logo zu laden - vereinfacht und direkt verwenden
        local logoUrl = "attachment://MYTHLOGO.png" -- Discord Attachment Format
        
        -- Prepare output for Discord
        local embeds = {}
        local mainEmbed = {
            title = formatHeader("INVENTORY OVERVIEW", "✨"),
            description = "Player: " .. maskedUsername .. "\n" ..
                      "Total Items: **" .. itemCount .. "**\n\n" ..
                      "Last Updated: <t:" .. currentTime .. ":R>",
            color = 0x0000FF, -- Blaues Design wie im Logo
            thumbnail = {
                url = logoUrl
            },
            fields = {},
            footer = {
                text = "MythHub Premium • github.com/MythHubRoblox/MythHub",
                icon_url = logoUrl
            },
            timestamp = DateTime.now():ToIsoDate()
        }
        
        -- Add equipped items with error handling
        local equippedField = {
            name = "🎽 **Equipped Items**",
            value = "",
            inline = false
        }
        
        local equippedTitle, equippedEquipment, equippedArtifact
        
        local getEquippedSuccess, getEquippedError = pcall(function()
            if LocalUser and LocalUser.backpack then
                equippedTitle = LocalUser.backpack:getEquippedTitle()
                equippedEquipment = LocalUser.backpack:getEquippedEquipment()
                equippedArtifact = LocalUser.backpack:getEquippedArtifact()
            end
        end)
        
        if not getEquippedSuccess then
            warn("Failed to get equipped items: " .. tostring(getEquippedError))
            equippedField.value = "*Error retrieving equipped items*"
        else
            -- Verbesserte Null-Prüfungen für Ausrüstungsgegenstände
            if equippedTitle and type(equippedTitle) == "table" and equippedTitle.item and type(equippedTitle.item) == "table" and equippedTitle.item.name then
                equippedField.value = equippedField.value .. "👑 **Title:** " .. equippedTitle.item.name .. "\n"
            end
            
            if equippedEquipment and type(equippedEquipment) == "table" and equippedEquipment.item and type(equippedEquipment.item) == "table" and equippedEquipment.item.name then
                equippedField.value = equippedField.value .. "⚔️ **Equipment:** " .. equippedEquipment.item.name .. "\n"
            end
            
            if equippedArtifact and type(equippedArtifact) == "table" and equippedArtifact.item and type(equippedArtifact.item) == "table" and equippedArtifact.item.name then
                equippedField.value = equippedField.value .. "🔮 **Artifact:** " .. equippedArtifact.item.name .. "\n"
            end
            
            if equippedField.value == "" then
                equippedField.value = "*No items equipped*"
            end
        end
        
        table.insert(mainEmbed.fields, equippedField)
        table.insert(embeds, mainEmbed)
        
        -- Category overview - wir erstellen für jede Kategorie ein eigenes Embed statt alle zusammen
        -- Entferne das alte categoryOverviewEmbed
        
        -- Erstelle für jede Kategorie ein eigenes Embed für bessere Lesbarkeit
        for categoryName, items in pairs(categorizedItems) do
            if #items > 0 then
                local categoryEmoji = getCategoryEmoji(categoryName)
                local categoryEmbed = {
                    title = formatHeader(categoryName, categoryEmoji),
                    description = "**Total:** " .. #items .. " items",
                    color = categoryColors[categoryName] or 0x2ECC71, -- Grün als Standard
                    fields = {},
                    footer = {
                        text = "MythHub Premium • Category: " .. categoryName,
                        icon_url = logoUrl
                    }
                }
                
                -- Items nach Seltenheit gruppieren für bessere Übersicht
                local itemsByRarity = {}
                for _, item in ipairs(items) do
                    if item and item.info and item.data then
                        local rarityName = (item.info.rarity and item.info.rarity.name) or "UNKNOWN"
                        if not itemsByRarity[rarityName] then
                            itemsByRarity[rarityName] = {}
                        end
                        table.insert(itemsByRarity[rarityName], item)
                    end
                end
                
                -- Seltenheiten in absteigender Reihenfolge (Mythisch zuerst)
                local rarityOrder = {"MYTHIC", "LEGENDARY", "EPIC", "RARE", "UNCOMMON", "COMMON"}
                
                for _, rarityName in ipairs(rarityOrder) do
                    local rarityItems = itemsByRarity[rarityName]
                    if rarityItems and #rarityItems > 0 then
                        local rarityEmoji = getRarityEmoji(rarityName)
                        local displayName = RARITY_NAMES[rarityName] or rarityName
                        local fieldValue = ""
                        
                        -- Keine Begrenzung, alle Items anzeigen (aufgeteilt in mehrere Felder bei Bedarf)
                        local maxItemsPerField = 20 -- Maximum pro Discord-Feld
                        local totalFields = math.ceil(#rarityItems / maxItemsPerField)
                        
                        for fieldIndex = 1, totalFields do
                            local startIdx = (fieldIndex - 1) * maxItemsPerField + 1
                            local endIdx = math.min(fieldIndex * maxItemsPerField, #rarityItems)
                            
                            local fieldValue = ""
                            for i = startIdx, endIdx do
                                local item = rarityItems[i]
                                local equipped = (item.data.equipped and "✅") or ""
                                
                                fieldValue = fieldValue .. string.format(
                                    "**%s** (×%d) %s\n",
                                    item.info.name or "Unknown Item",
                                    item.data.quantity or 0,
                                    equipped
                                )
                            end
                            
                            local fieldName = rarityEmoji .. " **" .. displayName .. "** (" .. #rarityItems .. ")"
                            if totalFields > 1 then
                                fieldName = fieldName .. " - Teil " .. fieldIndex .. "/" .. totalFields
                            end
                            
                            table.insert(categoryEmbed.fields, {
                                name = fieldName,
                                value = fieldValue,
                                inline = false
                            })
                        end
                    end
                end
                
                if #categoryEmbed.fields > 0 then
                    table.insert(embeds, categoryEmbed)
                end
            end
        end
        
        -- Rare items overview (Legendary & Mythic)
        local rareItemsEmbed = {
            title = "💎 **RARE ITEMS COLLECTION**",
            description = "Legendary and mythic items in your inventory",
            color = 0xF1C40F, -- Gold
            fields = {},
            footer = {
                text = "MythHub Premium • " .. formattedTime,
                icon_url = logoUrl
            }
        }
        
        local foundRareItems = false
        
        -- Find all legendary and mythic items
        for categoryName, items in pairs(categorizedItems) do
            local rareItems = {}
            
            for _, item in ipairs(items) do
                if item and item.info and item.info.rarity and item.info.rarity.name then
                    local rarityName = item.info.rarity.name
                    if rarityName == "LEGENDARY" or rarityName == "MYTHIC" then
                        table.insert(rareItems, item)
                        foundRareItems = true
                    end
                end
            end
            
            if #rareItems > 0 then
                local categoryEmoji = getCategoryEmoji(categoryName)
                local rareItemsField = {
                    name = categoryEmoji .. " **" .. categoryName .. "**",
                    value = "",
                    inline = true
                }
                
                -- Sort by rarity
                local sortSuccess, sortError = pcall(function()
                    table.sort(rareItems, function(a, b)
                        if not a or not b or not a.info or not b.info then return false end
                        
                        if (a.info.rarity and b.info.rarity and a.info.rarity.value ~= b.info.rarity.value) then
                            return (a.info.rarity.value or 0) > (b.info.rarity.value or 0)
                        end
                        return (a.info.name or "") < (b.info.name or "")
                    end)
                end)
                
                if not sortSuccess then
                    warn("Failed to sort rare items: " .. tostring(sortError))
                end
                
                for _, item in ipairs(rareItems) do
                    if item and item.info and item.data then
                        local rarityName = (item.info.rarity and item.info.rarity.name) or "UNKNOWN"
                        local rarityEmoji = getRarityEmoji(rarityName)
                        local equipped = (item.data.equipped and "✅") or ""
                        
                        rareItemsField.value = rareItemsField.value .. string.format(
                            "%s **%s** (×%d) %s\n",
                            rarityEmoji,
                            item.info.name or "Unknown Item",
                            item.data.quantity or 0,
                            equipped
                        )
                    end
                end
                
                table.insert(rareItemsEmbed.fields, rareItemsField)
            end
        end
        
        if not foundRareItems then
            rareItemsEmbed.description = "*No legendary or mythic items found in inventory*"
        end
        
        table.insert(embeds, rareItemsEmbed)
        
        -- Add statistics embed
        local statsEmbed = {
            title = formatHeader("INVENTORY STATISTICS", "📊"),
            color = 0x9B59B6, -- Lila
            fields = {},
            footer = {
                text = "MythHub Premium • discord.gg/mythhub",
                icon_url = logoUrl
            }
        }
        
        -- Detaillierte Auflistung der Items direkt nach Kategorie
        for categoryName, items in pairs(categorizedItems) do
            if #items == 0 then
                -- Überspringe leere Kategorien
                continue
            end
            
            -- Erstelle ein klares, organisiertes Format für die Kategorieüberschrift
            local categoryEmoji = getCategoryEmoji(categoryName)
            local categoryField = {
                name = "**" .. categoryName .. "** (" .. #items .. ")",
                value = "",
                inline = false
            }
            
            -- Gruppiere Items nach Namen und Seltenheit
            local groupedItems = {}
            
            for _, item in ipairs(items) do
                if item and item.info and item.info.name and item.data then
                    local itemName = item.info.name
                    local key = itemName -- Gruppierungsschlüssel
                    
                    if not groupedItems[key] then
                        groupedItems[key] = {
                            name = itemName,
                            quantity = 0,
                            equipped = item.data.equipped or false
                        }
                    end
                    
                    -- Summiere die Menge
                    groupedItems[key].quantity = groupedItems[key].quantity + (item.data.quantity or 1)
                    
                    -- Falls ein Item ausgerüstet ist, markiere es
                    if item.data.equipped then
                        groupedItems[key].equipped = true
                    end
                end
            end
            
            -- Konvertiere in Liste zum Sortieren
            local sortedItems = {}
            for _, itemData in pairs(groupedItems) do
                table.insert(sortedItems, itemData)
            end
            
            -- Sortiere nur nach Namen, da es keine Raritäten gibt
            table.sort(sortedItems, function(a, b)
                return a.name < b.name
            end)
            
            -- Füge jeden Item-Eintrag zum Feld hinzu
            for _, itemData in ipairs(sortedItems) do
                local equipped = itemData.equipped and " ✅" or ""
                
                -- WICHTIG: Verwende dasselbe Emoji wie für die Kategorie für jedes Item
                categoryField.value = categoryField.value .. string.format(
                    "%s **%s** (×%d)%s\n",
                    categoryEmoji,
                    itemData.name,
                    itemData.quantity,
                    equipped
                )
            end
            
            -- Füge einen Zeilenumbruch nach jedem Kategorie-Feld hinzu
            categoryField.value = "\n" .. categoryField.value
            
            -- Füge das Feld zum Embed hinzu, wenn es Inhalt hat
            if categoryField.value ~= "" then
                table.insert(statsEmbed.fields, categoryField)
            end
        end
        
        -- Entferne die Legende
        
        table.insert(embeds, statsEmbed)
        
        -- Versende Webhook mit verbessertem Design
        local HttpService = game:GetService("HttpService")
        local httpRequest = (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or request
        
        if httpRequest then
            -- Discord erlaubt maximal 10 Embeds pro Nachricht
            if #embeds > 10 then
                embeds = {table.unpack(embeds, 1, 10)}
            end
            
            -- Erstelle einen schöneren Webhook-Titel
            local currentDate = os.date("%d.%m.%Y", os.time())
            local webhookContent = "## 📋 MythHub Inventory Report - " .. currentDate .. "\n"
            webhookContent = webhookContent .. "Player: " .. maskedUsername .. " | Items: " .. itemCount
            
            -- Verbesserte Webhook-Nachricht mit Avatar und Benutzername
            -- Fügt die Datei direkt als Anhang hinzu
            local fileData
            
            -- Verbesserte Fehlerbehandlung für die Logo-Datei
            local readSuccess, readResult = pcall(function()
                if isfile and readfile and isfile("MYTHLOGO.png") then
                    return readfile("MYTHLOGO.png")
                elseif getsynasset and readfile and isfile("MYTHLOGO.png") then
                    -- Alternative für Synapse X
                    return readfile("MYTHLOGO.png") 
                end
                return nil
            end)
            
            if readSuccess and readResult then
                fileData = readResult
            else
                warn("Logo-Datei konnte nicht gelesen werden. Verwende alternatives Logo.")
            end
            
            -- HTTP Request mit Dateianhang (falls verfügbar)
            local requestSuccess, requestError = pcall(function()
                -- Webhook-URL und Methode vorbereiten
                local method = "POST"  -- Standard: Neue Nachricht erstellen
                local url = WebhookConfig.URL
                
                -- Wenn bereits eine Message-ID gespeichert ist, aktualisiere diese statt eine neue zu senden
                if WebhookConfig.LastMessageID then
                    method = "PATCH"  -- PATCH zum Aktualisieren einer existierenden Nachricht
                    url = WebhookConfig.URL .. "/messages/" .. WebhookConfig.LastMessageID
                end
                
                local response
                
                if fileData then
                    response = httpRequest({
                        Url = url,
                        Method = method,
                        Headers = {
                            ["Content-Type"] = "multipart/form-data; boundary=---------------------------boundary"
                        },
                        Body = "---------------------------boundary\r\n" ..
                              'Content-Disposition: form-data; name="payload_json"\r\n' ..
                              "Content-Type: application/json\r\n\r\n" ..
                              HttpService:JSONEncode({
                                  username = "MythHub Inventory System",
                                  content = webhookContent,
                                  embeds = embeds
                              }) .. "\r\n" ..
                              "---------------------------boundary\r\n" ..
                              'Content-Disposition: form-data; name="file"; filename="MYTHLOGO.png"\r\n' ..
                              "Content-Type: image/png\r\n\r\n" ..
                              fileData .. "\r\n" ..
                              "---------------------------boundary--\r\n"
                    })
                else
                    -- Fallback ohne Dateianhang
                    response = httpRequest({
                        Url = url,
                        Method = method,
                        Headers = {
                            ["Content-Type"] = "application/json"
                        },
                        Body = HttpService:JSONEncode({
                            username = "MythHub Inventory System",
                            avatar_url = "https://i.imgur.com/jVJ9q32.png", -- Fallback
                            content = webhookContent,
                            embeds = embeds
                        })
                    })
                end
                
                -- Speichere Message-ID für künftige Updates
                if method == "POST" and response and response.Body then
                    local success, body = pcall(function() return HttpService:JSONDecode(response.Body) end)
                    if success and body and body.id then
                        WebhookConfig.LastMessageID = body.id
                        -- Debug-Info
                        warn("Neue Webhook-Nachricht ID gespeichert: " .. body.id)
                    end
                end
            end)
            
            if not requestSuccess then
                warn("Webhook request failed: " .. tostring(requestError))
            end
            
            return true
        else
            return false
        end
    end)
    
    if not success then
        warn("Inventory webhook failed: " .. tostring(result))
    end
end

-- Intervall Slider wieder hinzufügen
TabMisc:CreateSlider({
    Name = "Interval (Minutes)",
    Description = "Time between inventory webhook updates",
    Range = {1, 60},
    Increment = 1,
    CurrentValue = 5,
    Callback = function(Value)
        WebhookConfig.InventoryInterval = Value * 60 -- Convert to seconds
        Utilities.Notify("Webhook", "Inventory interval set to " .. Value .. " minutes", "webhook")
    end
}, "InventoryIntervalSlider")
