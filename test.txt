--[[
    MythHub - Premium Script Hub
    Game: Anime Card Clash
    Created by: MythTeam
    
    Features:
    - Dashboard with information and stats
    - AutoFarm for enemies across all worlds
    - Tower automation for Battle and Infinite Towers
    - Raid assistance and automation
    - Exploration management
    - Shop automation
    - Misc utilities including auto pickup, auto merge, and more
    
    Last Updated: April 2025
]]

-- Load Luna Interface Library
local Luna = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/refs/heads/main/source.lua", true))()

-- Initialize Window without Key System
local Window = Luna:CreateWindow({
    Name = "MythHub",
    Subtitle = "Anime Card Clash",
    LogoID = "134758479713826", -- MythHub logo ID
    LoadingEnabled = true,
    LoadingTitle = "MythHub Premium",
    LoadingSubtitle = "Anime Card Clash Edition",
    
    ConfigSettings = {
        RootFolder = "MythHub",
        ConfigFolder = "AnimeCardClash"
    },
    
    KeySystem = false
})

-- Utility Functions
local Utilities = {}

-- Function to summon an enemy for battle
Utilities.SummonEnemy = function(enemyName)
    Utilities.DebugPrint("Attempting to fight enemy: " .. tostring(enemyName))
    
    if not enemyName then
        Utilities.DebugPrint("Cannot fight nil enemy")
        return false
    end
    
    local success, result = pcall(function()
        -- Versuche einen Kampf mit dem Gegner zu beginnen
        local args = {
            [1] = enemyName
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("9f262bf4-f76a-4916-94dc-46596cc25770"):FireServer(unpack(args))
        return true
    end)
    
    if not success then
        Utilities.DebugPrint("Error starting fight with enemy: " .. tostring(result))
        return false
    end
    
    Utilities.DebugPrint("Successfully sent fight request for: " .. enemyName)
    return true
end

-- Function to get local player
Utilities.GetLocalPlayer = function()
    return game:GetService("Players").LocalPlayer
end

-- Function to check if a player is in game
Utilities.IsInGame = function()
    return game:IsLoaded() and Utilities.GetLocalPlayer() ~= nil
end

-- Function to create notifications
Utilities.Notify = function(title, content, icon)
    Luna:Notification({
        Title = title or "MythHub Notification",
        Content = content or "Action completed successfully",
        Icon = icon or "notifications_active",
        ImageSource = "Material"
    })
end

-- Function to get Battle Tower level
Utilities.GetBattleTowerLevel = function()
    local success, result = pcall(function()
        local LocalUserModule = game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")
        local LocalUser = require(LocalUserModule).LocalUser
        local battleTowerWave = LocalUser.metadata:getAsNumber("battle_tower_wave")
        return battleTowerWave or 1
    end)
    
    if success then
        return result
    else
        return 1
    end
end

-- Function to get Infinite Tower floor
Utilities.GetInfiniteTowerFloor = function()
    local success, result = pcall(function()
        local LocalUser = require(game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        
        if LocalUser and LocalUser.infiniteTower then
            local document = LocalUser.infiniteTower:getDocument()
            if document and document.floor then
                return document.floor
            end
        end
        return 1
    end)
    
    if success and result then
        return result
    else
        return 1
    end
end

-- Function to get available upgrade points
Utilities.GetUpgradePoints = function()
    local success, result = pcall(function()
        local LocalUser = require(game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        return LocalUser.upgrades:getCards()
    end)
    
    if success then
        return result
    else
        return 0
    end
end

-- Function to print debug messages
Utilities.DebugPrint = function(message)
    print("[MythHub Debug] " .. message)
    -- Also add to console GUI if available
    pcall(function()
        if game:GetService("Players").LocalPlayer and game:GetService("Players").LocalPlayer.PlayerGui and game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("MythHubConsole") then
            local console = game:GetService("Players").LocalPlayer.PlayerGui.MythHubConsole
            if console and console:FindFirstChild("Console") and console.Console:FindFirstChild("Text") then
                console.Console.Text.Text = console.Console.Text.Text .. "\n" .. message
            end
        end
    end)
end

-- Function to check if player is in battle
Utilities.IsInBattle = function()
    local localPlayer = Utilities.GetLocalPlayer()
    if localPlayer and localPlayer.PlayerGui then
        local hasBattleGui = localPlayer.PlayerGui:FindFirstChild("battle") ~= nil
        Utilities.DebugPrint("Battle GUI check: " .. tostring(hasBattleGui))
        return hasBattleGui
    end
    Utilities.DebugPrint("Battle GUI check failed - player or GUI not found")
    return false
end

-- Function to check if battle just ended
Utilities.IsBattleEnded = function()
    local localPlayer = Utilities.GetLocalPlayer()
    if localPlayer and localPlayer.PlayerGui then
        local hasBattleEndGui = localPlayer.PlayerGui:FindFirstChild("battle-end") ~= nil
        Utilities.DebugPrint("Battle-End GUI check: " .. tostring(hasBattleEndGui))
        return hasBattleEndGui
    end
    Utilities.DebugPrint("Battle-End GUI check failed - player or GUI not found")
    return false
end

-- Function to simulate mouse clicks (M1)
Utilities.ClickM1 = function(times)
    times = times or 10 -- Default to 10 clicks
    
    Utilities.DebugPrint("Attempting to send " .. times .. " M1 clicks")
    pcall(function()
        for i = 1, times do
            Utilities.DebugPrint("Sending M1 click " .. i .. "/" .. times)
            game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, game, 1)
            wait(0.1)
            game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, false, game, 1)
            wait(0.1)
        end
    end)
    Utilities.DebugPrint("Finished sending M1 clicks")
end

-- Function to dismiss battle end screen
Utilities.DismissBattleEnd = function()
    Utilities.DebugPrint("DismissBattleEnd function called")
    if Utilities.IsBattleEnded() then
        Utilities.DebugPrint("Battle-End detected, waiting 3 seconds before clicking")
        wait(3)
        
        -- Click M1 repeatedly until battle-end GUI is gone
        local maxAttempts = 30 -- Maximum attempts to prevent infinite loop
        local attempts = 0
        
        Utilities.DebugPrint("Starting to click M1 to dismiss Battle-End")
        while Utilities.IsBattleEnded() and attempts < maxAttempts do
            Utilities.DebugPrint("Click attempt " .. attempts+1 .. "/" .. maxAttempts)
            Utilities.ClickM1(3) -- Try 3 clicks each iteration, changed from 5
            wait(0.5)
            attempts = attempts + 1
        end
        
        if attempts >= maxAttempts then
            Utilities.DebugPrint("WARNING: Failed to dismiss Battle-End after " .. maxAttempts .. " attempts")
        else
            Utilities.DebugPrint("Successfully dismissed Battle-End GUI after " .. attempts .. " attempts")
        end
        
        -- Wait a bit more to ensure everything is properly dismissed
        Utilities.DebugPrint("Waiting 1 second extra to ensure dismissal is complete")
        wait(1)
    else
        Utilities.DebugPrint("No Battle-End GUI detected, nothing to dismiss")
    end
end

-- AutoFarm Configuration
local AutoFarmConfig = {
    Enabled = false,
    CurrentWorld = "Ninja Village",
    CurrentEnemy = "unstoppable_fist",
    AutoCollect = false,
    AutoMerge = false,
    AutoFarmAllWorldBosses = false,
    AutoFarmAllEnemiesInSelectedWorlds = false,
    SelectedWorlds = {"Ninja Village"},
    SelectedEnemies = {"unstoppable_fist"},
    WorldBosses = {
        "bijuu_beast",           -- Naruto Rage Mode
        "awakened_galactic_tyrant", -- Frieza
        "king_of_curses",        -- Sukuna
        "combat_giant",          -- Eren
        "awakened_pale_demon_lord", -- Muzan
        "soul_queen",            -- Big Mom
        "awakened_shadow_monarch"  -- Sung Jinwoo
    },
    AllEnemies = {
        -- Ninja Village
        "unstoppable_fist", -- Rock Lee
        "copy_ninja", -- Kakashi
        "awakened_dark_avenger", -- Sasuke
        "awakened_promised_child", -- Naruto Sage Mode
        "six_paths_of_pain", -- Pain
        "bijuu_beast", -- Naruto Rage Mode (Boss)
        
        -- Green Village
        "ultimate_warrior", -- Son Gohan
        "body_switcher", -- Captain Ginyu
        "namekian_sage", -- Piccolo
        "awakened_prideful_prince", -- Vegeta
        "awakened_earth_strongest", -- Goku
        "awakened_galactic_tyrant", -- Frieza (Boss)
        
        -- Shibuya Station
        "cursed_doll", -- Nobara
        "awakened_shadow_summoner", -- Megumi
        "cursed_fist", -- Yuji
        "rika_blessing", -- Yuta
        "limitless_master", -- Gojo
        "king_of_curses", -- Sukuna (Boss)
        
        -- Titans City
        "survey_commander", -- Erwin
        "blade_warrior", -- Mikasa
        "armored_giant", -- Reiner
        "beast_giant", -- Zeke
        "blade_captain", -- Levi
        "combat_giant", -- Eren (Boss)
        
        -- Dimensional Fortress
        "thunder_demon", -- Kaigaku
        "childish_demon", -- Hantengu
        "compass_demon", -- Akaza
        "awakened_frost_demon", -- Doma
        "awakened_six_eyed_slayer", -- Kokushibo
        "awakened_pale_demon_lord", -- Muzan (Boss)
        
        -- Candy Island
        "genie_commander", -- Daifuku
        "candy_master", -- Perospero
        "biscuit_warrior", -- Cracker
        "juice_queen", -- Smoothie
        "mochi_emperor", -- Katakuri
        "soul_queen", -- Big Mom (Boss)
        
        -- Solo City
        "light_saintess", -- Cha Hae-In
        "the_goliath", -- Thomas Andre
        "shadow_bear", -- Tank
        "shadow_commander", -- Igris
        "shadow_ant", -- Beru
        "awakened_shadow_monarch" -- Sung Jinwoo (Boss)
    },
    Interval = 10 * 60, -- 10 minutes cooldown
    Connections = {},
    EnemyCooldowns = {} -- Stellen wir sicher, dass dies als leeres Table initialisiert wird
}

-- Funktion, um sicherzustellen, dass EnemyCooldowns existiert
Utilities.EnsureEnemyCooldownsInitialized = function()
    if not AutoFarmConfig.EnemyCooldowns then
        Utilities.DebugPrint("EnemyCooldowns was nil, initializing as empty table")
        AutoFarmConfig.EnemyCooldowns = {}
    end
end

-- Function to handle battle flow and start next battle
Utilities.StartNextBattle = function(enemyName)
    Utilities.DebugPrint("StartNextBattle called for enemy: " .. tostring(enemyName))
    
    -- Stellen wir sicher, dass EnemyCooldowns existiert
    Utilities.EnsureEnemyCooldownsInitialized()
    
    -- Check if enemy is on cooldown
    local currentTime = os.time()
    if enemyName and AutoFarmConfig.EnemyCooldowns[enemyName] and AutoFarmConfig.EnemyCooldowns[enemyName] > currentTime then
        local remainingCooldown = math.ceil(AutoFarmConfig.EnemyCooldowns[enemyName] - currentTime)
        Utilities.DebugPrint("Enemy " .. enemyName .. " is still on cooldown for " .. remainingCooldown .. " seconds")
        return false
    end
    
    -- First check if we're in a battle
    if Utilities.IsInBattle() then
        Utilities.DebugPrint("Already in battle, cannot start new battle")
        return false -- Already in battle, can't start a new one
    end
    
    -- Check if we need to dismiss a battle end screen
    if Utilities.IsBattleEnded() then
        Utilities.DebugPrint("Battle-End screen detected, attempting to dismiss")
        Utilities.DismissBattleEnd()
        return false
    end
    
    -- Now try to summon the enemy if not in battle and no battle end screen
    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
        Utilities.DebugPrint("No battle or battle-end detected, attempting to summon: " .. tostring(enemyName))
        local success = Utilities.SummonEnemy(enemyName)
        
        if success then
            Utilities.DebugPrint("Summon attempt successful, waiting 2 seconds for battle to start")
            -- Wait 2 seconds to allow battle to start properly
            wait(2)
            
            -- Check if we successfully entered battle
            if Utilities.IsInBattle() then
                Utilities.DebugPrint("Successfully entered battle with " .. enemyName)
                return true
            else
                -- If we didn't enter battle but summoned successfully, the enemy might be on cooldown
                Utilities.DebugPrint("Summoned enemy but didn't enter battle, setting cooldown for " .. enemyName)
                if enemyName then
                    AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + AutoFarmConfig.Interval
                end
                return false
            end
        else
            Utilities.DebugPrint("Summon attempt failed for: " .. tostring(enemyName))
        end
        
        return success
    end
    
    Utilities.DebugPrint("Failed to start battle - either still in battle or battle-end state")
    return false
end

-- Function to mark an enemy as defeated (sets its cooldown)
Utilities.MarkEnemyDefeated = function(enemyName)
    -- Stellen wir sicher, dass EnemyCooldowns existiert
    Utilities.EnsureEnemyCooldownsInitialized()
    
    if not enemyName then
        Utilities.DebugPrint("Cannot mark nil enemy as defeated")
        return
    end
    
    Utilities.DebugPrint("Marking enemy as defeated: " .. tostring(enemyName))
    
    -- Check if enemy is a raid boss (eternal_dragon) or world boss
    local isRaidBoss = (enemyName == "eternal_dragon")
    local isWorldBoss = false
    
    -- Check if it's a world boss
    for _, boss in ipairs(AutoFarmConfig.WorldBosses) do
        if enemyName == boss then
            isWorldBoss = true
            break
        end
    end
    
    -- Only set cooldown if it's not a raid boss
    if isRaidBoss then
        Utilities.DebugPrint("Enemy " .. enemyName .. " is a Raid Boss - no cooldown applied")
    elseif isWorldBoss then
        -- Still apply cooldown for world bosses (not raid bosses)
        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + 600
        Utilities.DebugPrint("World Boss " .. enemyName .. " will be available again in 10 minutes (at " .. os.date("%H:%M:%S", AutoFarmConfig.EnemyCooldowns[enemyName]) .. ")")
    else
        -- Set cooldown to exactly 10 minutes (600 seconds) for regular enemies
        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + 600
        Utilities.DebugPrint("Enemy " .. enemyName .. " will be available again in 10 minutes (at " .. os.date("%H:%M:%S", AutoFarmConfig.EnemyCooldowns[enemyName]) .. ")")
    end
end

-- Enemy display names mapping
local EnemyDisplayNames = {
    -- Ninja Village
    unstoppable_fist = "Rock Lee",
    copy_ninja = "Kakashi",
    awakened_dark_avenger = "Sasuke",
    awakened_promised_child = "Naruto Sage Mode",
    six_paths_of_pain = "Pain",
    bijuu_beast = "Naruto Rage Mode (Boss)",
    
    -- Green Village
    ultimate_warrior = "Son Gohan",
    body_switcher = "Captain Ginyu",
    namekian_sage = "Piccolo",
    awakened_prideful_prince = "Vegeta",
    awakened_earth_strongest = "Goku",
    awakened_galactic_tyrant = "Frieza (Boss)",
    
    -- Shibuya Station
    cursed_doll = "Nobara",
    awakened_shadow_summoner = "Megumi",
    cursed_fist = "Yuji",
    rika_blessing = "Yuta",
    limitless_master = "Gojo",
    king_of_curses = "Sukuna (Boss)",
    
    -- Titans City
    survey_commander = "Erwin",
    blade_warrior = "Mikasa",
    armored_giant = "Reiner",
    beast_giant = "Zeke",
    blade_captain = "Levi",
    combat_giant = "Eren (Boss)",
    
    -- Dimensional Fortress
    thunder_demon = "Kaigaku",
    childish_demon = "Hantengu",
    compass_demon = "Akaza",
    awakened_frost_demon = "Doma",
    awakened_six_eyed_slayer = "Kokushibo",
    awakened_pale_demon_lord = "Muzan (Boss)",
    
    -- Candy Island
    genie_commander = "Daifuku",
    candy_master = "Perospero",
    biscuit_warrior = "Cracker",
    juice_queen = "Smoothie",
    mochi_emperor = "Katakuri",
    soul_queen = "Big Mom (Boss)",
    
    -- Solo City
    light_saintess = "Cha Hae-In",
    the_goliath = "Thomas Andre",
    shadow_bear = "Tank",
    shadow_commander = "Igris",
    shadow_ant = "Beru",
    awakened_shadow_monarch = "Sung Jinwoo (Boss)"
}

-- Function to generate enemy display options for dropdown
local function getEnemyDisplayOptions(enemies)
    local displayOptions = {}
    for _, enemyCode in ipairs(enemies) do
        table.insert(displayOptions, EnemyDisplayNames[enemyCode] .. " (" .. enemyCode .. ")")
    end
    return displayOptions
end

-- Function to extract enemy code from display option
local function getEnemyCodeFromDisplayOption(displayOption)
    return string.match(displayOption, "%(([^%)]+)%)")
end

-- Initialize Tabs
local TabDashboard = Window:CreateTab({
    Name = "Dashboard",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabAutoFarm = Window:CreateTab({
    Name = "AutoFarm",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabTowers = Window:CreateTab({
    Name = "Towers",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabRaids = Window:CreateTab({
    Name = "Raids",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabExploration = Window:CreateTab({
    Name = "Exploration",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabShop = Window:CreateTab({
    Name = "Shop",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabMisc = Window:CreateTab({
    Name = "Misc",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabSettings = Window:CreateTab({
    Name = "Settings",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

-- Create Home Tab with information dashboard
Window:CreateHomeTab({
    SupportedExecutors = {"Synapse X", "Script-Ware", "Krnl", "Fluxus", "Electron", "Oxygen U"},
    DiscordInvite = "MythHubDiscord", -- Replace with actual Discord code
    Icon = 2
})

-- Dashboard Tab
TabDashboard:CreateParagraph({
    Title = "Welcome to MythHub - Anime Card Clash",
    Text = "Thank you for choosing MythHub Premium for Anime Card Clash. This script offers a comprehensive suite of features to enhance your gameplay experience. Our premium features are optimized for the best executors on the market."
})

TabDashboard:CreateSection("Player Statistics")

local stats_section = TabDashboard:CreateParagraph({
    Title = "Your Statistics",
    Text = "Loading player statistics..."
})

-- Update player stats periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            local tower_level = Utilities.GetBattleTowerLevel()
            local infinite_floor = Utilities.GetInfiniteTowerFloor()
            local upgrade_points = Utilities.GetUpgradePoints()
            
            stats_section:Set({
                Text = "Battle Tower Level: " .. tower_level .. 
                      "\nInfinite Tower Floor: " .. infinite_floor .. 
                      "\nAvailable Upgrade Points: " .. upgrade_points
            })
        end
    end
end)

TabDashboard:CreateDivider()

-- Add executor compatibility warning
TabDashboard:CreateSection("Executor Compatibility")

TabDashboard:CreateParagraph({
    Title = "Free Executor Limitations",
    Text = "Please note that free executors may not support all features due to their limitations. Specifically:\n\n• Battle Tower automation will not work properly\n• Stat Points features are incompatible with free executors\n\nOther features like AutoFarm and basic automation should function normally. For the best experience, we recommend using premium executors such as Synapse X, Script-Ware, or Fluxus."
})

TabDashboard:CreateDivider()

TabDashboard:CreateSection("Latest Updates")

TabDashboard:CreateParagraph({
    Title = "Recent Changes",
    Text = "• Added Auto Raid function with boss detection\n• Improved AutoFarm efficiency and stability\n• Added Auto-Merge functionality\n• Fixed issues with Tower automation\n• Improved UI responsiveness"
})

-- Add premium features highlight
TabDashboard:CreateDivider()

TabDashboard:CreateSection("Premium Features")

TabDashboard:CreateParagraph({
    Title = "MythHub Premium Advantages",
    Text = "• Advanced Battle Tower automation (Premium executors only)\n• Stat Points optimization system\n• Multi-world boss farming\n• Intelligent cooldown management\n• Automatic exploration team management\n• Premium support via our Discord"
})

-- AutoFarm Tab
TabAutoFarm:CreateSection("Enemy Farm Configuration")

-- World selection
local world_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select Worlds",
    Description = "Choose the worlds to farm enemies from",
    Options = {"Ninja Village", "Green Village", "Shibuya Station", "Titans City", "Dimensional Fortress", "Candy Island", "Solo City"},
    CurrentOption = {"Ninja Village"},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Option)
        AutoFarmConfig.SelectedWorlds = Option
        -- Update enemy dropdown based on selected worlds
        updateEnemyDropdown(Option)
    end
}, "WorldSelection")

-- Enemy dropdown (will be updated based on world selection)
local enemy_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select Enemies",
    Description = "Choose the enemies to farm",
    Options = getEnemyDisplayOptions({"unstoppable_fist", "copy_ninja", "awakened_dark_avenger", "awakened_promised_child", "six_paths_of_pain", "bijuu_beast"}),
    CurrentOption = {EnemyDisplayNames["unstoppable_fist"] .. " (unstoppable_fist)"},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Option)
        local selectedEnemies = {}
        for _, displayOption in ipairs(Option) do
            local enemyCode = getEnemyCodeFromDisplayOption(displayOption)
            if enemyCode then
                table.insert(selectedEnemies, enemyCode)
            end
        end
        AutoFarmConfig.SelectedEnemies = selectedEnemies
        AutoFarmConfig.CurrentEnemy = selectedEnemies[1] or "unstoppable_fist"
    end
}, "EnemySelection")

-- Function to update enemy dropdown based on world selection
function updateEnemyDropdown(worlds)
    local allEnemies = {}
    local enemyCodes = {}
    
    -- If no worlds selected, default to Ninja Village
    if #worlds == 0 then
        worlds = {"Ninja Village"}
    end
    
    for _, world in ipairs(worlds) do
        if world == "Ninja Village" then
            for _, enemy in ipairs({"unstoppable_fist", "copy_ninja", "awakened_dark_avenger", "awakened_promised_child", "six_paths_of_pain", "bijuu_beast"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Green Village" then
            for _, enemy in ipairs({"ultimate_warrior", "body_switcher", "namekian_sage", "awakened_prideful_prince", "awakened_earth_strongest", "awakened_galactic_tyrant"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Shibuya Station" then
            for _, enemy in ipairs({"cursed_doll", "awakened_shadow_summoner", "cursed_fist", "rika_blessing", "limitless_master", "king_of_curses"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Titans City" then
            for _, enemy in ipairs({"survey_commander", "blade_warrior", "armored_giant", "beast_giant", "blade_captain", "combat_giant"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Dimensional Fortress" then
            for _, enemy in ipairs({"thunder_demon", "childish_demon", "compass_demon", "awakened_frost_demon", "awakened_six_eyed_slayer", "awakened_pale_demon_lord"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Candy Island" then
            for _, enemy in ipairs({"genie_commander", "candy_master", "biscuit_warrior", "juice_queen", "mochi_emperor", "soul_queen"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Solo City" then
            for _, enemy in ipairs({"light_saintess", "the_goliath", "shadow_bear", "shadow_commander", "shadow_ant", "awakened_shadow_monarch"}) do
                enemyCodes[enemy] = true
            end
        end
    end
    
    -- Convert to array
    for enemyCode, _ in pairs(enemyCodes) do
        table.insert(allEnemies, enemyCode)
    end
    
    -- Get display options
    local displayOptions = getEnemyDisplayOptions(allEnemies)
    
    -- Update dropdown
    enemy_dropdown:Set({
        Options = displayOptions,
        CurrentOption = {displayOptions[1]}
    })
    
    -- Update selected enemies
    AutoFarmConfig.SelectedEnemies = {allEnemies[1] or "unstoppable_fist"}
    AutoFarmConfig.CurrentEnemy = allEnemies[1] or "unstoppable_fist"
end

TabAutoFarm:CreateDivider()
TabAutoFarm:CreateSection("World Bosses")

-- World Boss section (moved from Raid tab)
local world_boss_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select World Boss",
    Description = "Choose a world boss to battle",
    Options = {
        "Naruto Rage Mode (bijuu_beast)",
        "Frieza (awakened_galactic_tyrant)",
        "Sukuna (king_of_curses)",
        "Eren (combat_giant)",
        "Muzan (awakened_pale_demon_lord)",
        "Big Mom (soul_queen)",
        "Sung Jinwoo (awakened_shadow_monarch)"
    },
    CurrentOption = {"Naruto Rage Mode (bijuu_beast)"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        -- Nothing needed here, will be used in the button below
    end
}, "WorldBossSelection")

TabAutoFarm:CreateButton({
    Name = "Fight Selected Boss",
    Description = "Start a battle against the selected world boss",
    Callback = function()
        local boss = world_boss_dropdown.CurrentOption
        if type(boss) == "table" then
            boss = boss[1]
        end
        
        local bossCode = getEnemyCodeFromDisplayOption(boss)
        if bossCode then
            Utilities.SummonEnemy(bossCode)
        end
    end
})

TabAutoFarm:CreateDivider()
TabAutoFarm:CreateSection("Auto Farm Options")

-- Auto Farm All World Bosses toggle
local autofarm_all_bosses_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm All World Bosses",
    Description = "Automatically cycles through all world bosses",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoFarmAllWorldBosses = Value
        
        if Value then
            -- Start auto farm all bosses
            Utilities.DebugPrint("Auto Farm All World Bosses toggle activated")
            Utilities.Notify("Auto Farm", "Started auto farming all world bosses", "auto_mode")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoFarmAllBosses then
                Utilities.DebugPrint("Disconnecting previous Auto Farm All Bosses connection")
                AutoFarmConfig.Connections.AutoFarmAllBosses:Disconnect()
            end
            
            -- Create new auto farm loop
            Utilities.DebugPrint("Starting Auto Farm All Bosses loop for " .. #AutoFarmConfig.WorldBosses .. " bosses")
            AutoFarmConfig.Connections.AutoFarmAllBosses = spawn(function()
                local currentBossIndex = 1
                local currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex] or "bijuu_beast"
                
                while AutoFarmConfig.AutoFarmAllWorldBosses do
                    -- Check if we need to update the current boss (for bosses not on cooldown)
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Try to find a boss that's not on cooldown
                        local allOnCooldown = true
                        local startingIndex = currentBossIndex
                        
                        for i = 1, #AutoFarmConfig.WorldBosses do
                            -- Calculate the next boss index with wrap-around
                            local nextIndex = (startingIndex + i - 1) % #AutoFarmConfig.WorldBosses + 1
                            local nextBoss = AutoFarmConfig.WorldBosses[nextIndex]
                            
                            -- Check if this boss is on cooldown
                            local currentTime = os.time()
                            if not AutoFarmConfig.EnemyCooldowns[nextBoss] or AutoFarmConfig.EnemyCooldowns[nextBoss] <= currentTime then
                                currentBossIndex = nextIndex
                                currentBoss = nextBoss
                                allOnCooldown = false
                                break
                            end
                        end
                        
                        if allOnCooldown then
                            -- All bosses are on cooldown, find the one with the shortest remaining cooldown
                            local shortestCooldown = math.huge
                            local shortestIndex = 1
                            
                            for i = 1, #AutoFarmConfig.WorldBosses do
                                local boss = AutoFarmConfig.WorldBosses[i]
                                local remainingCooldown = (AutoFarmConfig.EnemyCooldowns[boss] or 0) - currentTime
                                
                                if remainingCooldown < shortestCooldown then
                                    shortestCooldown = remainingCooldown
                                    shortestIndex = i
                                end
                            end
                            
                            currentBossIndex = shortestIndex
                            currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex]
                            
                            Utilities.DebugPrint("All bosses on cooldown. Waiting for " .. currentBoss .. " (shortest cooldown: " .. math.max(0, shortestCooldown) .. " seconds)")
                            wait(math.min(5, math.max(1, shortestCooldown))) -- Wait at least 1 second, at most 5 seconds
                        else
                            -- Try to start battle with current boss (which is not on cooldown)
                            Utilities.DebugPrint("Attempting to start battle with boss: " .. tostring(currentBoss))
                            Utilities.StartNextBattle(currentBoss)
                        end
                    elseif Utilities.IsInBattle() then
                        Utilities.DebugPrint("Currently in boss battle with " .. currentBoss .. ", waiting...")
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DebugPrint("Boss battle ended with " .. currentBoss .. ", dismissing end screen")
                        Utilities.DismissBattleEnd()
                        
                        -- Once battle is dismissed, mark the boss as defeated and move to next
                        if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(currentBoss)
                            
                            -- Move to next boss for next iteration
                            currentBossIndex = currentBossIndex % #AutoFarmConfig.WorldBosses + 1
                            currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex]
                        end
                    end
                    
                    -- Wait 1 second before next check
                    wait(1)
                end
            end)
        else
            -- Stop auto farm all bosses
            Utilities.DebugPrint("Auto Farm All World Bosses toggle deactivated")
            Utilities.Notify("Auto Farm", "Stopped auto farming all world bosses", "stop_circle")
            
            -- Disconnect auto farm loop
            if AutoFarmConfig.Connections.AutoFarmAllBosses then
                Utilities.DebugPrint("Disconnecting Auto Farm All Bosses loop")
                AutoFarmConfig.Connections.AutoFarmAllBosses:Disconnect()
                AutoFarmConfig.Connections.AutoFarmAllBosses = nil
            end
        end
    end
}, "AutoFarmAllBossesToggle")

-- Auto Farm All Enemies in Selected Worlds toggle
local autofarm_all_enemies_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm All Enemies",
    Description = "Automatically cycles through all enemies in order from all worlds",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoFarmAllEnemiesInSelectedWorlds = Value
        
        if Value then
            -- Start auto farm all enemies
            Utilities.DebugPrint("Auto Farm All Enemies toggle activated")
            Utilities.Notify("Auto Farm", "Started auto farming all enemies in order", "auto_mode")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoFarmAllEnemies then
                Utilities.DebugPrint("Disconnecting previous Auto Farm All Enemies connection")
                AutoFarmConfig.Connections.AutoFarmAllEnemies:Disconnect()
            end
            
            -- Create new auto farm loop
            Utilities.DebugPrint("Starting Auto Farm All Enemies loop for " .. #AutoFarmConfig.AllEnemies .. " enemies")
            AutoFarmConfig.Connections.AutoFarmAllEnemies = spawn(function()
                local currentEnemyIndex = 1
                local currentEnemy = AutoFarmConfig.AllEnemies[currentEnemyIndex] or "unstoppable_fist"
                
                while AutoFarmConfig.AutoFarmAllEnemiesInSelectedWorlds do
                    -- Check if we can start a battle
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Try to find an enemy that's not on cooldown
                        local allOnCooldown = true
                        local startingIndex = currentEnemyIndex
                        
                        for i = 1, #AutoFarmConfig.AllEnemies do
                            -- Calculate the next enemy index with wrap-around
                            local nextIndex = (startingIndex + i - 1) % #AutoFarmConfig.AllEnemies + 1
                            local nextEnemy = AutoFarmConfig.AllEnemies[nextIndex]
                            
                            -- Check if this enemy is on cooldown
                            local currentTime = os.time()
                            if not AutoFarmConfig.EnemyCooldowns[nextEnemy] or AutoFarmConfig.EnemyCooldowns[nextEnemy] <= currentTime then
                                currentEnemyIndex = nextIndex
                                currentEnemy = nextEnemy
                                allOnCooldown = false
                                break
                            end
                        end
                        
                        if allOnCooldown then
                            -- All enemies are on cooldown, find the one with the shortest remaining cooldown
                            local shortestCooldown = math.huge
                            local shortestIndex = 1
                            
                            for i = 1, #AutoFarmConfig.AllEnemies do
                                local enemy = AutoFarmConfig.AllEnemies[i]
                                local remainingCooldown = (AutoFarmConfig.EnemyCooldowns[enemy] or 0) - currentTime
                                
                                if remainingCooldown < shortestCooldown then
                                    shortestCooldown = remainingCooldown
                                    shortestIndex = i
                                end
                            end
                            
                            currentEnemyIndex = shortestIndex
                            currentEnemy = AutoFarmConfig.AllEnemies[currentEnemyIndex]
                            
                            Utilities.DebugPrint("All enemies on cooldown. Waiting for " .. currentEnemy .. " (shortest cooldown: " .. math.max(0, shortestCooldown) .. " seconds)")
                            wait(math.min(5, math.max(1, shortestCooldown))) -- Wait at least 1 second, at most 5 seconds
                        else
                            -- Try to start battle with current enemy (which is not on cooldown)
                            Utilities.DebugPrint("Attempting to start battle with: " .. tostring(currentEnemy))
                            Utilities.StartNextBattle(currentEnemy)
                        end
                    elseif Utilities.IsInBattle() then
                        Utilities.DebugPrint("Currently in battle with " .. currentEnemy .. ", waiting...")
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DebugPrint("Battle ended with " .. currentEnemy .. ", dismissing end screen")
                        Utilities.DismissBattleEnd()
                        
                        -- Once battle is dismissed, mark the enemy as defeated and move to next
                        if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(currentEnemy)
                            
                            -- Move to next enemy for next iteration (always move in sequence)
                            currentEnemyIndex = currentEnemyIndex % #AutoFarmConfig.AllEnemies + 1
                            currentEnemy = AutoFarmConfig.AllEnemies[currentEnemyIndex]
                        end
                    end
                    
                    -- Wait 1 second before next check
                    wait(1)
                end
            end)
        else
            -- Stop auto farm all enemies
            Utilities.DebugPrint("Auto Farm All Enemies toggle deactivated")
            Utilities.Notify("Auto Farm", "Stopped auto farming all enemies", "stop_circle")
            
            -- Disconnect auto farm loop
            if AutoFarmConfig.Connections.AutoFarmAllEnemies then
                Utilities.DebugPrint("Disconnecting Auto Farm All Enemies loop")
                AutoFarmConfig.Connections.AutoFarmAllEnemies:Disconnect()
                AutoFarmConfig.Connections.AutoFarmAllEnemies = nil
            end
        end
    end
}, "AutoFarmAllEnemiesToggle")

-- Auto Farm Toggle
local autofarm_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm Selected Enemy",
    Description = "Automatically spawns the currently selected enemy after cooldown",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.Enabled = Value
        
        if Value then
            -- Start auto farm
            Utilities.DebugPrint("Auto Farm toggle activated for enemy: " .. tostring(AutoFarmConfig.CurrentEnemy))
            Utilities.Notify("Auto Farm", "Started auto farming " .. AutoFarmConfig.CurrentEnemy .. " in " .. table.concat(AutoFarmConfig.SelectedWorlds, ", "), "auto_mode")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoFarm then
                Utilities.DebugPrint("Disconnecting previous Auto Farm connection")
                AutoFarmConfig.Connections.AutoFarm:Disconnect()
            end
            
            -- Create new auto farm loop
            Utilities.DebugPrint("Starting Auto Farm loop")
            AutoFarmConfig.Connections.AutoFarm = spawn(function()
                while AutoFarmConfig.Enabled do
                    Utilities.DebugPrint("Auto Farm loop iteration for enemy: " .. tostring(AutoFarmConfig.CurrentEnemy))
                    
                    -- Stellen wir sicher, dass EnemyCooldowns existiert
                    Utilities.EnsureEnemyCooldownsInitialized()
                    
                    -- Check if we can start a battle (not in battle, not at battle end, and enemy not on cooldown)
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Check if enemy is on cooldown
                        local currentTime = os.time()
                        if AutoFarmConfig.CurrentEnemy and AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] and AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] > currentTime then
                            local remainingCooldown = math.ceil(AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] - currentTime)
                            Utilities.DebugPrint("Current enemy still on cooldown for " .. remainingCooldown .. " seconds")
                        else
                            -- Try to start a battle with current enemy
                            Utilities.DebugPrint("Attempting to start battle with: " .. tostring(AutoFarmConfig.CurrentEnemy))
                            Utilities.StartNextBattle(AutoFarmConfig.CurrentEnemy)
                        end
                    elseif Utilities.IsInBattle() then
                        Utilities.DebugPrint("Currently in battle, waiting...")
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DebugPrint("Battle ended, attempting to dismiss end screen")
                        Utilities.DismissBattleEnd()
                        
                        -- Once battle is dismissed, mark the enemy as defeated
                        if AutoFarmConfig.CurrentEnemy and not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(AutoFarmConfig.CurrentEnemy)
                        end
                    end
                    
                    -- Wait 1 second before next check
                    wait(1)
                end
            end)
        else
            -- Stop auto farm
            Utilities.DebugPrint("Auto Farm toggle deactivated")
            Utilities.Notify("Auto Farm", "Stopped auto farming", "stop_circle")
            
            -- Disconnect auto farm loop
            if AutoFarmConfig.Connections.AutoFarm then
                Utilities.DebugPrint("Disconnecting Auto Farm loop")
                AutoFarmConfig.Connections.AutoFarm:Disconnect()
                AutoFarmConfig.Connections.AutoFarm = nil
            end
        end
    end
}, "AutoFarmToggle")

-- Auto collect loop ändern (langsamerer Tween)
local autocollect_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Collect Items",
    Description = "Automatically collects dropped items",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoCollect = Value
        
        if Value then
            -- Start auto collect
            Utilities.Notify("Auto Collect", "Started auto collecting items", "inventory_2")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoCollect then
                AutoFarmConfig.Connections.AutoCollect:Disconnect()
            end
            
            -- Create new auto collect loop
            AutoFarmConfig.Connections.AutoCollect = spawn(function()
                while AutoFarmConfig.AutoCollect do
                    pcall(function()
                        local items = workspace.Folder:GetChildren()
                        
                        for _, item in pairs(items) do
                            if item:IsA("Model") and AutoFarmConfig.AutoCollect then
                                -- Get item position
                                local itemPosition = item:GetPivot().Position
                                
                                -- Get player's character and humanoid root part
                                local character = Utilities.GetLocalPlayer().Character
                                if character and character:FindFirstChild("HumanoidRootPart") then
                                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                                    
                                    -- Tween to the item (langsamerer Tween: 2.0 statt 0.5 Sekunden)
                                    local tweenService = game:GetService("TweenService")
                                    local tweenInfo = TweenInfo.new(2.0, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                                    
                                    local tween = tweenService:Create(
                                        humanoidRootPart,
                                        tweenInfo,
                                        {CFrame = CFrame.new(itemPosition)}
                                    )
                                    
                                    tween:Play()
                                    tween.Completed:Wait()
                                    
                                    -- Wait a bit to ensure item is collected
                                    wait(0.5)
                                end
                            end
                        end
                    end)
                    
                    wait(1) -- Wait before checking for new items
                end
            end)
        else
            -- Stop auto collect
            Utilities.Notify("Auto Collect", "Stopped auto collecting items", "stop_circle")
            
            -- Disconnect auto collect loop
            if AutoFarmConfig.Connections.AutoCollect then
                AutoFarmConfig.Connections.AutoCollect:Disconnect()
                AutoFarmConfig.Connections.AutoCollect = nil
            end
        end
    end
}, "AutoCollectToggle")

-- Auto merge toggle
local automerge_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Merge Units",
    Description = "Automatically merges your units",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoMerge = Value
        
        if Value then
            -- Start auto merge
            Utilities.Notify("Auto Merge", "Started auto merging units", "merge")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoMerge then
                AutoFarmConfig.Connections.AutoMerge:Disconnect()
            end
            
            -- Create new auto merge loop
            AutoFarmConfig.Connections.AutoMerge = spawn(function()
                while AutoFarmConfig.AutoMerge do
                    pcall(function()
                        -- Example auto merge code
                        local args = {
                            [1] = 0,
                            [2] = "light_admiral",
                            [3] = 200,
                            [4] = false
                        }
                        
                        game:GetService("ReplicatedStorage"):WaitForChild("noV"):WaitForChild("b57b2bf9-5561-408a-8668-8d7afa1b05f0"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Wait before attempting to merge again
                end
            end)
        else
            -- Stop auto merge
            Utilities.Notify("Auto Merge", "Stopped auto merging units", "stop_circle")
            
            -- Disconnect auto merge loop
            if AutoFarmConfig.Connections.AutoMerge then
                AutoFarmConfig.Connections.AutoMerge:Disconnect()
                AutoFarmConfig.Connections.AutoMerge = nil
            end
        end
    end
}, "AutoMergeToggle")

-- Towers Tab
TabTowers:CreateSection("Battle Tower")

-- Battle Tower level display
local battle_tower_level = TabTowers:CreateLabel({
    Text = "Current Battle Tower Level: " .. Utilities.GetBattleTowerLevel(),
    Style = 1
})

-- Update Battle Tower level periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            battle_tower_level:Set({
                Text = "Current Battle Tower Level: " .. Utilities.GetBattleTowerLevel()
            })
        end
    end
end)

-- Tower Level Config
local TowerConfig = {
    BattleTowerLevel = 1,
    AutoContinuousLevel = false,
    AutoHighestLevel = false,
    Connections = {}
}

-- Battle Tower Level Dropdown instead of Input
local battle_tower_dropdown = TabTowers:CreateDropdown({
    Name = "Select Battle Tower Level",
    Description = "Choose a Tower Level (1-100)",
    Options = {"1", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50", 
               "55", "60", "65", "70", "75", "80", "85", "90", "95", "100"},
    CurrentOption = {"1"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        local level = tonumber(Option[1])
        if level then
            TowerConfig.BattleTowerLevel = level
        end
    end
}, "BattleTowerLevelDropdown")

-- Button to start the selected level
TabTowers:CreateButton({
    Name = "Start Battle Tower Level Once",
    Description = "Start the selected Battle Tower level",
    Callback = function()
        local level = TowerConfig.BattleTowerLevel
        
        if level and level >= 1 and level <= 100 then
            local args = {
                [1] = level
            }
            
            local success, result = pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("c1438c4a-417f-41ee-9363-1ebabcc0bbd9"):FireServer(unpack(args))
            end)
            
            if success then
                Utilities.Notify("Battle Tower", "Battle Tower started at level " .. level, "castle")
            else
                Utilities.Notify("Error", "Failed to start Battle Tower", "error")
            end
        else
            Utilities.Notify("Error", "Please select a valid level between 1 and 100", "error")
        end
    end
})

-- Toggle for continuous level
local continuous_tower_toggle = TabTowers:CreateToggle({
    Name = "Auto Continuous Battle Tower",
    Description = "Continuously starts the selected Battle Tower level",
    CurrentValue = false,
    Callback = function(Value)
        TowerConfig.AutoContinuousLevel = Value
        
        if Value then
            -- Activate auto continuous level
            Utilities.Notify("Battle Tower", "Auto Continuous Battle Tower activated for level " .. TowerConfig.BattleTowerLevel, "castle")
            
            -- Remove previous connections
            if TowerConfig.Connections.AutoContinuous then
                TowerConfig.Connections.AutoContinuous:Disconnect()
            end
            
            -- Create new auto continuous loop
            TowerConfig.Connections.AutoContinuous = spawn(function()
                while TowerConfig.AutoContinuousLevel do
                    -- Only start Battle Tower if we're not in a battle
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local args = {
                            [1] = TowerConfig.BattleTowerLevel
                        }
                        
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("c1438c4a-417f-41ee-9363-1ebabcc0bbd9"):FireServer(unpack(args))
                        end)
                        
                        Utilities.DebugPrint("Auto Continuous Battle Tower - Level " .. TowerConfig.BattleTowerLevel .. " started")
                    end
                    
                    wait(5) -- Check every 5 seconds
                end
            end)
        else
            -- Deactivate auto continuous level
            Utilities.Notify("Battle Tower", "Auto Continuous Battle Tower deactivated", "stop_circle")
            
            -- End loop
            if TowerConfig.Connections.AutoContinuous then
                TowerConfig.Connections.AutoContinuous:Disconnect()
                TowerConfig.Connections.AutoContinuous = nil
            end
        end
    end
}, "AutoContinuousTowerToggle")

-- Toggle for automatic highest level
local highest_tower_toggle = TabTowers:CreateToggle({
    Name = "Auto Highest Battle Tower",
    Description = "Automatically starts the highest possible Battle Tower level",
    CurrentValue = false,
    Callback = function(Value)
        TowerConfig.AutoHighestLevel = Value
        
        if Value then
            -- Activate auto highest level
            Utilities.Notify("Battle Tower", "Auto Highest Battle Tower activated", "castle")
            
            -- Remove previous connections
            if TowerConfig.Connections.AutoHighest then
                TowerConfig.Connections.AutoHighest:Disconnect()
            end
            
            -- Create new auto highest loop
            TowerConfig.Connections.AutoHighest = spawn(function()
                while TowerConfig.AutoHighestLevel do
                    -- Only start Battle Tower if we're not in a battle
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local currentLevel = Utilities.GetBattleTowerLevel()
                        
                        local args = {
                            [1] = currentLevel
                        }
                        
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("c1438c4a-417f-41ee-9363-1ebabcc0bbd9"):FireServer(unpack(args))
                        end)
                        
                        Utilities.DebugPrint("Auto Highest Battle Tower - Level " .. currentLevel .. " started")
                    end
                    
                    wait(5) -- Check every 5 seconds
                end
            end)
        else
            -- Deactivate auto highest level
            Utilities.Notify("Battle Tower", "Auto Highest Battle Tower deactivated", "stop_circle")
            
            -- End loop
            if TowerConfig.Connections.AutoHighest then
                TowerConfig.Connections.AutoHighest:Disconnect()
                TowerConfig.Connections.AutoHighest = nil
            end
        end
    end
}, "AutoHighestTowerToggle")

-- Infinite Tower Tab
TabTowers:CreateSection("Infinite Tower")

-- Infinite Tower floor display
local infinite_tower_floor = TabTowers:CreateLabel({
    Text = "Current Infinite Tower Floor: " .. Utilities.GetInfiniteTowerFloor(),
    Style = 1
})

-- Update Infinite Tower floor periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            infinite_tower_floor:Set({
                Text = "Current Infinite Tower Floor: " .. Utilities.GetInfiniteTowerFloor()
            })
        end
    end
end)

-- Infinite Tower control buttons
TabTowers:CreateButton({
    Name = "Start Infinite Tower",
    Description = "Begin the Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("888b9aa0-9ca6-4c77-9946-cebf1edf613d"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Started Infinite Tower challenge", "castle")
        else
            Utilities.Notify("Error", "Failed to start Infinite Tower", "error")
        end
    end
})

TabTowers:CreateButton({
    Name = "Pause Infinite Tower",
    Description = "Pause the current Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("a8a25480-c0f3-426b-834f-0f95cf058edc"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Paused Infinite Tower challenge", "pause")
        else
            Utilities.Notify("Error", "Failed to pause Infinite Tower", "error")
        end
    end
})

TabTowers:CreateButton({
    Name = "End Infinite Tower",
    Description = "End the current Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("179a96b5-b8d2-4156-a939-6f34c92aa7a6"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Ended Infinite Tower challenge", "stop_circle")
        else
            Utilities.Notify("Error", "Failed to end Infinite Tower", "error")
        end
    end
})

-- Raids Tab
TabRaids:CreateSection("Raid Management")

TabRaids:CreateParagraph({
    Title = "Raid Information",
    Text = "Raids offer exclusive rewards and powerful units. You can start a raid against the Eternal Dragon or other powerful bosses."
})

-- Auto Raid Configuration
local RaidConfig = {
    AutoSummonEternalDragon = false,
    Connections = {}
}

-- Auto Summon Eternal Dragon toggle
local auto_summon_dragon_toggle = TabRaids:CreateToggle({
    Name = "Auto Fight Eternal Dragon",
    Description = "Automatically fights the Eternal Dragon at regular intervals",
    CurrentValue = false,
    Callback = function(Value)
        RaidConfig.AutoSummonEternalDragon = Value
        
        if Value then
            -- Start auto summon
            Utilities.Notify("Auto Raid", "Started auto fighting Eternal Dragon", "security")
            
            -- Clear previous connections if any
            if RaidConfig.Connections.AutoSummonDragon then
                Utilities.DebugPrint("Disconnecting previous Auto Summon Dragon connection")
                RaidConfig.Connections.AutoSummonDragon:Disconnect()
            end
            
            -- Create new auto summon loop
            RaidConfig.Connections.AutoSummonDragon = spawn(function()
                while RaidConfig.AutoSummonEternalDragon do
                    -- Check if we're in battle or at battle end screen
                    if Utilities.IsInBattle() then
                        Utilities.DebugPrint("Currently in Eternal Dragon battle, waiting...")
                        wait(2) -- Check less frequently during battle
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DebugPrint("Eternal Dragon battle ended, dismissing end screen")
                        Utilities.DismissBattleEnd()
                        wait(1) -- Wait for the dismiss to complete
                    else
                        -- Not in battle and not at end screen, try to start a new raid
                        Utilities.DebugPrint("Attempting to start Eternal Dragon raid")
                        pcall(function()
                            local args = {
                                [1] = "eternal_dragon"
                            }
                            
                            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("9f262bf4-f76a-4916-94dc-46596cc25770"):FireServer(unpack(args))
                        end)
                        wait(3) -- Wait a bit to see if battle starts
                    end
                    
                    -- Short wait between checks regardless of outcome
                    wait(1)
                end
            end)
        else
            -- Stop auto summon
            Utilities.Notify("Auto Raid", "Stopped auto fighting Eternal Dragon", "stop_circle")
            
            -- Disconnect auto summon loop
            if RaidConfig.Connections.AutoSummonDragon then
                Utilities.DebugPrint("Disconnecting Auto Summon Dragon loop")
                RaidConfig.Connections.AutoSummonDragon:Disconnect()
                RaidConfig.Connections.AutoSummonDragon = nil
            end
        end
    end
}, "AutoSummonDragonToggle")

TabRaids:CreateButton({
    Name = "Fight Eternal Dragon Once",
    Description = "Start a raid against the Eternal Dragon immediately",
    Callback = function()
        local success, result = pcall(function()
            local args = {
                [1] = "eternal_dragon"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("9f262bf4-f76a-4916-94dc-46596cc25770"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Raid Started", "Successfully started fight with Eternal Dragon", "security")
        else
            Utilities.Notify("Error", "Failed to start raid", "error")
        end
    end
})

-- Exploration Tab
TabExploration:CreateSection("Exploration Management")

-- Exploration team configuration
local exploration_difficulty = TabExploration:CreateDropdown({
    Name = "Exploration Difficulty",
    Description = "Select the difficulty level for exploration",
    Options = {"easy", "medium", "hard"},
    CurrentOption = {"easy"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        -- Nothing needed here, will be used in other functions
    end
}, "ExploreDifficulty")

-- Unit selection for exploration
local exploration_units = TabExploration:CreateInput({
    Name = "Exploration Units",
    Description = "Enter 4 unit names separated by commas",
    PlaceholderText = "e.g., dark_avenger,black_swordsman,dark_avenger,dark_avenger",
    CurrentValue = "dark_avenger,black_swordsman,dark_avenger,dark_avenger",
    Numeric = false,
    MaxCharacters = 100,
    Enter = false,
    Callback = function(Text)
        -- Nothing needed here, will be used in the deploy button
    end
}, "ExploreUnits")

TabExploration:CreateButton({
    Name = "Deploy Exploration Team",
    Description = "Send your selected units on an exploration mission",
    Callback = function()
        local difficulty = exploration_difficulty.CurrentOption
        if type(difficulty) == "table" then
            difficulty = difficulty[1]
        end
        
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = difficulty,
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("569ba6a6-d5ea-488e-b729-0f0b6dbaf40c"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for " .. difficulty .. " exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

TabExploration:CreateDivider()

TabExploration:CreateSection("Claim Rewards")

-- Exploration Claim Config
local ExplorationConfig = {
    AutoClaimEasy = false,
    AutoClaimMedium = false,
    AutoClaimHard = false,
    Connections = {}
}

-- Auto Claim Easy Toggle
local auto_claim_easy_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Easy Exploration Rewards",
    Description = "Automatically claims rewards from easy difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimEasy = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Easy Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimEasy then
                ExplorationConfig.Connections.AutoClaimEasy:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimEasy = spawn(function()
                while ExplorationConfig.AutoClaimEasy do
                    local args = {
                        [1] = "easy"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("e54723ed-0747-47de-9a09-3153dfb2acd7"):FireServer(unpack(args))
                    end)
                    
                    Utilities.DebugPrint("Auto Claiming Easy Exploration Rewards")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Easy Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimEasy then
                ExplorationConfig.Connections.AutoClaimEasy:Disconnect()
                ExplorationConfig.Connections.AutoClaimEasy = nil
            end
        end
    end
}, "AutoClaimEasyToggle")

-- Auto Claim Medium Toggle
local auto_claim_medium_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Medium Exploration Rewards",
    Description = "Automatically claims rewards from medium difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimMedium = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Medium Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimMedium then
                ExplorationConfig.Connections.AutoClaimMedium:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimMedium = spawn(function()
                while ExplorationConfig.AutoClaimMedium do
                    local args = {
                        [1] = "medium"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("e54723ed-0747-47de-9a09-3153dfb2acd7"):FireServer(unpack(args))
                    end)
                    
                    Utilities.DebugPrint("Auto Claiming Medium Exploration Rewards")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Medium Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimMedium then
                ExplorationConfig.Connections.AutoClaimMedium:Disconnect()
                ExplorationConfig.Connections.AutoClaimMedium = nil
            end
        end
    end
}, "AutoClaimMediumToggle")

-- Auto Claim Hard Toggle
local auto_claim_hard_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Hard Exploration Rewards",
    Description = "Automatically claims rewards from hard difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimHard = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Hard Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimHard then
                ExplorationConfig.Connections.AutoClaimHard:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimHard = spawn(function()
                while ExplorationConfig.AutoClaimHard do
                    local args = {
                        [1] = "hard"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("e54723ed-0747-47de-9a09-3153dfb2acd7"):FireServer(unpack(args))
                    end)
                    
                    Utilities.DebugPrint("Auto Claiming Hard Exploration Rewards")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Hard Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimHard then
                ExplorationConfig.Connections.AutoClaimHard:Disconnect()
                ExplorationConfig.Connections.AutoClaimHard = nil
            end
        end
    end
}, "AutoClaimHardToggle")

-- Shop Tab
TabShop:CreateSection("Shop Management")

TabShop:CreateParagraph({
    Title = "Shop Information",
    Text = "Purchase various items from the shop to enhance your gameplay experience."
})

-- Shop items
TabShop:CreateButton({
    Name = "Buy Luck Potion (Small)",
    Description = "Purchase a small luck potion",
    Callback = function()
        Utilities.BuyShopItem("small_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Luck Potion (Medium)",
    Description = "Purchase a medium luck potion",
    Callback = function()
        Utilities.BuyShopItem("medium_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Luck Potion (Large)",
    Description = "Purchase a large luck potion",
    Callback = function()
        Utilities.BuyShopItem("large_luck_potion", 1)
    end
})

TabShop:CreateDivider()

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Small)",
    Description = "Purchase a small cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("small_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Medium)",
    Description = "Purchase a medium cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("medium_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Large)",
    Description = "Purchase a large cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("large_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateDivider()

TabShop:CreateButton({
    Name = "Buy Raid Luck Potion",
    Description = "Purchase a raid luck potion",
    Callback = function()
        Utilities.BuyShopItem("raid_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Border Chance Potion",
    Description = "Purchase a raid border chance potion",
    Callback = function()
        Utilities.BuyShopItem("raid_border_chance_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Cooldown Potion",
    Description = "Purchase a raid cooldown potion",
    Callback = function()
        Utilities.BuyShopItem("raid_cooldown_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Boss Chance Potion",
    Description = "Purchase a raid boss chance potion",
    Callback = function()
        Utilities.BuyShopItem("raid_boss_chance_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Moon Cycle Reroll Potion",
    Description = "Purchase a raid moon cycle reroll potion",
    Callback = function()
        Utilities.BuyShopItem("raid_moon_cycle_reroll_potion", 1)
    end
})

-- Misc Tab
TabMisc:CreateSection("Miscellaneous Features")

-- BillboardGui text modification (Hide Name feature)
local NameHideConfig = {
    Enabled = false,
    OriginalTexts = {},
    OriginalColors = {}
}

-- Function to toggle name hiding
Utilities.ToggleNameHide = function(value)
    NameHideConfig.Enabled = value
    
    if value then
        -- Save original values first (only if not already saved)
        if #NameHideConfig.OriginalTexts == 0 then
            pcall(function()
                -- First TextLabel (which will be changed to "JOIN DC")
                local joinLabel = workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2]
                if joinLabel and joinLabel:IsA("TextLabel") then
                    NameHideConfig.OriginalTexts[joinLabel] = joinLabel.Text
                    NameHideConfig.OriginalColors[joinLabel] = joinLabel.TextColor3
                    
                    -- Change to "JOIN DC" in white
                    joinLabel.Text = "JOIN DC"
                    joinLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- White
                end
                
                -- Second TextLabel (which will be changed to "MYTHHUB")
                local mythLabel = workspace.rswhshj.Head.BillboardGui.Frame.TextLabel
                if mythLabel and mythLabel:IsA("TextLabel") then
                    NameHideConfig.OriginalTexts[mythLabel] = mythLabel.Text
                    NameHideConfig.OriginalColors[mythLabel] = mythLabel.TextColor3
                    
                    -- Change to "MYTHHUB" in #11189D (dark blue)
                    mythLabel.Text = "MYTHHUB"
                    mythLabel.TextColor3 = Color3.fromRGB(17, 24, 157) -- #11189D in RGB
                end
                
                Utilities.DebugPrint("Name hide enabled, texts changed")
            end)
        else
            -- Apply saved changes (in case they were reverted)
            pcall(function()
                workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2].Text = "JOIN DC"
                workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2].TextColor3 = Color3.fromRGB(255, 255, 255)
                
                workspace.rswhshj.Head.BillboardGui.Frame.TextLabel.Text = "MYTHHUB"
                workspace.rswhshj.Head.BillboardGui.Frame.TextLabel.TextColor3 = Color3.fromRGB(17, 24, 157)
                
                Utilities.DebugPrint("Name hide re-enabled, texts restored to hidden values")
            end)
        end
    else
        -- Restore original values
        for label, originalText in pairs(NameHideConfig.OriginalTexts) do
            pcall(function()
                label.Text = originalText
                label.TextColor3 = NameHideConfig.OriginalColors[label]
            end)
        end
        Utilities.DebugPrint("Name hide disabled, restored original text")
    end
end

-- Add Hide Name toggle
local hide_name_toggle = TabMisc:CreateToggle({
    Name = "Hide Name",
    Description = "Replaces the name with MYTHHUB and JOIN DC text",
    CurrentValue = false,
    Callback = function(Value)
        Utilities.ToggleNameHide(Value)
        
        if Value then
            Utilities.Notify("Name Hider", "Name hidden with custom text", "person")
        else
            Utilities.Notify("Name Hider", "Original name restored", "person")
        end
    end
}, "HideNameToggle")

-- Enemy Cooldown Display
TabMisc:CreateSection("Enemy Cooldown Information")

local enemy_cooldown_info = TabMisc:CreateParagraph({
    Title = "Enemy Cooldown",
    Text = "All enemies have a 10-minute cooldown after defeating them, including bosses."
})

-- Stats upgrade section
TabMisc:CreateSection("Stats Upgrade")

-- Auto Stats Configuration
local AutoStatsConfig = {
    AutoUpgradeLuck = false,
    AutoUpgradeCooldownReduction = false,
    AutoUpgradePotionDuration = false,
    AutoUpgradeBorderChance = false,
    AutoUpgradeBossChance = false,
    Connections = {}
}

-- Auto Upgrade Luck toggle
local auto_upgrade_luck_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Luck",
    Description = "Automatically upgrades your luck stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeLuck = Value
        
        if Value then
            -- Start auto upgrade
            Utilities.Notify("Auto Stats", "Started auto upgrading Luck stat", "trending_up")
            
            -- Clear previous connections if any
            if AutoStatsConfig.Connections.AutoUpgradeLuck then
                AutoStatsConfig.Connections.AutoUpgradeLuck:Disconnect()
            end
            
            -- Create new auto upgrade loop
            AutoStatsConfig.Connections.AutoUpgradeLuck = spawn(function()
                while AutoStatsConfig.AutoUpgradeLuck do
                    Utilities.UpgradeStat("LUCK")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Stop auto upgrade
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Luck stat", "stop_circle")
            
            -- Disconnect auto upgrade loop
            if AutoStatsConfig.Connections.AutoUpgradeLuck then
                AutoStatsConfig.Connections.AutoUpgradeLuck:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeLuck = nil
            end
        end
    end
}, "AutoUpgradeLuckToggle")

-- Auto Upgrade Cooldown Reduction toggle
local auto_upgrade_cooldown_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Cooldown Reduction",
    Description = "Automatically upgrades your cooldown reduction stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeCooldownReduction = Value
        
        if Value then
            -- Start auto upgrade
            Utilities.Notify("Auto Stats", "Started auto upgrading Cooldown Reduction stat", "trending_up")
            
            -- Clear previous connections if any
            if AutoStatsConfig.Connections.AutoUpgradeCooldownReduction then
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction:Disconnect()
            end
            
            -- Create new auto upgrade loop
            AutoStatsConfig.Connections.AutoUpgradeCooldownReduction = spawn(function()
                while AutoStatsConfig.AutoUpgradeCooldownReduction do
                    Utilities.UpgradeStat("COOLDOWN_REDUCTION")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Stop auto upgrade
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Cooldown Reduction stat", "stop_circle")
            
            -- Disconnect auto upgrade loop
            if AutoStatsConfig.Connections.AutoUpgradeCooldownReduction then
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction = nil
            end
        end
    end
}, "AutoUpgradeCooldownToggle")

-- Auto Upgrade Potion Duration toggle
local auto_upgrade_potion_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Potion Duration",
    Description = "Automatically upgrades your potion duration stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradePotionDuration = Value
        
        if Value then
            -- Start auto upgrade
            Utilities.Notify("Auto Stats", "Started auto upgrading Potion Duration stat", "trending_up")
            
            -- Clear previous connections if any
            if AutoStatsConfig.Connections.AutoUpgradePotionDuration then
                AutoStatsConfig.Connections.AutoUpgradePotionDuration:Disconnect()
            end
            
            -- Create new auto upgrade loop
            AutoStatsConfig.Connections.AutoUpgradePotionDuration = spawn(function()
                while AutoStatsConfig.AutoUpgradePotionDuration do
                    Utilities.UpgradeStat("POTION_DURATION")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Stop auto upgrade
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Potion Duration stat", "stop_circle")
            
            -- Disconnect auto upgrade loop
            if AutoStatsConfig.Connections.AutoUpgradePotionDuration then
                AutoStatsConfig.Connections.AutoUpgradePotionDuration:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradePotionDuration = nil
            end
        end
    end
}, "AutoUpgradePotionToggle")

-- Auto Upgrade Border Chance toggle
local auto_upgrade_border_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Border Chance",
    Description = "Automatically upgrades your border chance stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeBorderChance = Value
        
        if Value then
            -- Start auto upgrade
            Utilities.Notify("Auto Stats", "Started auto upgrading Border Chance stat", "trending_up")
            
            -- Clear previous connections if any
            if AutoStatsConfig.Connections.AutoUpgradeBorderChance then
                AutoStatsConfig.Connections.AutoUpgradeBorderChance:Disconnect()
            end
            
            -- Create new auto upgrade loop
            AutoStatsConfig.Connections.AutoUpgradeBorderChance = spawn(function()
                while AutoStatsConfig.AutoUpgradeBorderChance do
                    Utilities.UpgradeStat("BORDER_CHANCE")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Stop auto upgrade
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Border Chance stat", "stop_circle")
            
            -- Disconnect auto upgrade loop
            if AutoStatsConfig.Connections.AutoUpgradeBorderChance then
                AutoStatsConfig.Connections.AutoUpgradeBorderChance:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeBorderChance = nil
            end
        end
    end
}, "AutoUpgradeBorderToggle")

-- Auto Upgrade Boss Chance toggle
local auto_upgrade_boss_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Boss Chance",
    Description = "Automatically upgrades your boss chance stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeBossChance = Value
        
        if Value then
            -- Start auto upgrade
            Utilities.Notify("Auto Stats", "Started auto upgrading Boss Chance stat", "trending_up")
            
            -- Clear previous connections if any
            if AutoStatsConfig.Connections.AutoUpgradeBossChance then
                AutoStatsConfig.Connections.AutoUpgradeBossChance:Disconnect()
            end
            
            -- Create new auto upgrade loop
            AutoStatsConfig.Connections.AutoUpgradeBossChance = spawn(function()
                while AutoStatsConfig.AutoUpgradeBossChance do
                    Utilities.UpgradeStat("BOSS_CHANCE")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Stop auto upgrade
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Boss Chance stat", "stop_circle")
            
            -- Disconnect auto upgrade loop
            if AutoStatsConfig.Connections.AutoUpgradeBossChance then
                AutoStatsConfig.Connections.AutoUpgradeBossChance:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeBossChance = nil
            end
        end
    end
}, "AutoUpgradeBossToggle")

-- Manual upgrade buttons
TabMisc:CreateButton({
    Name = "Upgrade Luck (Once)",
    Description = "Upgrade your luck stat once",
    Callback = function()
        Utilities.UpgradeStat("LUCK")
    end
})

TabMisc:CreateButton({
    Name = "Upgrade Cooldown Reduction (Once)",
    Description = "Upgrade your cooldown reduction stat once",
    Callback = function()
        Utilities.UpgradeStat("COOLDOWN_REDUCTION")
    end
})

TabMisc:CreateButton({
    Name = "Upgrade Potion Duration (Once)",
    Description = "Upgrade your potion duration stat once",
    Callback = function()
        Utilities.UpgradeStat("POTION_DURATION")
    end
})

TabMisc:CreateButton({
    Name = "Upgrade Border Chance (Once)",
    Description = "Upgrade your border chance stat once",
    Callback = function()
        Utilities.UpgradeStat("BORDER_CHANCE")
    end
})

TabMisc:CreateButton({
    Name = "Upgrade Boss Chance (Once)",
    Description = "Upgrade your boss chance stat once",
    Callback = function()
        Utilities.UpgradeStat("BOSS_CHANCE")
    end
})

-- Theme and Config sections
TabSettings:BuildThemeSection()
TabSettings:BuildConfigSection()

-- Enable autoload config
Luna:LoadAutoloadConfig()

-- Add debug console to the game
Utilities.CreateDebugConsole = function()
    Utilities.DebugPrint("Attempting to create debug console GUI")
    
    -- Check if console already exists
    local player = Utilities.GetLocalPlayer()
    if player and player.PlayerGui and player.PlayerGui:FindFirstChild("MythHubConsole") then
        Utilities.DebugPrint("Debug console already exists, not creating a new one")
        return
    end
    
    -- Create console GUI
    pcall(function()
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "MythHubConsole"
        screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        screenGui.ResetOnSpawn = false
        
        local frame = Instance.new("Frame")
        frame.Name = "ConsoleFrame"
        frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        frame.BackgroundTransparency = 0.2
        frame.BorderSizePixel = 0
        frame.Position = UDim2.new(0, 10, 0, 10)
        frame.Size = UDim2.new(0, 400, 0, 300)
        frame.Parent = screenGui
        
        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        title.BackgroundTransparency = 0.2
        title.BorderSizePixel = 0
        title.Size = UDim2.new(1, 0, 0, 30)
        title.Font = Enum.Font.SourceSansBold
        title.Text = "MythHub Debug Console"
        title.TextColor3 = Color3.fromRGB(255, 255, 255)
        title.TextSize = 18
        title.Parent = frame
        
        local closeButton = Instance.new("TextButton")
        closeButton.Name = "CloseButton"
        closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
        closeButton.BorderSizePixel = 0
        closeButton.Position = UDim2.new(1, -25, 0, 5)
        closeButton.Size = UDim2.new(0, 20, 0, 20)
        closeButton.Font = Enum.Font.SourceSansBold
        closeButton.Text = "X"
        closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        closeButton.TextSize = 14
        closeButton.Parent = title
        
        local console = Instance.new("ScrollingFrame")
        console.Name = "Console"
        console.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        console.BackgroundTransparency = 0
        console.BorderSizePixel = 0
        console.Position = UDim2.new(0, 5, 0, 35)
        console.Size = UDim2.new(1, -10, 1, -40)
        console.CanvasSize = UDim2.new(0, 0, 0, 0)
        console.ScrollBarThickness = 8
        console.AutomaticCanvasSize = Enum.AutomaticSize.Y
        console.ScrollingDirection = Enum.ScrollingDirection.Y
        console.Parent = frame
        
        local text = Instance.new("TextLabel")
        text.Name = "Text"
        text.BackgroundTransparency = 1
        text.Position = UDim2.new(0, 5, 0, 5)
        text.Size = UDim2.new(1, -18, 0, 1000)
        text.CanvasSize = UDim2.new(0, 0, 0, 1000)
        text.Font = Enum.Font.SourceSans
        text.Text = "-- MythHub Debug Console Initialized --"
        text.TextColor3 = Color3.fromRGB(200, 200, 200)
        text.TextSize = 14
        text.TextXAlignment = Enum.TextXAlignment.Left
        text.TextYAlignment = Enum.TextYAlignment.Top
        text.TextWrapped = true
        text.Parent = console
        
        -- Make the console draggable
        local dragging
        local dragInput
        local dragStart
        local startPos
        
        local function update(input)
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
        
        title.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = frame.Position
                
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        
        title.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                dragInput = input
            end
        end)
        
        game:GetService("UserInputService").InputChanged:Connect(function(input)
            if input == dragInput and dragging then
                update(input)
            end
        end)
        
        closeButton.MouseButton1Click:Connect(function()
            screenGui.Enabled = false
        end)
        
        screenGui.Parent = player.PlayerGui
        Utilities.DebugPrint("Debug console created successfully")
    end)
end

-- Initialize debug console when script loads
spawn(function()
    wait(1) -- Wait a bit to ensure player is loaded
    Utilities.CreateDebugConsole()
end)

-- Create button to toggle console visibility in settings
TabSettings:CreateButton({
    Name = "Toggle Debug Console",
    Description = "Show or hide the debug console",
    Callback = function()
        local player = Utilities.GetLocalPlayer()
        if player and player.PlayerGui then
            local console = player.PlayerGui:FindFirstChild("MythHubConsole")
            if console then
                console.Enabled = not console.Enabled
                Utilities.Notify("Debug Console", console.Enabled and "Console shown" or "Console hidden", "settings")
            else
                Utilities.CreateDebugConsole()
                Utilities.Notify("Debug Console", "Console created", "settings")
            end
        end
    end
})

-- Add global battle end detection loop
spawn(function()
    Utilities.DebugPrint("Starting global battle end detection loop")
    while true do
        wait(1) -- Check every second
        
        -- Check if battle just ended
        if Utilities.IsBattleEnded() then
            Utilities.DebugPrint("Battle end detected by global monitor, dismissing automatically")
            Utilities.DismissBattleEnd()
            
            -- If not in an auto farm mode, still mark the last enemy as defeated
            if not AutoFarmConfig.Enabled and not AutoFarmConfig.AutoFarmAllWorldBosses and not AutoFarmConfig.AutoFarmAllEnemiesInSelectedWorlds then
                Utilities.DebugPrint("Not in auto farm mode, but still recording cooldown for last enemy")
                Utilities.EnsureEnemyCooldownsInitialized()
                
                -- Try to determine which enemy was defeated based on current world
                local possibleLastEnemy = nil
                
                -- If we were in a raid, it might be the Eternal Dragon
                if game.PlaceId == 9230754391 then -- Raid place ID
                    possibleLastEnemy = "eternal_dragon"
                else
                    -- Otherwise, use the current enemy from the AutoFarm settings if available
                    possibleLastEnemy = AutoFarmConfig.CurrentEnemy
                end
                
                if possibleLastEnemy then
                    Utilities.MarkEnemyDefeated(possibleLastEnemy)
                end
            end
        end
    end
end)

-- Enable autoload config
Luna:LoadAutoloadConfig()

-- Add Anti-AFK function (no GUI)
spawn(function()
    Utilities.DebugPrint("Starting Anti-AFK system")
    
    -- Get VirtualUser service
    local VirtualUser = game:GetService("VirtualUser")
    
    -- Connect to the Idled event
    Utilities.GetLocalPlayer().Idled:Connect(function()
        Utilities.DebugPrint("AFK kick prevention activated")
        
        -- Simulate input to prevent being kicked
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
        
        -- Notify the user
        Utilities.Notify("Anti-AFK", "Prevented AFK kick", "timer")
        
        Utilities.DebugPrint("Successfully prevented AFK kick")
    end)
    
    Utilities.DebugPrint("Anti-AFK system successfully initialized")
end)
