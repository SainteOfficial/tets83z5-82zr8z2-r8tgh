-- Verbesserter Mob Attack Script mit Hitbox Expander
-- Version 4.0 mit schnelleren Reaktionszeiten und besserer Positionierung
-- Erweitert: Bessere Überlebenschancen, Ausweichmechanismus und Vorausberechnung

-- Fehlerbehandlung für den gesamten Script
local success, errorMsg = pcall(function()

-- Services laden (mit sicherer Fehlerprüfung)
local Players = game:GetService("Players")
if not Players then warn("Players service nicht verfügbar") return end

local RunService = game:GetService("RunService") 
if not RunService then warn("RunService nicht verfügbar") return end

local UserInputService = game:GetService("UserInputService")
if not UserInputService then warn("UserInputService nicht verfügbar") return end

local VirtualInputManager = game:GetService("VirtualInputManager")
if not VirtualInputManager then warn("VirtualInputManager nicht verfügbar, nutze Fallback...") end

local TweenService = game:GetService("TweenService")
if not TweenService then warn("TweenService nicht verfügbar") return end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
if not ReplicatedStorage then warn("ReplicatedStorage nicht verfügbar") return end

-- Player und wichtige Variablen (mit Fehlerprüfung)
local Player = Players.LocalPlayer 
if not Player then
    warn("LocalPlayer nicht gefunden - Warte auf Spieler...")
    
    -- Warte auf Spieler
    while not Players.LocalPlayer do
        wait(0.1)
    end
    Player = Players.LocalPlayer
end

-- Erweiterte Konfiguration
local CONFIG = {
    HOVER_HEIGHT = 13,            -- Erhöht für bessere Sicht und Angriffswinkel
    ATTACK_DISTANCE = 90,         -- Erhöht für früheres Erkennen von Mobs
    ATTACK_INTERVAL = 0.03,       -- Stark reduziert für schnellere Angriffe
    HITBOX_SIZE_MULTIPLIER = 4,   -- Größere Hitbox für bessere Trefferchancen
    POSITION_SPEED = 0.05,        -- Verkürzte Positionierungszeit
    AUTO_DODGE = true,            -- Neue Funktion: Automatisches Ausweichen
    DODGE_THRESHOLD = 40,         -- HP-Schwelle für Ausweichmanöver
    PREDICT_MOVEMENT = true,      -- Neue Funktion: Vorhersage der Mob-Bewegung
    PRIORITY_TARGETING = true,    -- Neue Funktion: Priorisierte Ziele
    DEBUG_ENABLED = true          -- Auf false setzen, um Debug-Prints zu deaktivieren
}

-- Erweiterte Statusvariablen
local STATE = {
    isAttacking = false,
    isHitboxExpanded = false,
    selectedMob = nil,
    noClipEnabled = false,
    mobAttackCooldown = {},
    mobHealthCache = {},          -- Neu: Cache für Mob-Gesundheit
    playerMaxHealth = 0,          -- Neu: Speichert maximale Gesundheit des Spielers
    lastAttackTime = 0,           -- Neu: Zeitpunkt des letzten Angriffs
    dodgeInProgress = false,      -- Neu: Status des Ausweichmanövers
    mobPriorities = {},           -- Neu: Mobs nach Priorität
    nearbyPlayerCount = 0,        -- Neu: Anzahl der Spieler in der Nähe
    connections = {},
    guiElements = {}
}

-- Debug Funktion mit Sicherheitscheck
local function DebugPrint(message)
    if CONFIG.DEBUG_ENABLED and message then
        local timeStamp = os.date("%H:%M:%S")
        print("[" .. timeStamp .. "] [MOB ATTACKER] " .. tostring(message))
    end
end

DebugPrint("Script wird initialisiert...")

-- Character-Setup mit vollständiger Fehlerprüfung
local Character, Humanoid, HumanoidRootPart

local function SetupCharacter(char)
    if not char then
        DebugPrint("WARNUNG: SetupCharacter aufgerufen mit nil character")
        return false
    end
    
    Character = char
    
    -- Auf Humanoid warten mit kürzerem Timeout
    local startTime = tick()
    while not Character:FindFirstChild("Humanoid") and tick() - startTime < 3 do
        wait(0.05) -- Schnelleres Polling
    end
    
    Humanoid = Character:FindFirstChild("Humanoid")
    if not Humanoid then
        DebugPrint("FEHLER: Humanoid nicht gefunden nach Timeout")
        return false
    end
    
    -- Maximale Gesundheit speichern
    STATE.playerMaxHealth = Humanoid.MaxHealth
    
    -- Auf HumanoidRootPart warten mit kürzerem Timeout
    startTime = tick()
    while not Character:FindFirstChild("HumanoidRootPart") and tick() - startTime < 3 do
        wait(0.05) -- Schnelleres Polling
    end
    
    HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
    if not HumanoidRootPart then
        DebugPrint("FEHLER: HumanoidRootPart nicht gefunden nach Timeout")
        return false
    end
    
    DebugPrint("Character erfolgreich eingerichtet")
    
    -- Gesundheitsüberwachung für Ausweichmechanismus
    if Humanoid then
        -- Existierende Verbindung entfernen, falls vorhanden
        for i, conn in ipairs(STATE.connections) do
            if conn.Name == "HealthChanged" then
                conn:Disconnect()
                table.remove(STATE.connections, i)
                break
            end
        end
        
        local healthChangedConn = Humanoid.HealthChanged:Connect(function(health)
            -- Ausweichen bei niedriger Gesundheit
            if CONFIG.AUTO_DODGE and health < (STATE.playerMaxHealth * (CONFIG.DODGE_THRESHOLD / 100)) 
                and not STATE.dodgeInProgress then
                PerformEmergencyDodge()
            end
        end)
        healthChangedConn.Name = "HealthChanged"
        table.insert(STATE.connections, healthChangedConn)
    end
    
    return true
end

-- Verbindung hinzufügen mit Prüfung
local function AddConnection(connection, name)
    if connection then
        if name then
            connection.Name = name
        end
        table.insert(STATE.connections, connection)
        return connection
    end
    DebugPrint("WARNUNG: Versuch, eine nil Connection hinzuzufügen")
    return nil
end

-- Forward-Deklaration für Funktionen, die sich gegenseitig referenzieren
local PerformEmergencyDodge

-- Neuer Notfall-Ausweichmechanismus
PerformEmergencyDodge = function()
    if STATE.dodgeInProgress or not HumanoidRootPart or not Humanoid then return end
    
    STATE.dodgeInProgress = true
    DebugPrint("⚠️ KRITISCHER GESUNDHEITSSTATUS: Starte Notfall-Ausweichmanöver!")
    
    -- Status-Update
    if STATE.guiElements.StatusLabel then
        STATE.guiElements.StatusLabel.Text = "⚠️ AUSWEICHMANÖVER!"
    end
    
    -- Temporär Angriff pausieren
    local wasAttacking = STATE.isAttacking
    STATE.isAttacking = false
    
    -- Ausweichmanöver mit zufälliger Richtung
    pcall(function()
        -- Aktuelle Position merken
        local currentPos = HumanoidRootPart.Position
        
        -- Zufällige Ausweichrichtung
        local dodgeDistance = 50 -- 50 Studs Ausweichdistanz
        local randomAngle = math.random() * math.pi * 2
        local dodgeOffset = Vector3.new(
            math.cos(randomAngle) * dodgeDistance,
            30, -- Nach oben ausweichen
            math.sin(randomAngle) * dodgeDistance
        )
        
        -- Schnelles Ausweichen mit Tween
        local dodgeTween = TweenService:Create(
            HumanoidRootPart, 
            TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
            {CFrame = CFrame.new(currentPos + dodgeOffset)}
        )
        
        -- Ausweichen starten
        dodgeTween:Play()
        
        -- Warten auf Abschluss des Ausweichens
        dodgeTween.Completed:Wait()
        
        -- Kurze Erholungszeit
        wait(1.5)
        
        -- Angriffsmodus wiederherstellen
        STATE.isAttacking = wasAttacking
        STATE.dodgeInProgress = false
        
        if STATE.guiElements.StatusLabel then
            STATE.guiElements.StatusLabel.Text = STATE.isAttacking and "Suche Mobs..." or "Bereit"
        end
        
        DebugPrint("Ausweichmanöver abgeschlossen!")
    end)
end

-- GUI erstellen mit Fehlerbehandlung und erweiterten Informationen
local function CreateGUI()
    DebugPrint("Erstelle GUI...")
    
    -- Prüfe, ob GUI bereits existiert
    if Player:FindFirstChild("PlayerGui") then
        local existingGui = Player.PlayerGui:FindFirstChild("MobAttackerGUI")
        if existingGui then
            existingGui:Destroy()
            DebugPrint("Alte GUI entfernt")
        end
    end
    
    -- Schütze vor Fehlern
    local success, result = pcall(function()
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.Name = "MobAttackerGUI"
        ScreenGui.ResetOnSpawn = false
        ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        
        -- Für DisplayGuiWithOldBehavior
        pcall(function()
            ScreenGui.DisplayOrder = 999
        end)
        
        -- GUI an korrektem Ort platzieren
        if Player:FindFirstChild("PlayerGui") then
            ScreenGui.Parent = Player.PlayerGui
        else
            DebugPrint("PlayerGui nicht gefunden, wechsle zu CoreGui")
            -- Versuche Backup-Plan
            pcall(function()
                ScreenGui.Parent = game:GetService("CoreGui")
            end)
        end
        
        -- Hauptrahmen
        local MainFrame = Instance.new("Frame")
        MainFrame.Name = "ControlFrame"
        MainFrame.Size = UDim2.new(0, 220, 0, 170) -- Vergrößert für zusätzliche Info
        MainFrame.Position = UDim2.new(0.85, -110, 0.8, -85)
        MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        MainFrame.BackgroundTransparency = 0.2
        MainFrame.BorderSizePixel = 0
        MainFrame.Parent = ScreenGui
        
        -- Abgerundete Ecken
        local UICorner = Instance.new("UICorner")
        UICorner.CornerRadius = UDim.new(0, 10)
        UICorner.Parent = MainFrame
        
        -- Titel
        local Title = Instance.new("TextLabel")
        Title.Name = "TitleLabel"
        Title.Size = UDim2.new(1, 0, 0, 30)
        Title.BackgroundTransparency = 1
        Title.Text = "Mob Controller v4.0"
        Title.Font = Enum.Font.GothamBold
        Title.TextSize = 18
        Title.TextColor3 = Color3.fromRGB(255, 255, 255)
        Title.Parent = MainFrame
        
        -- Status-Anzeige
        local StatusLabel = Instance.new("TextLabel")
        StatusLabel.Name = "StatusLabel"
        StatusLabel.Size = UDim2.new(1, 0, 0, 20)
        StatusLabel.Position = UDim2.new(0, 0, 0.19, 0)
        StatusLabel.BackgroundTransparency = 1
        StatusLabel.Text = "Bereit"
        StatusLabel.Font = Enum.Font.Gotham
        StatusLabel.TextSize = 14
        StatusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        StatusLabel.Parent = MainFrame
        
        -- Mob Info Label (NEU)
        local MobInfoLabel = Instance.new("TextLabel")
        MobInfoLabel.Name = "MobInfoLabel"
        MobInfoLabel.Size = UDim2.new(1, 0, 0, 20)
        MobInfoLabel.Position = UDim2.new(0, 0, 0.31, 0)
        MobInfoLabel.BackgroundTransparency = 1
        MobInfoLabel.Text = "Kein Mob ausgewählt"
        MobInfoLabel.Font = Enum.Font.Gotham
        MobInfoLabel.TextSize = 12
        MobInfoLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        MobInfoLabel.Parent = MainFrame
        
        -- Angriff-Knopf
        local AttackButton = Instance.new("TextButton")
        AttackButton.Name = "AttackButton"
        AttackButton.Size = UDim2.new(0.85, 0, 0, 35)
        AttackButton.Position = UDim2.new(0.075, 0, 0.45, 0)
        AttackButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
        AttackButton.Text = "Angriff: AUS"
        AttackButton.Font = Enum.Font.GothamSemibold
        AttackButton.TextSize = 16
        AttackButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        AttackButton.ClipsDescendants = true
        AttackButton.Parent = MainFrame
        
        -- Button-Rundung
        local AttackCorner = Instance.new("UICorner")
        AttackCorner.CornerRadius = UDim.new(0, 6)
        AttackCorner.Parent = AttackButton
        
        -- Hitbox-Knopf
        local HitboxButton = Instance.new("TextButton")
        HitboxButton.Name = "HitboxButton"
        HitboxButton.Size = UDim2.new(0.85, 0, 0, 35)
        HitboxButton.Position = UDim2.new(0.075, 0, 0.67, 0)
        HitboxButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
        HitboxButton.Text = "Hitbox: AUS"
        HitboxButton.Font = Enum.Font.GothamSemibold
        HitboxButton.TextSize = 16
        HitboxButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        HitboxButton.Parent = MainFrame
        
        -- Button-Rundung
        local HitboxCorner = Instance.new("UICorner")
        HitboxCorner.CornerRadius = UDim.new(0, 6)
        HitboxCorner.Parent = HitboxButton
        
        -- Ausweichen-Knopf (NEU)
        local DodgeButton = Instance.new("TextButton")
        DodgeButton.Name = "DodgeButton"
        DodgeButton.Size = UDim2.new(0.85, 0, 0, 30)
        DodgeButton.Position = UDim2.new(0.075, 0, 0.87, 0)
        DodgeButton.BackgroundColor3 = Color3.fromRGB(50, 120, 220)
        DodgeButton.Text = "Ausweichen"
        DodgeButton.Font = Enum.Font.GothamSemibold
        DodgeButton.TextSize = 14
        DodgeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        DodgeButton.Parent = MainFrame
        
        -- Button-Rundung
        local DodgeCorner = Instance.new("UICorner")
        DodgeCorner.CornerRadius = UDim.new(0, 6)
        DodgeCorner.Parent = DodgeButton
        
        -- Button-Click-Effekte und Event-Handler (mit Schutz vor Fehlern)
        local ButtonConnections = {}
        
        local function CreateRippleEffect(button)
            -- Einfacher Ripple-Effekt
            local ripple = Instance.new("Frame")
            ripple.Name = "Ripple"
            ripple.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            ripple.BackgroundTransparency = 0.7
            ripple.BorderSizePixel = 0
            ripple.Position = UDim2.new(0.5, 0, 0.5, 0)
            ripple.AnchorPoint = Vector2.new(0.5, 0.5)
            ripple.Size = UDim2.new(0, 0, 0, 0)
            ripple.ZIndex = 2
            
            -- Rundung für Ripple
            local rippleCorner = Instance.new("UICorner")
            rippleCorner.CornerRadius = UDim.new(1, 0)
            rippleCorner.Parent = ripple
            
            ripple.Parent = button
            
            local targetSize = UDim2.new(2, 0, 2, 0)
            local rippleTween = TweenService:Create(ripple, TweenInfo.new(0.5), {Size = targetSize, BackgroundTransparency = 1})
            rippleTween:Play()
            
            delay(0.5, function()
                if ripple and ripple.Parent then
                    ripple:Destroy()
                end
            end)
        end
        
        -- Forward-Deklaration für Toggle-Funktionen
        local ToggleHitboxes, EnableImprovedFly
        
        -- Angriff Button Handler
        local attackClickConn
        attackClickConn = AttackButton.MouseButton1Click:Connect(function()
            STATE.isAttacking = not STATE.isAttacking
            
            -- Visuelles Feedback
            local goalColor = STATE.isAttacking and Color3.fromRGB(50, 180, 50) or Color3.fromRGB(220, 50, 50)
            local buttonTween = TweenService:Create(AttackButton, TweenInfo.new(0.3), {BackgroundColor3 = goalColor})
            buttonTween:Play()
            
            AttackButton.Text = STATE.isAttacking and "Angriff: AN" or "Angriff: AUS"
            StatusLabel.Text = STATE.isAttacking and "Suche Mobs..." or "Bereit"
            
            CreateRippleEffect(AttackButton)
            
            -- Bei Aktivierung Fly-Modus aktivieren
            if STATE.isAttacking and EnableImprovedFly then
                EnableImprovedFly()
            end
            
            DebugPrint("Angriffsmodus: " .. tostring(STATE.isAttacking))
        end)
        
        table.insert(ButtonConnections, attackClickConn)
        
        -- Hitbox Button Handler
        local hitboxClickConn
        hitboxClickConn = HitboxButton.MouseButton1Click:Connect(function()
            STATE.isHitboxExpanded = not STATE.isHitboxExpanded
            
            -- Visuelles Feedback
            local goalColor = STATE.isHitboxExpanded and Color3.fromRGB(50, 180, 50) or Color3.fromRGB(220, 50, 50)
            local buttonTween = TweenService:Create(HitboxButton, TweenInfo.new(0.3), {BackgroundColor3 = goalColor})
            buttonTween:Play()
            
            HitboxButton.Text = STATE.isHitboxExpanded and "Hitbox: AN" or "Hitbox: AUS"
            
            CreateRippleEffect(HitboxButton)
            
            -- Hitboxen aktivieren/deaktivieren
            if ToggleHitboxes then
                ToggleHitboxes(STATE.isHitboxExpanded)
            end
            
            DebugPrint("Hitbox-Modus: " .. tostring(STATE.isHitboxExpanded))
        end)
        
        table.insert(ButtonConnections, hitboxClickConn)
        
        -- NEU: Ausweichbutton-Effekt
        local dodgeClickConn
        dodgeClickConn = DodgeButton.MouseButton1Click:Connect(function()
            PerformEmergencyDodge()
            
            -- Visuelles Feedback
            local origColor = DodgeButton.BackgroundColor3
            local buttonTween = TweenService:Create(DodgeButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(100, 200, 255)})
            buttonTween:Play()
            
            CreateRippleEffect(DodgeButton)
            
            delay(0.5, function()
                TweenService:Create(DodgeButton, TweenInfo.new(0.3), {BackgroundColor3 = origColor}):Play()
            end)
        end)
        
        table.insert(ButtonConnections, dodgeClickConn)
        
        -- Connections speichern
        for _, conn in ipairs(ButtonConnections) do
            table.insert(STATE.connections, conn)
        end
        
        -- Elemente speichern und zurückgeben
        return {
            ScreenGui = ScreenGui, 
            StatusLabel = StatusLabel,
            MobInfoLabel = MobInfoLabel,
            AttackButton = AttackButton,
            HitboxButton = HitboxButton,
            DodgeButton = DodgeButton,
            Connections = ButtonConnections
        }
    end)
    
    if success and result then
        DebugPrint("GUI erfolgreich erstellt")
        STATE.guiElements = result
        return result
    else
        DebugPrint("FEHLER bei GUI-Erstellung: " .. tostring(result))
        -- Fallback minimale GUI
        local minGui = Instance.new("ScreenGui")
        minGui.Name = "MinimalMobAttackerGUI"
        pcall(function() minGui.Parent = Player.PlayerGui end)
        
        local minButton = Instance.new("TextButton")
        minButton.Text = "MOB CONTROL v4"
        minButton.Size = UDim2.new(0, 100, 0, 40)
        minButton.Position = UDim2.new(0.9, -50, 0.9, -20)
        minButton.Parent = minGui
        
        return {ScreenGui = minGui, StatusLabel = nil}
    end
end

-- Berechne Mob-Priorität (NEU)
local function CalculateMobPriority(mob)
    if not mob then return 0 end
    
    local priority = 0
    local mobHumanoid = mob:FindFirstChild("Humanoid")
    
    -- Grundpriorität basierend auf Name (für bestimmte Mobtypen)
    local name = mob.Name:lower()
    if name:find("boss") then 
        priority = priority + 20
    elseif name:find("elite") then
        priority = priority + 10
    elseif name:find("rare") then 
        priority = priority + 15
    end
    
    -- Priorisiere schwächere Mobs für schnelle Erfolge
    if mobHumanoid then
        local healthPercentage = mobHumanoid.Health / mobHumanoid.MaxHealth
        -- Niedrigere Gesundheit = höhere Priorität
        priority = priority + (20 * (1 - healthPercentage))
    end
    
    return priority
end

-- Verbesserte Mob-Suche mit Prioritäten und Vorhersage
local function FindClosestMob()
    -- Sicherheitschecks
    if not Character or not HumanoidRootPart then
        DebugPrint("FEHLER: Character oder HumanoidRootPart nicht verfügbar bei Mob-Suche")
        return nil
    end

    -- Mobs-Ordner finden
    local Mobs = workspace:FindFirstChild("Mobs")
    if not Mobs then
        DebugPrint("FEHLER: Mobs-Ordner nicht gefunden in workspace, suche alternative Orte...")
        
        -- Alternative Orte für Mobs suchen
        local alternativeFolders = {"Enemies", "NPCs", "Monsters", "Creatures"}
        for _, folderName in ipairs(alternativeFolders) do
            Mobs = workspace:FindFirstChild(folderName)
            if Mobs then
                DebugPrint("Alternative Mobs gefunden in: " .. folderName)
                break
            end
        end
        
        if not Mobs then
            -- Letzte Option: Direkt im Workspace nach Humanoid-Charakteren suchen
            DebugPrint("Keine expliziten Mob-Ordner gefunden, suche direkt im Workspace...")
            local candidates = {}
            
            for _, obj in pairs(workspace:GetChildren()) do
                if obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj ~= Character then
                    local humanoid = obj:FindFirstChild("Humanoid")
                    local root = obj:FindFirstChild("HumanoidRootPart")
                    
                    if humanoid and root and humanoid.Health > 0 then
                        local playerPosition = HumanoidRootPart.Position
                        local distance = (playerPosition - root.Position).Magnitude
                        
                        if distance < CONFIG.ATTACK_DISTANCE then
                            table.insert(candidates, {
                                mob = obj,
                                distance = distance,
                                priority = CONFIG.PRIORITY_TARGETING and CalculateMobPriority(obj) or 0,
                                health = humanoid.Health,
                                maxHealth = humanoid.MaxHealth,
                                position = root.Position
                            })
                        end
                    end
                end
            end
            
            if #candidates > 0 then
                -- Sortieren und besten Kandidaten auswählen
                table.sort(candidates, function(a, b)
                    local scoreA = a.distance - (a.priority * 5)
                    local scoreB = b.distance - (b.priority * 5)
                    return scoreA < scoreB
                end)
                
                local bestCandidate = candidates[1]
                
                -- GUI aktualisieren
                if STATE.guiElements.MobInfoLabel then
                    STATE.guiElements.MobInfoLabel.Text = bestCandidate.mob.Name .. 
                        " | HP: " .. math.floor(bestCandidate.health) .. "/" .. math.floor(bestCandidate.maxHealth) ..
                        " | " .. math.floor(bestCandidate.distance) .. "m"
                end
                
                STATE.mobHealthCache[bestCandidate.mob] = bestCandidate.health
                
                return bestCandidate.mob, bestCandidate.position
            end
            
            return nil
        end
    end
    
    local candidates = {}
    local playerPosition = HumanoidRootPart.Position
    
    -- Sichere Iteration durch Mobs
    for _, mob in pairs(Mobs:GetChildren()) do
        if mob and mob:IsA("Model") then
            -- Sichere Suche nach mobRoot
            local success, result = pcall(function()
                local mobRoot = mob:FindFirstChild("HumanoidRootPart")
                local mobHumanoid = mob:FindFirstChild("Humanoid")
                
                if mobRoot and mobHumanoid and mobHumanoid.Health > 0 then
                    -- Distanz mit pcall berechnen
                    local distance = (playerPosition - mobRoot.Position).Magnitude
                    
                    if distance < CONFIG.ATTACK_DISTANCE then
                        -- Cooldown-Check
                        local onCooldown = false
                        if STATE.mobAttackCooldown[mob] and tick() - STATE.mobAttackCooldown[mob] < 1.5 then
                            onCooldown = true
                        end
                        
                        if not onCooldown then
                            -- Mob-Bewegung vorhersagen
                            local predictedPosition = mobRoot.Position
                            
                            if CONFIG.PREDICT_MOVEMENT then
                                -- Einfache lineare Vorhersage basierend auf aktueller Geschwindigkeit
                                if mobRoot.Velocity.Magnitude > 1 then
                                    predictedPosition = mobRoot.Position + (mobRoot.Velocity * 0.2)
                                end
                            end
                            
                            -- Berechnete Distanz zur vorhergesagten Position
                            local predictedDistance = (playerPosition - predictedPosition).Magnitude
                            
                            -- Mob-Priorität berechnen
                            local priority = CONFIG.PRIORITY_TARGETING and CalculateMobPriority(mob) or 0
                            
                            -- Auf die Kandidatenliste setzen
                            table.insert(candidates, {
                                mob = mob,
                                distance = predictedDistance,
                                priority = priority,
                                health = mobHumanoid.Health,
                                maxHealth = mobHumanoid.MaxHealth,
                                position = predictedPosition
                            })
                        end
                    end
                end
            end)
            
            if not success then
                DebugPrint("Fehler bei Mob-Prüfung: " .. tostring(result))
            end
        end
    end
    
    -- Sortiere Kandidaten nach einer Kombination aus Distanz und Priorität
    if #candidates > 0 then
        -- Sortieren nach Distanz und Priorität (höhere Priorität reduziert den Score)
        table.sort(candidates, function(a, b)
            local scoreA = a.distance - (a.priority * 5)
            local scoreB = b.distance - (b.priority * 5)
            return scoreA < scoreB
        end)
        
        local bestCandidate = candidates[1]
        
        -- GUI aktualisieren
        if STATE.guiElements.MobInfoLabel then
            STATE.guiElements.MobInfoLabel.Text = bestCandidate.mob.Name .. 
                " | HP: " .. math.floor(bestCandidate.health) .. "/" .. math.floor(bestCandidate.maxHealth) ..
                " | " .. math.floor(bestCandidate.distance) .. "m"
        end
        
        -- Health-Informationen cachen
        STATE.mobHealthCache[bestCandidate.mob] = bestCandidate.health
        
        return bestCandidate.mob, bestCandidate.position
    end
    
    -- Keine geeigneten Mobs gefunden
    if STATE.guiElements.MobInfoLabel then
        STATE.guiElements.MobInfoLabel.Text = "Kein Mob in Reichweite"
    end
    
    return nil
end

-- Verbesserte Funktion zum Angreifen des Mobs
local function AttackMob(mob, predictedPosition)
    -- Sicherheitschecks
    if not mob or not Character or not HumanoidRootPart or not Humanoid then
        return false
    end
    
    STATE.selectedMob = mob
    
    -- Sichere Root-Abrufe
    local mobRoot = mob:FindFirstChild("HumanoidRootPart")
    if not mobRoot then
        DebugPrint("FEHLER: Mob hat keinen HumanoidRootPart")
        return false
    end
    
    local mobPosition = predictedPosition or mobRoot.Position
    
    -- Bessere Angriffsposition (über dem Mob)
    local targetPosition = mobPosition + Vector3.new(0, CONFIG.HOVER_HEIGHT, 0)
    
    -- Schnellere Bewegung zum Ziel
    if HumanoidRootPart then
        -- Mit Tween für sanftere Bewegung
        local moveTween = TweenService:Create(
            HumanoidRootPart,
            TweenInfo.new(CONFIG.POSITION_SPEED, Enum.EasingStyle.Quad),
            {CFrame = CFrame.new(targetPosition, mobPosition)}
        )
        moveTween:Play()
    end
    
    -- Cooldown für diesen Mob setzen
    STATE.mobAttackCooldown[mob] = tick()
    
    -- Angriff ausführen
    if tick() - STATE.lastAttackTime > CONFIG.ATTACK_INTERVAL then
        pcall(function()
            -- Virtual Input Manager für Angriff nutzen (mit Fallback)
            if VirtualInputManager then
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
            else
                -- Fallback: Direktes Auslösen des Angriffs über Remote Events versuchen
                -- Angriffs-Remote-Events finden und auslösen
                local possibleEvents = {"Attack", "Combat", "Fight", "DamageEvent"}
                
                for _, eventName in ipairs(possibleEvents) do
                    local event = ReplicatedStorage:FindFirstChild(eventName)
                    if event and event:IsA("RemoteEvent") then
                        event:FireServer(mob)
                        break
                    end
                end
            end
            
            STATE.lastAttackTime = tick()
        end)
    end
    
    return true
end

-- Verbesserte Hitbox-Erweiterung
ToggleHitboxes = function(enabled)
    -- Mobs-Ordner finden
    local Mobs = workspace:FindFirstChild("Mobs")
    if not Mobs then
        -- Alternative Orte für Mobs suchen
        local alternativeFolders = {"Enemies", "NPCs", "Monsters", "Creatures"}
        for _, folderName in ipairs(alternativeFolders) do
            Mobs = workspace:FindFirstChild(folderName)
            if Mobs then break end
        end
        
        if not Mobs then
            DebugPrint("Keine Mobs gefunden für Hitbox-Erweiterung")
            return
        end
    end
    
    -- Durch alle Mobs iterieren
    for _, mob in pairs(Mobs:GetChildren()) do
        if mob and mob:IsA("Model") then
            local mobRoot = mob:FindFirstChild("HumanoidRootPart")
            if mobRoot then
                pcall(function()
                    if enabled then
                        -- Größere Hitbox für bessere Trefferchancen
                        mobRoot.Size = Vector3.new(
                            mobRoot.Size.X * CONFIG.HITBOX_SIZE_MULTIPLIER,
                            mobRoot.Size.Y * CONFIG.HITBOX_SIZE_MULTIPLIER, 
                            mobRoot.Size.Z * CONFIG.HITBOX_SIZE_MULTIPLIER
                        )
                        mobRoot.Transparency = 0.5 -- Semitransparent für visuelle Rückmeldung
                        mobRoot.CanCollide = false -- Verhindert Kollisionen mit vergrößerter Hitbox
                    else
                        -- Hitbox auf Originalzustand zurücksetzen
                        -- Originalgrößen wiederherstellen (grobe Schätzung)
                        mobRoot.Size = Vector3.new(
                            mobRoot.Size.X / CONFIG.HITBOX_SIZE_MULTIPLIER,
                            mobRoot.Size.Y / CONFIG.HITBOX_SIZE_MULTIPLIER, 
                            mobRoot.Size.Z / CONFIG.HITBOX_SIZE_MULTIPLIER
                        )
                        mobRoot.Transparency = 1 -- Standardtransparenz
                        mobRoot.CanCollide = true -- Kollisionen wiederherstellen
                    end
                end)
            end
        end
    end
    
    DebugPrint("Hitboxen " .. (enabled and "erweitert" : "zurückgesetzt"))
end

-- Verbesserte Fly-Funktion mit Anti-Fall und Kollisionsvermeidung
EnableImprovedFly = function()
    if STATE.noClipEnabled then return end
    
    STATE.noClipEnabled = true
    DebugPrint("Verbesserter Flugmodus aktiviert")
    
    -- Existierende Flug-Verbindung entfernen, falls vorhanden
    for i, conn in ipairs(STATE.connections) do
        if conn.Name == "NoClipLoop" then
            conn:Disconnect()
            table.remove(STATE.connections, i)
            break
        end
    end
    
    -- NoClip Loop für bessere Beweglichkeit
    local noClipConn = RunService.Stepped:Connect(function()
        if not CHARACTER or not HumanoidRootPart or not Humanoid then return end
        
        -- Setze CanCollide auf false für alle Teile
        for _, part in pairs(Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
        
        -- Automatischer Fall-Schutz
        if HumanoidRootPart.Position.Y < -5 then
            -- Bei zu tiefem Fall, nach oben teleportieren
            HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position.X, 50, HumanoidRootPart.Position.Z)
        end
    end)
    
    noClipConn.Name = "NoClipLoop"
    table.insert(STATE.connections, noClipConn)
end

-- Hauptschleife für den Angriff
local function StartAttackLoop()
    DebugPrint("Starte Angriffs-Loop")
    
    -- Existierende Angriffs-Verbindung entfernen, falls vorhanden
    for i, conn in ipairs(STATE.connections) do
        if conn.Name == "AttackLoop" then
            conn:Disconnect()
            table.remove(STATE.connections, i)
            break
        end
    end
    
    -- Angriffs-Loop
    local attackConn = RunService.Heartbeat:Connect(function()
        if not STATE.isAttacking or STATE.dodgeInProgress then return end
        
        -- Sicherstellung, dass Character existiert
        if not Character or not Character.Parent or not HumanoidRootPart or not Humanoid then
            return
        end
        
        -- Suche nächsten Mob
        local mob, predictedPosition = FindClosestMob()
        
        -- Wenn Mob gefunden, angreifen
        if mob then
            AttackMob(mob, predictedPosition)
        end
    end)
    
    attackConn.Name = "AttackLoop"
    table.insert(STATE.connections, attackConn)
end

-- Funktion zum Aufräumen bei Beendigung
local function CleanupEverything()
    DebugPrint("Räume alles auf...")
    
    -- Alle Verbindungen trennen
    for _, conn in ipairs(STATE.connections) do
        pcall(function()
            if conn and typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            end
        end)
    end
    
    -- GUI entfernen
    if STATE.guiElements.ScreenGui then
        STATE.guiElements.ScreenGui:Destroy()
    end
    
    -- Hitboxen zurücksetzen
    if STATE.isHitboxExpanded then
        pcall(function()
            ToggleHitboxes(false)
        end)
    end
    
    -- Status zurücksetzen
    STATE.isAttacking = false
    STATE.isHitboxExpanded = false
    STATE.noClipEnabled = false
    STATE.selectedMob = nil
    STATE.connections = {}
    STATE.guiElements = {}
    
    DebugPrint("Aufräumen abgeschlossen")
end

-- Hotkey-Unterstützung für schnelle Kontrolle
local function SetupHotkeys()
    DebugPrint("Richte Hotkeys ein")
    
    -- Existierende Hotkey-Verbindung entfernen, falls vorhanden
    for i, conn in ipairs(STATE.connections) do
        if conn.Name == "HotkeyInput" then
            conn:Disconnect()
            table.remove(STATE.connections, i)
            break
        end
    end
    
    -- Hotkey-Verbindung
    local inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        -- Hotkey für Angriffsmodus toggle (U)
        if input.KeyCode == Enum.KeyCode.U then
            STATE.isAttacking = not STATE.isAttacking
            
            if STATE.guiElements.AttackButton then
                STATE.guiElements.AttackButton.Text = STATE.isAttacking and "Angriff: AN" or "Angriff: AUS"
                local goalColor = STATE.isAttacking and Color3.fromRGB(50, 180, 50) or Color3.fromRGB(220, 50, 50)
                TweenService:Create(STATE.guiElements.AttackButton, TweenInfo.new(0.3), {BackgroundColor3 = goalColor}):Play()
            end
            
            if STATE.guiElements.StatusLabel then
                STATE.guiElements.StatusLabel.Text = STATE.isAttacking and "Suche Mobs..." or "Bereit"
            end
            
            DebugPrint("Angriffsmodus: " .. tostring(STATE.isAttacking))
            
            -- Bei Aktivierung Fly-Modus aktivieren
            if STATE.isAttacking and EnableImprovedFly then
                EnableImprovedFly()
            end
        end
        
        -- Hotkey für Hitbox toggle (H)
        if input.KeyCode == Enum.KeyCode.H then
            STATE.isHitboxExpanded = not STATE.isHitboxExpanded
            
            if STATE.guiElements.HitboxButton then
                STATE.guiElements.HitboxButton.Text = STATE.isHitboxExpanded and "Hitbox: AN" or "Hitbox: AUS"
                local goalColor = STATE.isHitboxExpanded and Color3.fromRGB(50, 180, 50) or Color3.fromRGB(220, 50, 50)
                TweenService:Create(STATE.guiElements.HitboxButton, TweenInfo.new(0.3), {BackgroundColor3 = goalColor}):Play()
            end
            
            -- Hitboxen aktivieren/deaktivieren
            if ToggleHitboxes then
                ToggleHitboxes(STATE.isHitboxExpanded)
            end
            
            DebugPrint("Hitbox-Modus: " .. tostring(STATE.isHitboxExpanded))
        end
        
        -- Hotkey für Notfall-Ausweichen (E)
        if input.KeyCode == Enum.KeyCode.E then
            PerformEmergencyDodge()
        end
    end)
    
    inputConn.Name = "HotkeyInput"
    table.insert(STATE.connections, inputConn)
end

-- Haupt-Initialisierungsfunktion
local function Initialize()
    DebugPrint("Initialisiere Mob Controller v4.0...")
    
    -- Auf Character warten
    if not Player.Character then
        DebugPrint("Warte auf Character...")
        Player.CharacterAdded:Wait()
    end
    
    local success = SetupCharacter(Player.Character)
    if not success then
        DebugPrint("Fehler bei Character-Setup, versuche erneut in 1 Sekunde...")
        wait(1)
        success = SetupCharacter(Player.Character)
        if not success then
            DebugPrint("Kritischer Fehler: Character-Setup fehlgeschlagen nach mehreren Versuchen.")
            return
        end
    end
    
    -- GUI erstellen
    CreateGUI()
    
    -- Hotkeys einrichten
    SetupHotkeys()
    
    -- Character neu laden Event
    local characterAddedConn = Player.CharacterAdded:Connect(function(newCharacter)
        DebugPrint("Neuer Character erkannt, initialisiere...")
        SetupCharacter(newCharacter)
    end)
    
    characterAddedConn.Name = "CharacterAdded"
    table.insert(STATE.connections, characterAddedConn)
    
    -- Angriffs-Loop starten
    StartAttackLoop()
    
    -- Speichern der Character-Info
    if Humanoid then
        STATE.playerMaxHealth = Humanoid.MaxHealth
    end
    
    -- Automatische Umgebungserkennung
    DebugPrint("Überprüfe Spielumgebung...")
    
    -- Überprüfe, ob wir in einer PvP-Zone sind
    local isPvPEnabled = false
    local pvpZoneTags = {"PvP", "PVP", "Kampfzone", "BattleArena"}
    
    for _, tag in ipairs(pvpZoneTags) do
        if workspace:FindFirstChild(tag) then
            isPvPEnabled = true
            break
        end
    end
    
    if isPvPEnabled then
        DebugPrint("⚠️ PvP-Zone erkannt! Sei vorsichtig.")
        CONFIG.AUTO_DODGE = true -- In PvP immer ausweichen aktivieren
    end
    
    -- Überprüfe auf andere Spieler in der Nähe
    local nearbyPlayers = 0
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if distance < 50 then
                nearbyPlayers = nearbyPlayers + 1
            end
        end
    end
    
    STATE.nearbyPlayerCount = nearbyPlayers
    
    if nearbyPlayers > 0 then
        DebugPrint("ℹ️ " .. nearbyPlayers .. " Spieler in der Nähe.")
    end
    
    DebugPrint("Mob Controller v4.0 erfolgreich initialisiert!")
    
    -- Erfolgsbenachrichtigung in der GUI
    if STATE.guiElements.StatusLabel then
        STATE.guiElements.StatusLabel.Text = "Initialisiert - Bereit!"
        
        -- Kurzen Erfolgs-Flash durchführen
        local originalColor = STATE.guiElements.StatusLabel.TextColor3
        STATE.guiElements.StatusLabel.TextColor3 = Color3.fromRGB(50, 255, 50)
        
        delay(1, function()
            if STATE.guiElements.StatusLabel then
                TweenService:Create(STATE.guiElements.StatusLabel, TweenInfo.new(0.5), 
                    {TextColor3 = originalColor}):Play()
            end
        end)
    end
end

-- Cleanup bei Script-End hinzufügen
game:GetService("Players").PlayerRemoving:Connect(function(player)
    if player == Player then
        CleanupEverything()
    end
end)

-- Script starten
Initialize()

end) -- pcall Ende

-- Fehlerbehandlung für den gesamten Script
if not success then
    warn("KRITISCHER FEHLER im Mob Attack Script: " .. tostring(errorMsg))
    
    -- Versuche, eine Fehlermeldung anzuzeigen
    pcall(function()
        local errorGui = Instance.new("ScreenGui")
        errorGui.Name = "MobAttackErrorGUI"
        
        local errorFrame = Instance.new("Frame")
        errorFrame.Size = UDim2.new(0, 300, 0, 100)
        errorFrame.Position = UDim2.new(0.5, -150, 0.5, -50)
        errorFrame.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
        errorFrame.Parent = errorGui
        
        local errorMsg = Instance.new("TextLabel")
        errorMsg.Size = UDim2.new(1, -20, 1, -20)
        errorMsg.Position = UDim2.new(0, 10, 0, 10)
        errorMsg.Text = "Fehler im Mob Attack Script: Bitte neu starten."
        errorMsg.TextColor3 = Color3.fromRGB(255, 255, 255)
        errorMsg.BackgroundTransparency = 1
        errorMsg.Parent = errorFrame
        
        errorGui.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
        
        wait(5)
        errorGui:Destroy()
    end)
end
