--[[
    MythHub - Premium Script Hub
    Game: Anime Card Clash
    Created by: MythTeam
    
    Features:
    - Dashboard with information and stats
    - AutoFarm for enemies across all worlds
    - Tower automation for Battle and Infinite Towers
    - Raid assistance and automation
    - Exploration management
    - Shop automation
    - Misc utilities including auto pickup, auto merge, and more
    
    Last Updated: April 2025
]]

-- Load Luna Interface Library
local Luna = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/refs/heads/main/source.lua", true))()

-- Initialize Window without Key System
local Window = Luna:CreateWindow({
    Name = "MythHub",
    Subtitle = "Anime Card Clash",
    LogoID = "134758479713826", -- MythHub logo ID
    LoadingEnabled = true,
    LoadingTitle = "MythHub Premium",
    LoadingSubtitle = "Anime Card Clash Edition",
    
    ConfigSettings = {
        RootFolder = "MythHub",
        ConfigFolder = "AnimeCardClash"
    },
    
    KeySystem = false
})

-- Utility Functions
local Utilities = {}

-- Function to get local player
Utilities.GetLocalPlayer = function()
    return game:GetService("Players").LocalPlayer
end

-- Function to check if a player is in game
Utilities.IsInGame = function()
    return game:IsLoaded() and Utilities.GetLocalPlayer() ~= nil
end

-- Function to create notifications
Utilities.Notify = function(title, content, icon)
    Luna:Notification({
        Title = title or "MythHub Notification",
        Content = content or "Action completed successfully",
        Icon = icon or "notifications_active",
        ImageSource = "Material"
    })
end

-- Function to get Battle Tower level
Utilities.GetBattleTowerLevel = function()
    local success, result = pcall(function()
        local LocalUserModule = game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")
        local LocalUser = require(LocalUserModule).LocalUser
        local battleTowerWave = LocalUser.metadata:getAsNumber("battle_tower_wave")
        return battleTowerWave or 1
    end)
    
    if success then
        return result
    else
        return 1
    end
end

-- Function to get Infinite Tower floor
Utilities.GetInfiniteTowerFloor = function()
    local success, result = pcall(function()
        local LocalUser = require(game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        
        if LocalUser and LocalUser.infiniteTower then
            local document = LocalUser.infiniteTower:getDocument()
            if document and document.floor then
                return document.floor
            end
        end
        return 1
    end)
    
    if success and result then
        return result
    else
        return 1
    end
end

-- Function to get available upgrade points
Utilities.GetUpgradePoints = function()
    local success, result = pcall(function()
        local LocalUser = require(game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        return LocalUser.upgrades:getCards()
    end)
    
    if success then
        return result
    else
        return 0
    end
end

-- Function to print debug messages
Utilities.DebugPrint = function(message)
    print("[MythHub Debug] " .. message)
    -- Also add to console GUI if available
    pcall(function()
        if game:GetService("Players").LocalPlayer and game:GetService("Players").LocalPlayer.PlayerGui and game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("MythHubConsole") then
            local console = game:GetService("Players").LocalPlayer.PlayerGui.MythHubConsole
            if console and console:FindFirstChild("Console") and console.Console:FindFirstChild("Text") then
                console.Console.Text.Text = console.Console.Text.Text .. "\n" .. message
            end
        end
    end)
end

-- Function to check if player is in battle
Utilities.IsInBattle = function()
    local localPlayer = Utilities.GetLocalPlayer()
    if localPlayer and localPlayer.PlayerGui then
        local hasBattleGui = localPlayer.PlayerGui:FindFirstChild("battle") ~= nil
        Utilities.DebugPrint("Battle GUI check: " .. tostring(hasBattleGui))
        return hasBattleGui
    end
    Utilities.DebugPrint("Battle GUI check failed - player or GUI not found")
    return false
end

-- Function to check if battle just ended
Utilities.IsBattleEnded = function()
    local localPlayer = Utilities.GetLocalPlayer()
    if localPlayer and localPlayer.PlayerGui then
        local hasBattleEndGui = localPlayer.PlayerGui:FindFirstChild("battle-end") ~= nil
        Utilities.DebugPrint("Battle-End GUI check: " .. tostring(hasBattleEndGui))
        return hasBattleEndGui
    end
    Utilities.DebugPrint("Battle-End GUI check failed - player or GUI not found")
    return false
end

-- Function to simulate mouse clicks (M1)
Utilities.ClickM1 = function(times)
    times = times or 10 -- Default to 10 clicks
    
    Utilities.DebugPrint("Attempting to send " .. times .. " M1 clicks")
    pcall(function()
        for i = 1, times do
            Utilities.DebugPrint("Sending M1 click " .. i .. "/" .. times)
            game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, game, 1)
            wait(0.1)
            game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, false, game, 1)
            wait(0.1)
        end
    end)
    Utilities.DebugPrint("Finished sending M1 clicks")
end

-- Function to dismiss battle end screen
Utilities.DismissBattleEnd = function()
    Utilities.DebugPrint("DismissBattleEnd function called")
    if Utilities.IsBattleEnded() then
        Utilities.DebugPrint("Battle-End detected, waiting 3 seconds before clicking")
        wait(3)
        
        -- Click M1 repeatedly until battle-end GUI is gone
        local maxAttempts = 30 -- Maximum attempts to prevent infinite loop
        local attempts = 0
        
        Utilities.DebugPrint("Starting to click M1 to dismiss Battle-End")
        while Utilities.IsBattleEnded() and attempts < maxAttempts do
            Utilities.DebugPrint("Click attempt " .. attempts+1 .. "/" .. maxAttempts)
            Utilities.ClickM1(5) -- Try 5 clicks each iteration
            wait(0.5)
            attempts = attempts + 1
        end
        
        if attempts >= maxAttempts then
            Utilities.DebugPrint("WARNING: Failed to dismiss Battle-End after " .. maxAttempts .. " attempts")
        else
            Utilities.DebugPrint("Successfully dismissed Battle-End GUI after " .. attempts .. " attempts")
        end
        
        -- Wait a bit more to ensure everything is properly dismissed
        Utilities.DebugPrint("Waiting 1 second extra to ensure dismissal is complete")
        wait(1)
    else
        Utilities.DebugPrint("No Battle-End GUI detected, nothing to dismiss")
    end
end

-- Function to handle battle flow and start next battle
Utilities.StartNextBattle = function(enemyName)
    Utilities.DebugPrint("StartNextBattle called for enemy: " .. tostring(enemyName))
    
    -- Check if enemy is on cooldown
    local currentTime = os.time()
    if AutoFarmConfig.EnemyCooldowns[enemyName] and AutoFarmConfig.EnemyCooldowns[enemyName] > currentTime then
        local remainingCooldown = math.ceil(AutoFarmConfig.EnemyCooldowns[enemyName] - currentTime)
        Utilities.DebugPrint("Enemy " .. enemyName .. " is still on cooldown for " .. remainingCooldown .. " seconds")
        return false
    end
    
    -- First check if we're in a battle
    if Utilities.IsInBattle() then
        Utilities.DebugPrint("Already in battle, cannot start new battle")
        return false -- Already in battle, can't start a new one
    end
    
    -- Check if we need to dismiss a battle end screen
    if Utilities.IsBattleEnded() then
        Utilities.DebugPrint("Battle-End screen detected, attempting to dismiss")
        Utilities.DismissBattleEnd()
        return false
    end
    
    -- Now try to summon the enemy if not in battle and no battle end screen
    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
        Utilities.DebugPrint("No battle or battle-end detected, attempting to summon: " .. tostring(enemyName))
        local success = Utilities.SummonEnemy(enemyName)
        
        if success then
            Utilities.DebugPrint("Summon attempt successful, waiting 2 seconds for battle to start")
            -- Wait 2 seconds to allow battle to start properly
            wait(2)
            
            -- Check if we successfully entered battle
            if Utilities.IsInBattle() then
                Utilities.DebugPrint("Successfully entered battle with " .. enemyName)
                return true
            else
                -- If we didn't enter battle but summoned successfully, the enemy might be on cooldown
                Utilities.DebugPrint("Summoned enemy but didn't enter battle, setting cooldown for " .. enemyName)
                AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + AutoFarmConfig.Interval
                return false
            end
        else
            Utilities.DebugPrint("Summon attempt failed for: " .. tostring(enemyName))
        end
        
        return success
    end
    
    Utilities.DebugPrint("Failed to start battle - either still in battle or battle-end state")
    return false
end

-- Function to mark an enemy as defeated (sets its cooldown)
Utilities.MarkEnemyDefeated = function(enemyName)
    Utilities.DebugPrint("Marking enemy as defeated: " .. tostring(enemyName))
    -- Set cooldown to exactly 10 minutes (600 seconds)
    AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + 600
    Utilities.DebugPrint("Enemy " .. enemyName .. " will be available again in 10 minutes (at " .. os.date("%H:%M:%S", AutoFarmConfig.EnemyCooldowns[enemyName]) .. ")")
end

-- AutoFarm Configuration
local AutoFarmConfig = {
    Enabled = false,
    CurrentWorld = "Ninja Village",
    CurrentEnemy = "unstoppable_fist",
    AutoCollect = false,
    AutoMerge = false,
    AutoFarmAllWorldBosses = false,
    AutoFarmAllEnemiesInSelectedWorlds = false,
    SelectedWorlds = {"Ninja Village"},
    SelectedEnemies = {"unstoppable_fist"},
    WorldBosses = {
        "bijuu_beast",           -- Naruto Rage Mode
        "awakened_galactic_tyrant", -- Frieza
        "king_of_curses",        -- Sukuna
        "combat_giant",          -- Eren
        "awakened_pale_demon_lord", -- Muzan
        "soul_queen",            -- Big Mom
        "awakened_shadow_monarch"  -- Sung Jinwoo
    },
    Interval = 10 * 60, -- 10 minutes cooldown
    Connections = {},
    EnemyCooldowns = {}
}

-- Enemy display names mapping
local EnemyDisplayNames = {
    -- Ninja Village
    unstoppable_fist = "Rock Lee",
    copy_ninja = "Kakashi",
    awakened_dark_avenger = "Sasuke",
    awakened_promised_child = "Naruto Sage Mode",
    six_paths_of_pain = "Pain",
    bijuu_beast = "Naruto Rage Mode (Boss)",
    
    -- Green Village
    ultimate_warrior = "Son Gohan",
    body_switcher = "Captain Ginyu",
    namekian_sage = "Piccolo",
    awakened_prideful_prince = "Vegeta",
    awakened_earth_strongest = "Goku",
    awakened_galactic_tyrant = "Frieza (Boss)",
    
    -- Shibuya Station
    cursed_doll = "Nobara",
    awakened_shadow_summoner = "Megumi",
    cursed_fist = "Yuji",
    rika_blessing = "Yuta",
    limitless_master = "Gojo",
    king_of_curses = "Sukuna (Boss)",
    
    -- Titans City
    survey_commander = "Erwin",
    blade_warrior = "Mikasa",
    armored_giant = "Reiner",
    beast_giant = "Zeke",
    blade_captain = "Levi",
    combat_giant = "Eren (Boss)",
    
    -- Dimensional Fortress
    thunder_demon = "Kaigaku",
    childish_demon = "Hantengu",
    compass_demon = "Akaza",
    awakened_frost_demon = "Doma",
    awakened_six_eyed_slayer = "Kokushibo",
    awakened_pale_demon_lord = "Muzan (Boss)",
    
    -- Candy Island
    genie_commander = "Daifuku",
    candy_master = "Perospero",
    biscuit_warrior = "Cracker",
    juice_queen = "Smoothie",
    mochi_emperor = "Katakuri",
    soul_queen = "Big Mom (Boss)",
    
    -- Solo City
    light_saintess = "Cha Hae-In",
    the_goliath = "Thomas Andre",
    shadow_bear = "Tank",
    shadow_commander = "Igris",
    shadow_ant = "Beru",
    awakened_shadow_monarch = "Sung Jinwoo (Boss)"
}

-- Function to generate enemy display options for dropdown
local function getEnemyDisplayOptions(enemies)
    local displayOptions = {}
    for _, enemyCode in ipairs(enemies) do
        table.insert(displayOptions, EnemyDisplayNames[enemyCode] .. " (" .. enemyCode .. ")")
    end
    return displayOptions
end

-- Function to extract enemy code from display option
local function getEnemyCodeFromDisplayOption(displayOption)
    return string.match(displayOption, "%(([^%)]+)%)")
end

-- Initialize Tabs
local TabDashboard = Window:CreateTab({
    Name = "Dashboard",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabAutoFarm = Window:CreateTab({
    Name = "AutoFarm",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabTowers = Window:CreateTab({
    Name = "Towers",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabRaids = Window:CreateTab({
    Name = "Raids",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabExploration = Window:CreateTab({
    Name = "Exploration",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabShop = Window:CreateTab({
    Name = "Shop",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabMisc = Window:CreateTab({
    Name = "Misc",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabSettings = Window:CreateTab({
    Name = "Settings",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

-- Create Home Tab with information dashboard
Window:CreateHomeTab({
    SupportedExecutors = {"Synapse X", "Script-Ware", "Krnl", "Fluxus", "Electron", "Oxygen U"},
    DiscordInvite = "MythHubDiscord", -- Replace with actual Discord code
    Icon = 2
})

-- Dashboard Tab
TabDashboard:CreateParagraph({
    Title = "Welcome to MythHub - Anime Card Clash",
    Text = "Thank you for choosing MythHub Premium for Anime Card Clash. This script offers a comprehensive suite of features to enhance your gameplay experience. Navigate through the tabs to access various features and automation tools."
})

local stats_section = TabDashboard:CreateSection("Player Statistics")

local player_stats = TabDashboard:CreateParagraph({
    Title = "Player Stats",
    Text = "Loading player statistics..."
})

-- Update player stats periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            local tower_level = Utilities.GetBattleTowerLevel()
            local infinite_floor = Utilities.GetInfiniteTowerFloor()
            local upgrade_points = Utilities.GetUpgradePoints()
            
            player_stats:Set({
                Text = "Battle Tower Level: " .. tower_level .. 
                      "\nInfinite Tower Floor: " .. infinite_floor .. 
                      "\nAvailable Upgrade Points: " .. upgrade_points
            })
        end
    end
end)

TabDashboard:CreateDivider()

TabDashboard:CreateParagraph({
    Title = "Latest Updates",
    Text = "• Added Auto Raid feature with boss detection\n• Improved AutoFarm efficiency and stability\n• Added auto-merge functionality\n• Fixed issues with Tower automation\n• Enhanced UI responsiveness"
})

-- AutoFarm Tab
TabAutoFarm:CreateSection("Enemy Farm Configuration")

-- World selection
local world_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select Worlds",
    Description = "Choose the worlds to farm enemies from",
    Options = {"Ninja Village", "Green Village", "Shibuya Station", "Titans City", "Dimensional Fortress", "Candy Island", "Solo City"},
    CurrentOption = {"Ninja Village"},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Option)
        AutoFarmConfig.SelectedWorlds = Option
        -- Update enemy dropdown based on selected worlds
        updateEnemyDropdown(Option)
    end
}, "WorldSelection")

-- Enemy dropdown (will be updated based on world selection)
local enemy_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select Enemies",
    Description = "Choose the enemies to farm",
    Options = getEnemyDisplayOptions({"unstoppable_fist", "copy_ninja", "awakened_dark_avenger", "awakened_promised_child", "six_paths_of_pain", "bijuu_beast"}),
    CurrentOption = {EnemyDisplayNames["unstoppable_fist"] .. " (unstoppable_fist)"},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Option)
        local selectedEnemies = {}
        for _, displayOption in ipairs(Option) do
            local enemyCode = getEnemyCodeFromDisplayOption(displayOption)
            if enemyCode then
                table.insert(selectedEnemies, enemyCode)
            end
        end
        AutoFarmConfig.SelectedEnemies = selectedEnemies
        AutoFarmConfig.CurrentEnemy = selectedEnemies[1] or "unstoppable_fist"
    end
}, "EnemySelection")

-- Function to update enemy dropdown based on world selection
function updateEnemyDropdown(worlds)
    local allEnemies = {}
    local enemyCodes = {}
    
    -- If no worlds selected, default to Ninja Village
    if #worlds == 0 then
        worlds = {"Ninja Village"}
    end
    
    for _, world in ipairs(worlds) do
        if world == "Ninja Village" then
            for _, enemy in ipairs({"unstoppable_fist", "copy_ninja", "awakened_dark_avenger", "awakened_promised_child", "six_paths_of_pain", "bijuu_beast"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Green Village" then
            for _, enemy in ipairs({"ultimate_warrior", "body_switcher", "namekian_sage", "awakened_prideful_prince", "awakened_earth_strongest", "awakened_galactic_tyrant"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Shibuya Station" then
            for _, enemy in ipairs({"cursed_doll", "awakened_shadow_summoner", "cursed_fist", "rika_blessing", "limitless_master", "king_of_curses"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Titans City" then
            for _, enemy in ipairs({"survey_commander", "blade_warrior", "armored_giant", "beast_giant", "blade_captain", "combat_giant"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Dimensional Fortress" then
            for _, enemy in ipairs({"thunder_demon", "childish_demon", "compass_demon", "awakened_frost_demon", "awakened_six_eyed_slayer", "awakened_pale_demon_lord"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Candy Island" then
            for _, enemy in ipairs({"genie_commander", "candy_master", "biscuit_warrior", "juice_queen", "mochi_emperor", "soul_queen"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Solo City" then
            for _, enemy in ipairs({"light_saintess", "the_goliath", "shadow_bear", "shadow_commander", "shadow_ant", "awakened_shadow_monarch"}) do
                enemyCodes[enemy] = true
            end
        end
    end
    
    -- Convert to array
    for enemyCode, _ in pairs(enemyCodes) do
        table.insert(allEnemies, enemyCode)
    end
    
    -- Get display options
    local displayOptions = getEnemyDisplayOptions(allEnemies)
    
    -- Update dropdown
    enemy_dropdown:Set({
        Options = displayOptions,
        CurrentOption = {displayOptions[1]}
    })
    
    -- Update selected enemies
    AutoFarmConfig.SelectedEnemies = {allEnemies[1] or "unstoppable_fist"}
    AutoFarmConfig.CurrentEnemy = allEnemies[1] or "unstoppable_fist"
end

TabAutoFarm:CreateDivider()
TabAutoFarm:CreateSection("World Bosses")

-- World Boss section (moved from Raid tab)
local world_boss_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select World Boss",
    Description = "Choose a world boss to battle",
    Options = {
        "Naruto Rage Mode (bijuu_beast)",
        "Frieza (awakened_galactic_tyrant)",
        "Sukuna (king_of_curses)",
        "Eren (combat_giant)",
        "Muzan (awakened_pale_demon_lord)",
        "Big Mom (soul_queen)",
        "Sung Jinwoo (awakened_shadow_monarch)"
    },
    CurrentOption = {"Naruto Rage Mode (bijuu_beast)"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        -- Nothing needed here, will be used in the button below
    end
}, "WorldBossSelection")

TabAutoFarm:CreateButton({
    Name = "Summon Selected Boss",
    Description = "Start a battle against the selected world boss",
    Callback = function()
        local boss = world_boss_dropdown.CurrentOption
        if type(boss) == "table" then
            boss = boss[1]
        end
        
        local bossCode = getEnemyCodeFromDisplayOption(boss)
        if bossCode then
            Utilities.SummonEnemy(bossCode)
        end
    end
})

TabAutoFarm:CreateDivider()
TabAutoFarm:CreateSection("Auto Farm Options")

-- Auto Farm All World Bosses toggle
local autofarm_all_bosses_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm All World Bosses",
    Description = "Automatically cycles through all world bosses",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoFarmAllWorldBosses = Value
        
        if Value then
            -- Start auto farm all bosses
            Utilities.DebugPrint("Auto Farm All World Bosses toggle activated")
            Utilities.Notify("Auto Farm", "Started auto farming all world bosses", "auto_mode")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoFarmAllBosses then
                Utilities.DebugPrint("Disconnecting previous Auto Farm All Bosses connection")
                AutoFarmConfig.Connections.AutoFarmAllBosses:Disconnect()
            end
            
            -- Create new auto farm loop
            Utilities.DebugPrint("Starting Auto Farm All Bosses loop for " .. #AutoFarmConfig.WorldBosses .. " bosses")
            AutoFarmConfig.Connections.AutoFarmAllBosses = spawn(function()
                local currentBossIndex = 1
                local currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex] or "bijuu_beast"
                
                while AutoFarmConfig.AutoFarmAllWorldBosses do
                    -- Check if we need to update the current boss (for bosses not on cooldown)
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Try to find a boss that's not on cooldown
                        local allOnCooldown = true
                        local startingIndex = currentBossIndex
                        
                        for i = 1, #AutoFarmConfig.WorldBosses do
                            -- Calculate the next boss index with wrap-around
                            local nextIndex = (startingIndex + i - 1) % #AutoFarmConfig.WorldBosses + 1
                            local nextBoss = AutoFarmConfig.WorldBosses[nextIndex]
                            
                            -- Check if this boss is on cooldown
                            local currentTime = os.time()
                            if not AutoFarmConfig.EnemyCooldowns[nextBoss] or AutoFarmConfig.EnemyCooldowns[nextBoss] <= currentTime then
                                currentBossIndex = nextIndex
                                currentBoss = nextBoss
                                allOnCooldown = false
                                break
                            end
                        end
                        
                        if allOnCooldown then
                            -- All bosses are on cooldown, find the one with the shortest remaining cooldown
                            local shortestCooldown = math.huge
                            local shortestIndex = 1
                            
                            for i = 1, #AutoFarmConfig.WorldBosses do
                                local boss = AutoFarmConfig.WorldBosses[i]
                                local remainingCooldown = (AutoFarmConfig.EnemyCooldowns[boss] or 0) - currentTime
                                
                                if remainingCooldown < shortestCooldown then
                                    shortestCooldown = remainingCooldown
                                    shortestIndex = i
                                end
                            end
                            
                            currentBossIndex = shortestIndex
                            currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex]
                            
                            Utilities.DebugPrint("All bosses on cooldown. Waiting for " .. currentBoss .. " (shortest cooldown: " .. math.max(0, shortestCooldown) .. " seconds)")
                            wait(math.min(5, math.max(1, shortestCooldown))) -- Wait at least 1 second, at most 5 seconds
                        else
                            -- Try to start battle with current boss (which is not on cooldown)
                            Utilities.DebugPrint("Attempting to start battle with boss: " .. tostring(currentBoss))
                            Utilities.StartNextBattle(currentBoss)
                        end
                    elseif Utilities.IsInBattle() then
                        Utilities.DebugPrint("Currently in boss battle with " .. currentBoss .. ", waiting...")
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DebugPrint("Boss battle ended with " .. currentBoss .. ", dismissing end screen")
                        Utilities.DismissBattleEnd()
                        
                        -- Once battle is dismissed, mark the boss as defeated and move to next
                        if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(currentBoss)
                            
                            -- Move to next boss for next iteration
                            currentBossIndex = currentBossIndex % #AutoFarmConfig.WorldBosses + 1
                            currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex]
                        end
                    end
                    
                    -- Wait 1 second before next check
                    wait(1)
                end
            end)
        else
            -- Stop auto farm all bosses
            Utilities.DebugPrint("Auto Farm All World Bosses toggle deactivated")
            Utilities.Notify("Auto Farm", "Stopped auto farming all world bosses", "stop_circle")
            
            -- Disconnect auto farm loop
            if AutoFarmConfig.Connections.AutoFarmAllBosses then
                Utilities.DebugPrint("Disconnecting Auto Farm All Bosses loop")
                AutoFarmConfig.Connections.AutoFarmAllBosses:Disconnect()
                AutoFarmConfig.Connections.AutoFarmAllBosses = nil
            end
        end
    end
}, "AutoFarmAllBossesToggle")

-- Auto Farm All Enemies in Selected Worlds toggle
local autofarm_all_enemies_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm All Selected Enemies",
    Description = "Automatically cycles through all selected enemies in selected worlds",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoFarmAllEnemiesInSelectedWorlds = Value
        
        if Value then
            -- Start auto farm all enemies
            Utilities.DebugPrint("Auto Farm All Selected Enemies toggle activated")
            Utilities.Notify("Auto Farm", "Started auto farming all selected enemies", "auto_mode")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoFarmAllEnemies then
                Utilities.DebugPrint("Disconnecting previous Auto Farm All Enemies connection")
                AutoFarmConfig.Connections.AutoFarmAllEnemies:Disconnect()
            end
            
            -- Create new auto farm loop
            Utilities.DebugPrint("Starting Auto Farm All Enemies loop for " .. #AutoFarmConfig.SelectedEnemies .. " enemies")
            AutoFarmConfig.Connections.AutoFarmAllEnemies = spawn(function()
                local currentEnemyIndex = 1
                local currentEnemy = AutoFarmConfig.SelectedEnemies[currentEnemyIndex] or "unstoppable_fist"
                
                while AutoFarmConfig.AutoFarmAllEnemiesInSelectedWorlds do
                    if #AutoFarmConfig.SelectedEnemies > 0 then
                        -- Check if we can start a battle
                        if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                            -- Try to find an enemy that's not on cooldown
                            local allOnCooldown = true
                            local startingIndex = currentEnemyIndex
                            
                            for i = 1, #AutoFarmConfig.SelectedEnemies do
                                -- Calculate the next enemy index with wrap-around
                                local nextIndex = (startingIndex + i - 1) % #AutoFarmConfig.SelectedEnemies + 1
                                local nextEnemy = AutoFarmConfig.SelectedEnemies[nextIndex]
                                
                                -- Check if this enemy is on cooldown
                                local currentTime = os.time()
                                if not AutoFarmConfig.EnemyCooldowns[nextEnemy] or AutoFarmConfig.EnemyCooldowns[nextEnemy] <= currentTime then
                                    currentEnemyIndex = nextIndex
                                    currentEnemy = nextEnemy
                                    allOnCooldown = false
                                    break
                                end
                            end
                            
                            if allOnCooldown then
                                -- All enemies are on cooldown, find the one with the shortest remaining cooldown
                                local shortestCooldown = math.huge
                                local shortestIndex = 1
                                
                                for i = 1, #AutoFarmConfig.SelectedEnemies do
                                    local enemy = AutoFarmConfig.SelectedEnemies[i]
                                    local remainingCooldown = (AutoFarmConfig.EnemyCooldowns[enemy] or 0) - currentTime
                                    
                                    if remainingCooldown < shortestCooldown then
                                        shortestCooldown = remainingCooldown
                                        shortestIndex = i
                                    end
                                end
                                
                                currentEnemyIndex = shortestIndex
                                currentEnemy = AutoFarmConfig.SelectedEnemies[currentEnemyIndex]
                                
                                Utilities.DebugPrint("All enemies on cooldown. Waiting for " .. currentEnemy .. " (shortest cooldown: " .. math.max(0, shortestCooldown) .. " seconds)")
                                wait(math.min(5, math.max(1, shortestCooldown))) -- Wait at least 1 second, at most 5 seconds
                            else
                                -- Try to start battle with current enemy (which is not on cooldown)
                                Utilities.DebugPrint("Attempting to start battle with: " .. tostring(currentEnemy))
                                Utilities.StartNextBattle(currentEnemy)
                            end
                        elseif Utilities.IsInBattle() then
                            Utilities.DebugPrint("Currently in battle with " .. currentEnemy .. ", waiting...")
                        elseif Utilities.IsBattleEnded() then
                            Utilities.DebugPrint("Battle ended with " .. currentEnemy .. ", dismissing end screen")
                            Utilities.DismissBattleEnd()
                            
                            -- Once battle is dismissed, mark the enemy as defeated and move to next
                            if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                                Utilities.MarkEnemyDefeated(currentEnemy)
                                
                                -- Move to next enemy for next iteration
                                currentEnemyIndex = currentEnemyIndex % #AutoFarmConfig.SelectedEnemies + 1
                                currentEnemy = AutoFarmConfig.SelectedEnemies[currentEnemyIndex]
                            end
                        end
                    else
                        Utilities.DebugPrint("No enemies selected, waiting 5 seconds")
                        wait(5)
                    end
                    
                    -- Wait 1 second before next check
                    wait(1)
                end
            end)
        else
            -- Stop auto farm all enemies
            Utilities.DebugPrint("Auto Farm All Selected Enemies toggle deactivated")
            Utilities.Notify("Auto Farm", "Stopped auto farming all selected enemies", "stop_circle")
            
            -- Disconnect auto farm loop
            if AutoFarmConfig.Connections.AutoFarmAllEnemies then
                Utilities.DebugPrint("Disconnecting Auto Farm All Enemies loop")
                AutoFarmConfig.Connections.AutoFarmAllEnemies:Disconnect()
                AutoFarmConfig.Connections.AutoFarmAllEnemies = nil
            end
        end
    end
}, "AutoFarmAllEnemiesToggle")

-- Auto Farm Toggle
local autofarm_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm Selected Enemy",
    Description = "Automatically spawns the currently selected enemy after cooldown",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.Enabled = Value
        
        if Value then
            -- Start auto farm
            Utilities.DebugPrint("Auto Farm toggle activated for enemy: " .. tostring(AutoFarmConfig.CurrentEnemy))
            Utilities.Notify("Auto Farm", "Started auto farming " .. AutoFarmConfig.CurrentEnemy .. " in " .. table.concat(AutoFarmConfig.SelectedWorlds, ", "), "auto_mode")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoFarm then
                Utilities.DebugPrint("Disconnecting previous Auto Farm connection")
                AutoFarmConfig.Connections.AutoFarm:Disconnect()
            end
            
            -- Create new auto farm loop
            Utilities.DebugPrint("Starting Auto Farm loop")
            AutoFarmConfig.Connections.AutoFarm = spawn(function()
                while AutoFarmConfig.Enabled do
                    Utilities.DebugPrint("Auto Farm loop iteration for enemy: " .. tostring(AutoFarmConfig.CurrentEnemy))
                    
                    -- Check if we can start a battle (not in battle, not at battle end, and enemy not on cooldown)
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Check if enemy is on cooldown
                        local currentTime = os.time()
                        if AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] and AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] > currentTime then
                            local remainingCooldown = math.ceil(AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] - currentTime)
                            Utilities.DebugPrint("Current enemy still on cooldown for " .. remainingCooldown .. " seconds")
                        else
                            -- Try to start a battle with current enemy
                            Utilities.DebugPrint("Attempting to start battle with: " .. tostring(AutoFarmConfig.CurrentEnemy))
                            Utilities.StartNextBattle(AutoFarmConfig.CurrentEnemy)
                        end
                    elseif Utilities.IsInBattle() then
                        Utilities.DebugPrint("Currently in battle, waiting...")
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DebugPrint("Battle ended, attempting to dismiss end screen")
                        Utilities.DismissBattleEnd()
                        
                        -- Once battle is dismissed, mark the enemy as defeated
                        if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(AutoFarmConfig.CurrentEnemy)
                        end
                    end
                    
                    -- Wait 1 second before next check
                    wait(1)
                end
            end)
        else
            -- Stop auto farm
            Utilities.DebugPrint("Auto Farm toggle deactivated")
            Utilities.Notify("Auto Farm", "Stopped auto farming", "stop_circle")
            
            -- Disconnect auto farm loop
            if AutoFarmConfig.Connections.AutoFarm then
                Utilities.DebugPrint("Disconnecting Auto Farm loop")
                AutoFarmConfig.Connections.AutoFarm:Disconnect()
                AutoFarmConfig.Connections.AutoFarm = nil
            end
        end
    end
}, "AutoFarmToggle")

-- Auto collect toggle
local autocollect_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Collect Items",
    Description = "Automatically collects dropped items",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoCollect = Value
        
        if Value then
            -- Start auto collect
            Utilities.Notify("Auto Collect", "Started auto collecting items", "inventory_2")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoCollect then
                AutoFarmConfig.Connections.AutoCollect:Disconnect()
            end
            
            -- Create new auto collect loop
            AutoFarmConfig.Connections.AutoCollect = spawn(function()
                while AutoFarmConfig.AutoCollect do
                    pcall(function()
                        local items = workspace.Folder:GetChildren()
                        
                        for _, item in pairs(items) do
                            if item:IsA("Model") and AutoFarmConfig.AutoCollect then
                                -- Get item position
                                local itemPosition = item:GetPivot().Position
                                
                                -- Get player's character and humanoid root part
                                local character = Utilities.GetLocalPlayer().Character
                                if character and character:FindFirstChild("HumanoidRootPart") then
                                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                                    
                                    -- Tween to the item
                                    local tweenService = game:GetService("TweenService")
                                    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                                    
                                    local tween = tweenService:Create(
                                        humanoidRootPart,
                                        tweenInfo,
                                        {CFrame = CFrame.new(itemPosition)}
                                    )
                                    
                                    tween:Play()
                                    tween.Completed:Wait()
                                    
                                    -- Wait a bit to ensure item is collected
                                    wait(0.1)
                                end
                            end
                        end
                    end)
                    
                    wait(1) -- Wait before checking for new items
                end
            end)
        else
            -- Stop auto collect
            Utilities.Notify("Auto Collect", "Stopped auto collecting items", "stop_circle")
            
            -- Disconnect auto collect loop
            if AutoFarmConfig.Connections.AutoCollect then
                AutoFarmConfig.Connections.AutoCollect:Disconnect()
                AutoFarmConfig.Connections.AutoCollect = nil
            end
        end
    end
}, "AutoCollectToggle")

-- Auto merge toggle
local automerge_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Merge Units",
    Description = "Automatically merges your units",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoMerge = Value
        
        if Value then
            -- Start auto merge
            Utilities.Notify("Auto Merge", "Started auto merging units", "merge")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoMerge then
                AutoFarmConfig.Connections.AutoMerge:Disconnect()
            end
            
            -- Create new auto merge loop
            AutoFarmConfig.Connections.AutoMerge = spawn(function()
                while AutoFarmConfig.AutoMerge do
                    pcall(function()
                        -- Example auto merge code
                        local args = {
                            [1] = 0,
                            [2] = "light_admiral",
                            [3] = 200,
                            [4] = false
                        }
                        
                        game:GetService("ReplicatedStorage"):WaitForChild("noV"):WaitForChild("b57b2bf9-5561-408a-8668-8d7afa1b05f0"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Wait before attempting to merge again
                end
            end)
        else
            -- Stop auto merge
            Utilities.Notify("Auto Merge", "Stopped auto merging units", "stop_circle")
            
            -- Disconnect auto merge loop
            if AutoFarmConfig.Connections.AutoMerge then
                AutoFarmConfig.Connections.AutoMerge:Disconnect()
                AutoFarmConfig.Connections.AutoMerge = nil
            end
        end
    end
}, "AutoMergeToggle")

-- Cooldown slider
local cooldown_slider = TabAutoFarm:CreateSlider({
    Name = "Farm Cooldown (Minutes)",
    Range = {1, 30},
    Increment = 1,
    CurrentValue = 10,
    Callback = function(Value)
        AutoFarmConfig.Interval = Value * 60 -- Convert to seconds
        Utilities.Notify("Cooldown Updated", "Farm cooldown set to " .. Value .. " minutes", "timer")
    end
}, "FarmCooldownSlider")

-- Towers Tab
TabTowers:CreateSection("Battle Tower")

-- Battle Tower level display
local battle_tower_level = TabTowers:CreateLabel({
    Text = "Current Battle Tower Level: " .. Utilities.GetBattleTowerLevel(),
    Style = 1
})

-- Update Battle Tower level periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            battle_tower_level:Set({
                Text = "Current Battle Tower Level: " .. Utilities.GetBattleTowerLevel()
            })
        end
    end
end)

-- Battle Tower level input
local battle_tower_input = TabTowers:CreateInput({
    Name = "Enter Battle Tower Level",
    Description = "Enter a specific tower level (1-100)",
    PlaceholderText = "Enter level (1-100)",
    CurrentValue = "",
    Numeric = true,
    MaxCharacters = 3,
    Enter = true,
    Callback = function(Text)
        local level = tonumber(Text)
        
        if level and level >= 1 and level <= 100 then
            local args = {
                [1] = level
            }
            
            local success, result = pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("c1438c4a-417f-41ee-9363-1ebabcc0bbd9"):FireServer(unpack(args))
            end)
            
            if success then
                Utilities.Notify("Battle Tower", "Starting Battle Tower at level " .. level, "castle")
            else
                Utilities.Notify("Error", "Failed to start Battle Tower", "error")
            end
        else
            Utilities.Notify("Error", "Please enter a valid level between 1 and 100", "error")
        end
    end
}, "BattleTowerLevelInput")

TabTowers:CreateDivider()

TabTowers:CreateSection("Infinite Tower")

-- Infinite Tower floor display
local infinite_tower_floor = TabTowers:CreateLabel({
    Text = "Current Infinite Tower Floor: " .. Utilities.GetInfiniteTowerFloor(),
    Style = 1
})

-- Update Infinite Tower floor periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            infinite_tower_floor:Set({
                Text = "Current Infinite Tower Floor: " .. Utilities.GetInfiniteTowerFloor()
            })
        end
    end
end)

-- Infinite Tower control buttons
TabTowers:CreateButton({
    Name = "Start Infinite Tower",
    Description = "Begin the Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("888b9aa0-9ca6-4c77-9946-cebf1edf613d"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Started Infinite Tower challenge", "castle")
        else
            Utilities.Notify("Error", "Failed to start Infinite Tower", "error")
        end
    end
})

TabTowers:CreateButton({
    Name = "Pause Infinite Tower",
    Description = "Pause the current Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("a8a25480-c0f3-426b-834f-0f95cf058edc"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Paused Infinite Tower challenge", "pause")
        else
            Utilities.Notify("Error", "Failed to pause Infinite Tower", "error")
        end
    end
})

TabTowers:CreateButton({
    Name = "End Infinite Tower",
    Description = "End the current Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("179a96b5-b8d2-4156-a939-6f34c92aa7a6"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Ended Infinite Tower challenge", "stop_circle")
        else
            Utilities.Notify("Error", "Failed to end Infinite Tower", "error")
        end
    end
})

-- Raids Tab
TabRaids:CreateSection("Raid Management")

TabRaids:CreateParagraph({
    Title = "Raid Information",
    Text = "Raids offer exclusive rewards and powerful units. You can start a raid against the Eternal Dragon or other powerful bosses."
})

-- Auto Raid Configuration
local RaidConfig = {
    AutoSummonEternalDragon = false,
    Connections = {}
}

-- Auto Summon Eternal Dragon toggle
local auto_summon_dragon_toggle = TabRaids:CreateToggle({
    Name = "Auto Summon Eternal Dragon",
    Description = "Automatically summons the Eternal Dragon at regular intervals",
    CurrentValue = false,
    Callback = function(Value)
        RaidConfig.AutoSummonEternalDragon = Value
        
        if Value then
            -- Start auto summon
            Utilities.Notify("Auto Raid", "Started auto summoning Eternal Dragon", "security")
            
            -- Clear previous connections if any
            if RaidConfig.Connections.AutoSummonDragon then
                RaidConfig.Connections.AutoSummonDragon:Disconnect()
            end
            
            -- Create new auto summon loop
            RaidConfig.Connections.AutoSummonDragon = spawn(function()
                while RaidConfig.AutoSummonEternalDragon do
                    pcall(function()
                        local args = {
                            [1] = "eternal_dragon"
                        }
                        
                        game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("9f262bf4-f76a-4916-94dc-46596cc25770"):FireServer(unpack(args))
                    end)
                    
                    wait(AutoFarmConfig.Interval) -- Use the same cooldown as auto farm
                end
            end)
        else
            -- Stop auto summon
            Utilities.Notify("Auto Raid", "Stopped auto summoning Eternal Dragon", "stop_circle")
            
            -- Disconnect auto summon loop
            if RaidConfig.Connections.AutoSummonDragon then
                RaidConfig.Connections.AutoSummonDragon:Disconnect()
                RaidConfig.Connections.AutoSummonDragon = nil
            end
        end
    end
}, "AutoSummonDragonToggle")

TabRaids:CreateButton({
    Name = "Summon Eternal Dragon Once",
    Description = "Start a raid against the Eternal Dragon immediately",
    Callback = function()
        local success, result = pcall(function()
            local args = {
                [1] = "eternal_dragon"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("9f262bf4-f76a-4916-94dc-46596cc25770"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Raid Started", "Successfully summoned the Eternal Dragon", "security")
        else
            Utilities.Notify("Error", "Failed to start raid", "error")
        end
    end
})

-- Exploration Tab
TabExploration:CreateSection("Exploration Management")

-- Exploration team configuration
local exploration_difficulty = TabExploration:CreateDropdown({
    Name = "Exploration Difficulty",
    Description = "Select the difficulty level for exploration",
    Options = {"easy", "medium", "hard"},
    CurrentOption = {"easy"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        -- Nothing needed here, will be used in other functions
    end
}, "ExploreDifficulty")

-- Unit selection for exploration
local exploration_units = TabExploration:CreateInput({
    Name = "Exploration Units",
    Description = "Enter 4 unit names separated by commas",
    PlaceholderText = "e.g., dark_avenger,black_swordsman,dark_avenger,dark_avenger",
    CurrentValue = "dark_avenger,black_swordsman,dark_avenger,dark_avenger",
    Numeric = false,
    MaxCharacters = 100,
    Enter = false,
    Callback = function(Text)
        -- Nothing needed here, will be used in the deploy button
    end
}, "ExploreUnits")

TabExploration:CreateButton({
    Name = "Deploy Exploration Team",
    Description = "Send your selected units on an exploration mission",
    Callback = function()
        local difficulty = exploration_difficulty.CurrentOption
        if type(difficulty) == "table" then
            difficulty = difficulty[1]
        end
        
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = difficulty,
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("569ba6a6-d5ea-488e-b729-0f0b6dbaf40c"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for " .. difficulty .. " exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

TabExploration:CreateDivider()

TabExploration:CreateSection("Claim Rewards")

-- Buttons to claim exploration rewards
TabExploration:CreateButton({
    Name = "Claim Easy Exploration Rewards",
    Description = "Claim rewards from easy difficulty explorations",
    Callback = function()
        local args = {
            [1] = "easy"
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("e54723ed-0747-47de-9a09-3153dfb2acd7"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Rewards Claimed", "Successfully claimed easy exploration rewards", "redeem")
        else
            Utilities.Notify("Error", "Failed to claim rewards", "error")
        end
    end
})

TabExploration:CreateButton({
    Name = "Claim Medium Exploration Rewards",
    Description = "Claim rewards from medium difficulty explorations",
    Callback = function()
        local args = {
            [1] = "medium"
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("e54723ed-0747-47de-9a09-3153dfb2acd7"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Rewards Claimed", "Successfully claimed medium exploration rewards", "redeem")
        else
            Utilities.Notify("Error", "Failed to claim rewards", "error")
        end
    end
})

TabExploration:CreateButton({
    Name = "Claim Hard Exploration Rewards",
    Description = "Claim rewards from hard difficulty explorations",
    Callback = function()
        local args = {
            [1] = "hard"
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("3aA"):WaitForChild("e54723ed-0747-47de-9a09-3153dfb2acd7"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Rewards Claimed", "Successfully claimed hard exploration rewards", "redeem")
        else
            Utilities.Notify("Error", "Failed to claim rewards", "error")
        end
    end
})

-- Shop Tab
TabShop:CreateSection("Shop Management")

TabShop:CreateParagraph({
    Title = "Shop Information",
    Text = "Purchase various items from the shop to enhance your gameplay experience."
})

-- Shop items
TabShop:CreateButton({
    Name = "Buy Luck Potion (Small)",
    Description = "Purchase a small luck potion",
    Callback = function()
        Utilities.BuyShopItem("small_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Luck Potion (Medium)",
    Description = "Purchase a medium luck potion",
    Callback = function()
        Utilities.BuyShopItem("medium_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Luck Potion (Large)",
    Description = "Purchase a large luck potion",
    Callback = function()
        Utilities.BuyShopItem("large_luck_potion", 1)
    end
})

TabShop:CreateDivider()

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Small)",
    Description = "Purchase a small cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("small_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Medium)",
    Description = "Purchase a medium cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("medium_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Large)",
    Description = "Purchase a large cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("large_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateDivider()

TabShop:CreateButton({
    Name = "Buy Raid Luck Potion",
    Description = "Purchase a raid luck potion",
    Callback = function()
        Utilities.BuyShopItem("raid_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Border Chance Potion",
    Description = "Purchase a raid border chance potion",
    Callback = function()
        Utilities.BuyShopItem("raid_border_chance_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Cooldown Potion",
    Description = "Purchase a raid cooldown potion",
    Callback = function()
        Utilities.BuyShopItem("raid_cooldown_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Boss Chance Potion",
    Description = "Purchase a raid boss chance potion",
    Callback = function()
        Utilities.BuyShopItem("raid_boss_chance_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Moon Cycle Reroll Potion",
    Description = "Purchase a raid moon cycle reroll potion",
    Callback = function()
        Utilities.BuyShopItem("raid_moon_cycle_reroll_potion", 1)
    end
})

-- Misc Tab
TabMisc:CreateSection("Miscellaneous Features")

-- Enemy Cooldown Display
TabMisc:CreateSection("Enemy Cooldown Information")

local enemy_cooldown_info = TabMisc:CreateParagraph({
    Title = "Enemy Cooldown",
    Text = "All enemies have a 10-minute cooldown after defeating them, including bosses."
})

-- Stats upgrade section
TabMisc:CreateSection("Stats Upgrade")

-- Auto Stats Configuration
local AutoStatsConfig = {
    AutoUpgradeLuck = false,
    AutoUpgradeCooldownReduction = false,
    AutoUpgradePotionDuration = false,
    AutoUpgradeBorderChance = false,
    AutoUpgradeBossChance = false,
    Connections = {}
}

-- Auto Upgrade Luck toggle
local auto_upgrade_luck_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Luck",
    Description = "Automatically upgrades your luck stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeLuck = Value
        
        if Value then
            -- Start auto upgrade
            Utilities.Notify("Auto Stats", "Started auto upgrading Luck stat", "trending_up")
            
            -- Clear previous connections if any
            if AutoStatsConfig.Connections.AutoUpgradeLuck then
                AutoStatsConfig.Connections.AutoUpgradeLuck:Disconnect()
            end
            
            -- Create new auto upgrade loop
            AutoStatsConfig.Connections.AutoUpgradeLuck = spawn(function()
                while AutoStatsConfig.AutoUpgradeLuck do
                    Utilities.UpgradeStat("LUCK")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Stop auto upgrade
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Luck stat", "stop_circle")
            
            -- Disconnect auto upgrade loop
            if AutoStatsConfig.Connections.AutoUpgradeLuck then
                AutoStatsConfig.Connections.AutoUpgradeLuck:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeLuck = nil
            end
        end
    end
}, "AutoUpgradeLuckToggle")

-- Auto Upgrade Cooldown Reduction toggle
local auto_upgrade_cooldown_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Cooldown Reduction",
    Description = "Automatically upgrades your cooldown reduction stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeCooldownReduction = Value
        
        if Value then
            -- Start auto upgrade
            Utilities.Notify("Auto Stats", "Started auto upgrading Cooldown Reduction stat", "trending_up")
            
            -- Clear previous connections if any
            if AutoStatsConfig.Connections.AutoUpgradeCooldownReduction then
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction:Disconnect()
            end
            
            -- Create new auto upgrade loop
            AutoStatsConfig.Connections.AutoUpgradeCooldownReduction = spawn(function()
                while AutoStatsConfig.AutoUpgradeCooldownReduction do
                    Utilities.UpgradeStat("COOLDOWN_REDUCTION")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Stop auto upgrade
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Cooldown Reduction stat", "stop_circle")
            
            -- Disconnect auto upgrade loop
            if AutoStatsConfig.Connections.AutoUpgradeCooldownReduction then
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction = nil
            end
        end
    end
}, "AutoUpgradeCooldownToggle")

-- Auto Upgrade Potion Duration toggle
local auto_upgrade_potion_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Potion Duration",
    Description = "Automatically upgrades your potion duration stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradePotionDuration = Value
        
        if Value then
            -- Start auto upgrade
            Utilities.Notify("Auto Stats", "Started auto upgrading Potion Duration stat", "trending_up")
            
            -- Clear previous connections if any
            if AutoStatsConfig.Connections.AutoUpgradePotionDuration then
                AutoStatsConfig.Connections.AutoUpgradePotionDuration:Disconnect()
            end
            
            -- Create new auto upgrade loop
            AutoStatsConfig.Connections.AutoUpgradePotionDuration = spawn(function()
                while AutoStatsConfig.AutoUpgradePotionDuration do
                    Utilities.UpgradeStat("POTION_DURATION")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Stop auto upgrade
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Potion Duration stat", "stop_circle")
            
            -- Disconnect auto upgrade loop
            if AutoStatsConfig.Connections.AutoUpgradePotionDuration then
                AutoStatsConfig.Connections.AutoUpgradePotionDuration:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradePotionDuration = nil
            end
        end
    end
}, "AutoUpgradePotionToggle")

-- Auto Upgrade Border Chance toggle
local auto_upgrade_border_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Border Chance",
    Description = "Automatically upgrades your border chance stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeBorderChance = Value
        
        if Value then
            -- Start auto upgrade
            Utilities.Notify("Auto Stats", "Started auto upgrading Border Chance stat", "trending_up")
            
            -- Clear previous connections if any
            if AutoStatsConfig.Connections.AutoUpgradeBorderChance then
                AutoStatsConfig.Connections.AutoUpgradeBorderChance:Disconnect()
            end
            
            -- Create new auto upgrade loop
            AutoStatsConfig.Connections.AutoUpgradeBorderChance = spawn(function()
                while AutoStatsConfig.AutoUpgradeBorderChance do
                    Utilities.UpgradeStat("BORDER_CHANCE")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Stop auto upgrade
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Border Chance stat", "stop_circle")
            
            -- Disconnect auto upgrade loop
            if AutoStatsConfig.Connections.AutoUpgradeBorderChance then
                AutoStatsConfig.Connections.AutoUpgradeBorderChance:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeBorderChance = nil
            end
        end
    end
}, "AutoUpgradeBorderToggle")

-- Auto Upgrade Boss Chance toggle
local auto_upgrade_boss_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Boss Chance",
    Description = "Automatically upgrades your boss chance stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeBossChance = Value
        
        if Value then
            -- Start auto upgrade
            Utilities.Notify("Auto Stats", "Started auto upgrading Boss Chance stat", "trending_up")
            
            -- Clear previous connections if any
            if AutoStatsConfig.Connections.AutoUpgradeBossChance then
                AutoStatsConfig.Connections.AutoUpgradeBossChance:Disconnect()
            end
            
            -- Create new auto upgrade loop
            AutoStatsConfig.Connections.AutoUpgradeBossChance = spawn(function()
                while AutoStatsConfig.AutoUpgradeBossChance do
                    Utilities.UpgradeStat("BOSS_CHANCE")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Stop auto upgrade
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Boss Chance stat", "stop_circle")
            
            -- Disconnect auto upgrade loop
            if AutoStatsConfig.Connections.AutoUpgradeBossChance then
                AutoStatsConfig.Connections.AutoUpgradeBossChance:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeBossChance = nil
            end
        end
    end
}, "AutoUpgradeBossToggle")

-- Manual upgrade buttons
TabMisc:CreateButton({
    Name = "Upgrade Luck (Once)",
    Description = "Upgrade your luck stat once",
    Callback = function()
        Utilities.UpgradeStat("LUCK")
    end
})

TabMisc:CreateButton({
    Name = "Upgrade Cooldown Reduction (Once)",
    Description = "Upgrade your cooldown reduction stat once",
    Callback = function()
        Utilities.UpgradeStat("COOLDOWN_REDUCTION")
    end
})

TabMisc:CreateButton({
    Name = "Upgrade Potion Duration (Once)",
    Description = "Upgrade your potion duration stat once",
    Callback = function()
        Utilities.UpgradeStat("POTION_DURATION")
    end
})

TabMisc:CreateButton({
    Name = "Upgrade Border Chance (Once)",
    Description = "Upgrade your border chance stat once",
    Callback = function()
        Utilities.UpgradeStat("BORDER_CHANCE")
    end
})

TabMisc:CreateButton({
    Name = "Upgrade Boss Chance (Once)",
    Description = "Upgrade your boss chance stat once",
    Callback = function()
        Utilities.UpgradeStat("BOSS_CHANCE")
    end
})

-- Theme and Config sections
TabSettings:BuildThemeSection()
TabSettings:BuildConfigSection()

-- Enable autoload config
Luna:LoadAutoloadConfig()

-- Add debug console to the game
Utilities.CreateDebugConsole = function()
    Utilities.DebugPrint("Attempting to create debug console GUI")
    
    -- Check if console already exists
    local player = Utilities.GetLocalPlayer()
    if player and player.PlayerGui and player.PlayerGui:FindFirstChild("MythHubConsole") then
        Utilities.DebugPrint("Debug console already exists, not creating a new one")
        return
    end
    
    -- Create console GUI
    pcall(function()
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "MythHubConsole"
        screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        screenGui.ResetOnSpawn = false
        
        local frame = Instance.new("Frame")
        frame.Name = "ConsoleFrame"
        frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        frame.BackgroundTransparency = 0.2
        frame.BorderSizePixel = 0
        frame.Position = UDim2.new(0, 10, 0, 10)
        frame.Size = UDim2.new(0, 400, 0, 300)
        frame.Parent = screenGui
        
        local title = Instance.new("TextLabel")
        title.Name = "Title"
        title.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        title.BackgroundTransparency = 0.2
        title.BorderSizePixel = 0
        title.Size = UDim2.new(1, 0, 0, 30)
        title.Font = Enum.Font.SourceSansBold
        title.Text = "MythHub Debug Console"
        title.TextColor3 = Color3.fromRGB(255, 255, 255)
        title.TextSize = 18
        title.Parent = frame
        
        local closeButton = Instance.new("TextButton")
        closeButton.Name = "CloseButton"
        closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
        closeButton.BorderSizePixel = 0
        closeButton.Position = UDim2.new(1, -25, 0, 5)
        closeButton.Size = UDim2.new(0, 20, 0, 20)
        closeButton.Font = Enum.Font.SourceSansBold
        closeButton.Text = "X"
        closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        closeButton.TextSize = 14
        closeButton.Parent = title
        
        local console = Instance.new("ScrollingFrame")
        console.Name = "Console"
        console.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        console.BackgroundTransparency = 0
        console.BorderSizePixel = 0
        console.Position = UDim2.new(0, 5, 0, 35)
        console.Size = UDim2.new(1, -10, 1, -40)
        console.CanvasSize = UDim2.new(0, 0, 0, 0)
        console.ScrollBarThickness = 8
        console.AutomaticCanvasSize = Enum.AutomaticSize.Y
        console.ScrollingDirection = Enum.ScrollingDirection.Y
        console.Parent = frame
        
        local text = Instance.new("TextLabel")
        text.Name = "Text"
        text.BackgroundTransparency = 1
        text.Position = UDim2.new(0, 5, 0, 5)
        text.Size = UDim2.new(1, -18, 0, 1000)
        text.CanvasSize = UDim2.new(0, 0, 0, 1000)
        text.Font = Enum.Font.SourceSans
        text.Text = "-- MythHub Debug Console Initialized --"
        text.TextColor3 = Color3.fromRGB(200, 200, 200)
        text.TextSize = 14
        text.TextXAlignment = Enum.TextXAlignment.Left
        text.TextYAlignment = Enum.TextYAlignment.Top
        text.TextWrapped = true
        text.Parent = console
        
        -- Make the console draggable
        local dragging
        local dragInput
        local dragStart
        local startPos
        
        local function update(input)
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
        
        title.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = frame.Position
                
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        
        title.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                dragInput = input
            end
        end)
        
        game:GetService("UserInputService").InputChanged:Connect(function(input)
            if input == dragInput and dragging then
                update(input)
            end
        end)
        
        closeButton.MouseButton1Click:Connect(function()
            screenGui.Enabled = false
        end)
        
        screenGui.Parent = player.PlayerGui
        Utilities.DebugPrint("Debug console created successfully")
    end)
end

-- Initialize debug console when script loads
spawn(function()
    wait(1) -- Wait a bit to ensure player is loaded
    Utilities.CreateDebugConsole()
end)

-- Create button to toggle console visibility in settings
TabSettings:CreateButton({
    Name = "Toggle Debug Console",
    Description = "Show or hide the debug console",
    Callback = function()
        local player = Utilities.GetLocalPlayer()
        if player and player.PlayerGui then
            local console = player.PlayerGui:FindFirstChild("MythHubConsole")
            if console then
                console.Enabled = not console.Enabled
                Utilities.Notify("Debug Console", console.Enabled and "Console shown" or "Console hidden", "settings")
            else
                Utilities.CreateDebugConsole()
                Utilities.Notify("Debug Console", "Console created", "settings")
            end
        end
    end
})
