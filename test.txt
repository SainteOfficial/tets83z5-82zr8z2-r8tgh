--[[
    MythHub Premium
    Game: Anime Card Clash
    Created by: MythTeam
    
    Features:
    - Dashboard with information and statistics
    - AutoFarm for enemies from all worlds
    - Tower automation for Battle and Infinite Towers
    - Raid support and automation
    - Exploration management
    - Shop automation
    - Various utilities such as Auto-Pickup, Auto-Merge and more
    
    Last Updated: May 2025
]]

print("Nothing to see here :O")

-- Load Luna Interface Library
local Luna = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/refs/heads/main/source.lua", true))()

-- Initialize Window without Key System
local Window = Luna:CreateWindow({
    Name = "MythHub Premium",
    Subtitle = "Anime Card Clash",
    LogoID = "134758479713826", -- MythHub logo ID
    LoadingEnabled = true,
    LoadingTitle = "MythHub Premium",
    LoadingSubtitle = "Anime Card Clash Edition",
    
    ConfigSettings = {
        RootFolder = "MythHub",
        ConfigFolder = "AnimeCardClash"
    },
    
    KeySystem = false
})

-- Utility Functions
local Utilities = {}

-- Add a safer WaitForChild function with timeout
Utilities.SafeWaitForChild = function(parent, childName, timeout)
    timeout = timeout or 10 -- Default timeout of 10 seconds
    
    local startTime = os.time()
    local child = nil
    
    -- Try to find the child until it's found or timeout is reached
    while not child and os.time() - startTime < timeout do
        child = parent:FindFirstChild(childName)
        if child then
            return child
        end
        wait(0.1) -- Short wait to not consume too much CPU
    end
    
    -- If the child was not found, output a warning
    if not child then
        warn("SafeWaitForChild: Could not find " .. childName .. " in " .. parent.Name .. " (Timeout after " .. timeout .. " seconds)")
        return nil
    end
    
    return child
end

-- Function to summon an enemy for battle
Utilities.SummonEnemy = function(enemyName)
    if not enemyName then
        return false
    end
    
    local success, result = pcall(function()
        local args = {
            [1] = enemyName
        }
        
        local replicatedStorage = game:GetService("ReplicatedStorage")
        -- Verwende SafeWaitForChild statt WaitForChild, um Infinite Yield zu vermeiden
        local childkQR = Utilities.SafeWaitForChild(replicatedStorage, "kQR", 5)
        if not childkQR then
            return false
        end
        
        local battleRemote = Utilities.SafeWaitForChild(childkQR, "8a63919a-217b-436a-9cfa-4b472d213bbb", 3)
        if not battleRemote then
            return false
        end
        
        battleRemote:FireServer(unpack(args))
        return true
    end)
    
    if not success then
        warn("SummonEnemy fehlgeschlagen: " .. tostring(result))
        return false
    end
    
    return true
end

-- Function to get local player
Utilities.GetLocalPlayer = function()
    return game:GetService("Players").LocalPlayer
end

-- Function to check if a player is in game
Utilities.IsInGame = function()
    return game:IsLoaded() and Utilities.GetLocalPlayer() ~= nil
end

-- Function to create notifications
Utilities.Notify = function(title, content, icon)
    Luna:Notification({
        Title = title or "MythHub Notification",
        Content = content or "Action completed successfully",
        Icon = icon or "notifications_active",
        ImageSource = "Material"
    })
end

-- Function to get Battle Tower level
Utilities.GetBattleTowerLevel = function()
    local success, result = pcall(function()
        local replicatedStorage = game:GetService("ReplicatedStorage")
        local TS = Utilities.SafeWaitForChild(replicatedStorage, "TS", 5)
        if not TS then return 1 end
        
        local user = Utilities.SafeWaitForChild(TS, "user", 3)
        if not user then return 1 end
        
        local localFolder = Utilities.SafeWaitForChild(user, "local", 3)
        if not localFolder then return 1 end
        
        local LocalUserModule = Utilities.SafeWaitForChild(localFolder, "local-user", 3)
        if not LocalUserModule then return 1 end
        
        local LocalUser = require(LocalUserModule).LocalUser
        local battleTowerWave = LocalUser.metadata:getAsNumber("battle_tower_wave")
        return battleTowerWave or 1
    end)
    
    if success then
        return result
    else
        return 1
    end
end

-- Function to get Infinite Tower floor
Utilities.GetInfiniteTowerFloor = function()
    local success, result = pcall(function()
        local LocalUser = require(game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        
        if LocalUser and LocalUser.infiniteTower then
            local document = LocalUser.infiniteTower:getDocument()
            if document and document.floor then
                return document.floor
            end
        end
        return 1
    end)
    
    if success and result then
        return result
    else
        return 1
    end
end

-- Function to get available upgrade points
Utilities.GetUpgradePoints = function()
    local success, result = pcall(function()
        local LocalUser = require(game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        return LocalUser.upgrades:getCards()
    end)
    
    if success then
        return result
    else
        return 0
    end
end

-- Function to check if player is in battle
Utilities.IsInBattle = function()
    local success, result = pcall(function()
        local localPlayer = Utilities.GetLocalPlayer()
        if localPlayer and localPlayer.PlayerGui then
            -- Prüft, ob eine der Kampf-GUIs existiert
            local hasBattleGui = localPlayer.PlayerGui:FindFirstChild("battle") ~= nil
            local hasHideBattleButton = localPlayer.PlayerGui:FindFirstChild("HideBattleButton") ~= nil
            
            -- Wenn eine der beiden GUIs existiert, ist der Spieler noch im Kampf
            return hasBattleGui or hasHideBattleButton
        end
        return false
    end)
    
    if success then
        return result
    else
        return false
    end
end

-- Function to check if battle just ended
Utilities.IsBattleEnded = function()
    local success, result = pcall(function()
        local localPlayer = Utilities.GetLocalPlayer()
        if localPlayer and localPlayer.PlayerGui then
            local hasBattleEndGui = localPlayer.PlayerGui:FindFirstChild("battle-end") ~= nil
            return hasBattleEndGui
        end
        return false
    end)
    
    if success then
        return result
    else
        return false
    end
end

-- Function to simulate mouse clicks (M1) in the middle-bottom of the screen
Utilities.ClickM1 = function(times)
    times = times or 10
    
    pcall(function()
        -- Get screen size
        local screenSize = workspace.CurrentCamera.ViewportSize
        local middleX = screenSize.X / 2
        local lowerY = screenSize.Y * 0.7 -- 70% down the screen (middle-bottom)
        
        for i = 1, times do
            game:GetService("VirtualInputManager"):SendMouseButtonEvent(middleX, lowerY, 0, true, game, 1)
            wait(0.1)
            game:GetService("VirtualInputManager"):SendMouseButtonEvent(middleX, lowerY, 0, false, game, 1)
            wait(0.1)
        end
    end)
end

-- Function to dismiss battle end screen
Utilities.DismissBattleEnd = function()
    -- Sicherheitsüberprüfung mit pcall
    pcall(function()
        if Utilities.IsBattleEnded() then
            wait(3)
            
            -- Klicke M1 wiederholt, bis der Endbildschirm weg ist
            local maxAttempts = 30 -- Maximale Versuche, um Endlosschleifen zu vermeiden
            local attempts = 0
            
            while Utilities.IsBattleEnded() and attempts < maxAttempts do
                -- Versuche, mit M1 zu klicken
                pcall(function()
                    Utilities.ClickM1(3)
                end)
                wait(0.5)
                attempts = attempts + 1
            end
            
            -- Etwas länger warten, um sicherzustellen, dass alles geschlossen ist
            wait(1)
        end
    end)
end

-- AutoFarm Configuration
local AutoFarmConfig = {
    Enabled = false,
    CurrentWorld = "Ninja Village",
    CurrentEnemy = "unstoppable_fist",
    AutoCollect = false,
    AutoMerge = false,
    AutoFarmAllWorldBosses = false,
    AutoFarmAllEnemies = false,
    SelectedWorlds = {"Ninja Village"},
    SelectedEnemies = {"unstoppable_fist"},
    WorldBosses = {
        "bijuu_beast",           -- Naruto Rage Mode
        "awakened_galactic_tyrant", -- Frieza
        "king_of_curses",        -- Sukuna
        "combat_giant",          -- Eren
        "awakened_pale_demon_lord", -- Muzan
        "soul_queen",            -- Big Mom
        "awakened_shadow_monarch"  -- Sung Jinwoo
    },
    AllEnemies = {
        -- Ninja Village
        "unstoppable_fist", -- Rock Lee
        "copy_ninja", -- Kakashi
        "awakened_dark_avenger", -- Sasuke
        "awakened_promised_child", -- Naruto Sage Mode
        "six_paths_of_pain", -- Pain
        "bijuu_beast", -- Naruto Rage Mode (Boss)
        
        -- Green Village
        "ultimate_warrior", -- Son Gohan
        "body_switcher", -- Captain Ginyu
        "namekian_sage", -- Piccolo
        "awakened_prideful_prince", -- Vegeta
        "awakened_earth_strongest", -- Goku
        "awakened_galactic_tyrant", -- Frieza (Boss)
        
        -- Shibuya Station
        "cursed_doll", -- Nobara
        "awakened_shadow_summoner", -- Megumi
        "cursed_fist", -- Yuji
        "rika_blessing", -- Yuta
        "limitless_master", -- Gojo
        "king_of_curses", -- Sukuna (Boss)
        
        -- Titans City
        "survey_commander", -- Erwin
        "blade_warrior", -- Mikasa
        "armored_giant", -- Reiner
        "beast_giant", -- Zeke
        "blade_captain", -- Levi
        "combat_giant", -- Eren (Boss)
        
        -- Dimensional Fortress
        "thunder_demon", -- Kaigaku
        "childish_demon", -- Hantengu
        "compass_demon", -- Akaza
        "awakened_frost_demon", -- Doma
        "awakened_six_eyed_slayer", -- Kokushibo
        "awakened_pale_demon_lord", -- Muzan (Boss)
        
        -- Candy Island
        "genie_commander", -- Daifuku
        "candy_master", -- Perospero
        "biscuit_warrior", -- Cracker
        "juice_queen", -- Smoothie
        "mochi_emperor", -- Katakuri
        "soul_queen", -- Big Mom (Boss)
        
        -- Solo City
        "light_saintess", -- Cha Hae-In
        "the_goliath", -- Thomas Andre
        "shadow_bear", -- Tank
        "shadow_commander", -- Igris
        "shadow_ant", -- Beru
        "awakened_shadow_monarch" -- Sung Jinwoo (Boss)
    },
    Interval = 10 * 60, -- 10 minutes cooldown
    Connections = {},
    EnemyCooldowns = {} -- Stellen wir sicher, dass dies als leeres Table initialisiert wird
}

-- Funktion, um sicherzustellen, dass EnemyCooldowns existiert
Utilities.EnsureEnemyCooldownsInitialized = function()
    if not AutoFarmConfig.EnemyCooldowns then
        AutoFarmConfig.EnemyCooldowns = {}
    end
end

-- Function to handle battle flow and start next battle
Utilities.StartNextBattle = function(enemyName)
    -- Sicherheitsüberprüfung für nil
    if not enemyName then
        return false
    end
    
    -- Stellen wir sicher, dass EnemyCooldowns existiert
    Utilities.EnsureEnemyCooldownsInitialized()
    
    -- Cooldown-Überprüfung mit Fehlerbehandlung
    local onCooldown = false
    pcall(function()
        local currentTime = os.time()
        if enemyName and AutoFarmConfig.EnemyCooldowns[enemyName] and AutoFarmConfig.EnemyCooldowns[enemyName] > currentTime then
            onCooldown = true
        end
    end)
    
    if onCooldown then
        return false
    end
    
    -- Überprüfung des Spielstatus mit Fehlerbehandlung
    local inBattle = Utilities.IsInBattle()
    local battleEnded = Utilities.IsBattleEnded()
    
    if inBattle then
        return false -- Bereits im Kampf, kann keinen neuen starten
    end
    
    if battleEnded then
        pcall(function()
            Utilities.DismissBattleEnd()
        end)
        wait(1) -- Kurz warten, um sicherzustellen, dass der Endbildschirm weg ist
        return false
    end
    
    -- Erneute Überprüfung, ob wir den Kampf starten können
    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
        local success = false
        
        -- Versuche, den Gegner zu beschwören
        pcall(function()
            local args = {
                [1] = enemyName
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
            success = true
        end)
        
        if success then
            -- Warten, damit der Kampf gestartet werden kann
            wait(2)
            
            -- Prüfen, ob wir im Kampf sind
            if Utilities.IsInBattle() then
                return true
            else
                -- Wenn wir nicht im Kampf sind, obwohl wir den Gegner beschworen haben, könnte er auf Cooldown sein
                pcall(function()
                    if enemyName and not (enemyName == "eternal_dragon" or enemyName == "shadow_dragon") then
                        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + AutoFarmConfig.Interval
                    end
                end)
                return false
            end
        end
        
        return success
    end
    
    return false
end

-- Function to mark an enemy as defeated (sets its cooldown)
Utilities.MarkEnemyDefeated = function(enemyName)
    if not enemyName then
        return
    end
    
    -- Check if enemy is a raid boss (eternal_dragon or shadow_dragon) or world boss
    local isRaidBoss = (enemyName == "eternal_dragon" or enemyName == "shadow_dragon")
    local isWorldBoss = false
    
    -- Check if it's a world boss
    for _, boss in ipairs(AutoFarmConfig.WorldBosses) do
        if enemyName == boss then
            isWorldBoss = true
            break
        end
    end
    
    -- Only set cooldown if it's not a raid boss
    if isRaidBoss then
        return
    elseif isWorldBoss then
        -- Still apply cooldown for world bosses (not raid bosses)
        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + 600
    else
        -- Set cooldown to exactly 10 minutes (600 seconds) for regular enemies
        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + 600
    end
end

-- Enemy display names mapping
local EnemyDisplayNames = {
    -- Ninja Village
    unstoppable_fist = "Rock Lee",
    copy_ninja = "Kakashi",
    awakened_dark_avenger = "Sasuke",
    awakened_promised_child = "Naruto Sage Mode",
    six_paths_of_pain = "Pain",
    bijuu_beast = "Naruto Rage Mode (Boss)",
    
    -- Green Village
    ultimate_warrior = "Son Gohan",
    body_switcher = "Captain Ginyu",
    namekian_sage = "Piccolo",
    awakened_prideful_prince = "Vegeta",
    awakened_earth_strongest = "Goku",
    awakened_galactic_tyrant = "Frieza (Boss)",
    
    -- Shibuya Station
    cursed_doll = "Nobara",
    awakened_shadow_summoner = "Megumi",
    cursed_fist = "Yuji",
    rika_blessing = "Yuta",
    limitless_master = "Gojo",
    king_of_curses = "Sukuna (Boss)",
    
    -- Titans City
    survey_commander = "Erwin",
    blade_warrior = "Mikasa",
    armored_giant = "Reiner",
    beast_giant = "Zeke",
    blade_captain = "Levi",
    combat_giant = "Eren (Boss)",
    
    -- Dimensional Fortress
    thunder_demon = "Kaigaku",
    childish_demon = "Hantengu",
    compass_demon = "Akaza",
    awakened_frost_demon = "Doma",
    awakened_six_eyed_slayer = "Kokushibo",
    awakened_pale_demon_lord = "Muzan (Boss)",
    
    -- Candy Island
    genie_commander = "Daifuku",
    candy_master = "Perospero",
    biscuit_warrior = "Cracker",
    juice_queen = "Smoothie",
    mochi_emperor = "Katakuri",
    soul_queen = "Big Mom (Boss)",
    
    -- Solo City
    light_saintess = "Cha Hae-In",
    the_goliath = "Thomas Andre",
    shadow_bear = "Tank",
    shadow_commander = "Igris",
    shadow_ant = "Beru",
    awakened_shadow_monarch = "Sung Jinwoo (Boss)"
}

-- Function to generate enemy display options for dropdown
local function getEnemyDisplayOptions(enemies)
    local displayOptions = {}
    for _, enemyCode in ipairs(enemies) do
        table.insert(displayOptions, EnemyDisplayNames[enemyCode] .. " (" .. enemyCode .. ")")
    end
    return displayOptions
end

-- Function to extract enemy code from display option
local function getEnemyCodeFromDisplayOption(displayOption)
    return string.match(displayOption, "%(([^%)]+)%)")
end

-- Initialize Tabs
local TabDashboard = Window:CreateTab({
    Name = "Dashboard",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabAutoFarm = Window:CreateTab({
    Name = "AutoFarm",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabTowers = Window:CreateTab({
    Name = "Towers",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabRaids = Window:CreateTab({
    Name = "Raids",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabExploration = Window:CreateTab({
    Name = "Exploration",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabShop = Window:CreateTab({
    Name = "Shop",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabMisc = Window:CreateTab({
    Name = "Misc",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabSettings = Window:CreateTab({
    Name = "Settings",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

-- Create Home Tab with information dashboard
Window:CreateHomeTab({
    SupportedExecutors = {}, -- Kein Executor-Check, damit der Script für alle funktioniert
    DiscordInvite = "MythHubDiscord",
    Icon = 2
})

-- Dashboard Tab
TabDashboard:CreateParagraph({
    Title = "Welcome to MythHub Premium - Anime Card Clash",
    Text = "Thank you for choosing MythHub Premium for Anime Card Clash. This script offers a comprehensive suite of features to enhance your gameplay experience. Our premium features are optimized for the best executors on the market."
})

TabDashboard:CreateSection("Player Statistics")

local stats_section = TabDashboard:CreateParagraph({
    Title = "Your Statistics",
    Text = "Loading player statistics..."
})

-- Update player stats periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            local tower_level = Utilities.GetBattleTowerLevel()
            local infinite_floor = Utilities.GetInfiniteTowerFloor()
            local upgrade_points = Utilities.GetUpgradePoints()
            
            stats_section:Set({
                Text = "Battle Tower Level: " .. tower_level .. 
                      "\nInfinite Tower Floor: " .. infinite_floor .. 
                      "\nAvailable Upgrade Points: " .. upgrade_points
            })
        end
    end
end)

TabDashboard:CreateDivider()

-- Add executor compatibility warning
TabDashboard:CreateSection("Executor Compatibility")

TabDashboard:CreateParagraph({
    Title = "Free Executor Limitations",
    Text = "Please note that free executors may not support all features due to their limitations. Specifically:\n\n• Battle Tower automation will not work properly\n• Stat Points features are incompatible with free executors\n\nOther features like AutoFarm and basic automation should function normally. For the best experience, we recommend using premium executors such as Synapse X, Script-Ware, or Fluxus."
})

TabDashboard:CreateDivider()

TabDashboard:CreateSection("Latest Updates")

TabDashboard:CreateParagraph({
    Title = "Recent Changes",
    Text = "• Added Auto Raid function with boss detection\n• Improved AutoFarm efficiency and stability\n• Added Auto-Merge functionality\n• Fixed issues with Tower automation\n• Improved UI responsiveness"
})

-- Add premium features highlight
TabDashboard:CreateDivider()

TabDashboard:CreateSection("Premium Features")

TabDashboard:CreateParagraph({
    Title = "MythHub Premium Advantages",
    Text = "• Advanced Battle Tower automation (Premium executors only)\n• Stat Points optimization system\n• Multi-world boss farming\n• Intelligent cooldown management\n• Automatic exploration team management\n• Premium support via our Discord"
})

-- AutoFarm Tab
TabAutoFarm:CreateSection("Enemy Farm Configuration")

-- World selection
local world_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select Worlds",
    Description = "Choose the worlds to farm enemies from",
    Options = {"Ninja Village", "Green Village", "Shibuya Station", "Titans City", "Dimensional Fortress", "Candy Island", "Solo City"},
    CurrentOption = {"Ninja Village"},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Option)
        AutoFarmConfig.SelectedWorlds = Option
        -- Update enemy dropdown based on selected worlds
        updateEnemyDropdown(Option)
    end
}, "WorldSelection")

-- Enemy dropdown (will be updated based on world selection)
local enemy_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select Enemies",
    Description = "Choose the enemies to farm",
    Options = getEnemyDisplayOptions({"unstoppable_fist", "copy_ninja", "awakened_dark_avenger", "awakened_promised_child", "six_paths_of_pain", "bijuu_beast"}),
    CurrentOption = {EnemyDisplayNames["unstoppable_fist"] .. " (unstoppable_fist)"},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Option)
        local selectedEnemies = {}
        for _, displayOption in ipairs(Option) do
            local enemyCode = getEnemyCodeFromDisplayOption(displayOption)
            if enemyCode then
                table.insert(selectedEnemies, enemyCode)
            end
        end
        AutoFarmConfig.SelectedEnemies = selectedEnemies
        AutoFarmConfig.CurrentEnemy = selectedEnemies[1] or "unstoppable_fist"
    end
}, "EnemySelection")

-- Function to update enemy dropdown based on world selection
function updateEnemyDropdown(worlds)
    local allEnemies = {}
    local enemyCodes = {}
    
    -- If no worlds selected, default to Ninja Village
    if #worlds == 0 then
        worlds = {"Ninja Village"}
    end
    
    for _, world in ipairs(worlds) do
        if world == "Ninja Village" then
            for _, enemy in ipairs({"unstoppable_fist", "copy_ninja", "awakened_dark_avenger", "awakened_promised_child", "six_paths_of_pain", "bijuu_beast"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Green Village" then
            for _, enemy in ipairs({"ultimate_warrior", "body_switcher", "namekian_sage", "awakened_prideful_prince", "awakened_earth_strongest", "awakened_galactic_tyrant"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Shibuya Station" then
            for _, enemy in ipairs({"cursed_doll", "awakened_shadow_summoner", "cursed_fist", "rika_blessing", "limitless_master", "king_of_curses"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Titans City" then
            for _, enemy in ipairs({"survey_commander", "blade_warrior", "armored_giant", "beast_giant", "blade_captain", "combat_giant"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Dimensional Fortress" then
            for _, enemy in ipairs({"thunder_demon", "childish_demon", "compass_demon", "awakened_frost_demon", "awakened_six_eyed_slayer", "awakened_pale_demon_lord"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Candy Island" then
            for _, enemy in ipairs({"genie_commander", "candy_master", "biscuit_warrior", "juice_queen", "mochi_emperor", "soul_queen"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Solo City" then
            for _, enemy in ipairs({"light_saintess", "the_goliath", "shadow_bear", "shadow_commander", "shadow_ant", "awakened_shadow_monarch"}) do
                enemyCodes[enemy] = true
            end
        end
    end
    
    -- Convert to array
    for enemyCode, _ in pairs(enemyCodes) do
        table.insert(allEnemies, enemyCode)
    end
    
    -- Get display options
    local displayOptions = getEnemyDisplayOptions(allEnemies)
    
    -- Update dropdown
    enemy_dropdown:Set({
        Options = displayOptions,
        CurrentOption = {displayOptions[1]}
    })
    
    -- Update selected enemies
    AutoFarmConfig.SelectedEnemies = {allEnemies[1] or "unstoppable_fist"}
    AutoFarmConfig.CurrentEnemy = allEnemies[1] or "unstoppable_fist"
end

TabAutoFarm:CreateDivider()
TabAutoFarm:CreateSection("World Bosses")

-- World Boss section (moved from Raid tab)
local world_boss_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select World Boss",
    Description = "Choose a world boss to battle",
    Options = {
        "Naruto Rage Mode (bijuu_beast)",
        "Frieza (awakened_galactic_tyrant)",
        "Sukuna (king_of_curses)",
        "Eren (combat_giant)",
        "Muzan (awakened_pale_demon_lord)",
        "Big Mom (soul_queen)",
        "Sung Jinwoo (awakened_shadow_monarch)"
    },
    CurrentOption = {"Naruto Rage Mode (bijuu_beast)"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        -- Nothing needed here, will be used in the button below
    end
}, "WorldBossSelection")

TabAutoFarm:CreateButton({
    Name = "Fight Selected Boss",
    Description = "Start a battle against the selected world boss",
    Callback = function()
        local boss = world_boss_dropdown.CurrentOption
        if type(boss) == "table" then
            boss = boss[1]
        end
        
        local bossCode = getEnemyCodeFromDisplayOption(boss)
        if bossCode then
            Utilities.SummonEnemy(bossCode)
        end
    end
})

TabAutoFarm:CreateDivider()
TabAutoFarm:CreateSection("Auto Farm Options")

-- Auto Farm All World Bosses toggle
local autofarm_all_bosses_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm All World Bosses",
    Description = "Automatically cycles through all world bosses",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoFarmAllWorldBosses = Value
        
        if Value then
            -- Start auto farm all bosses
            Utilities.Notify("Auto Farm", "Started auto farming all world bosses", "auto_mode")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoFarmAllBosses then
                AutoFarmConfig.Connections.AutoFarmAllBosses:Disconnect()
            end
            
            -- Create new auto farm loop
            AutoFarmConfig.Connections.AutoFarmAllBosses = spawn(function()
                local currentBossIndex = 1
                local currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex] or "bijuu_beast"
                
                while AutoFarmConfig.AutoFarmAllWorldBosses do
                    -- Check if we need to update the current boss (for bosses not on cooldown)
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Try to find a boss that's not on cooldown
                        local allOnCooldown = true
                        local startingIndex = currentBossIndex
                        
                        for i = 1, #AutoFarmConfig.WorldBosses do
                            -- Calculate the next boss index with wrap-around
                            local nextIndex = (startingIndex + i - 1) % #AutoFarmConfig.WorldBosses + 1
                            local nextBoss = AutoFarmConfig.WorldBosses[nextIndex]
                            
                            -- Check if this boss is on cooldown
                            local currentTime = os.time()
                            if not AutoFarmConfig.EnemyCooldowns[nextBoss] or AutoFarmConfig.EnemyCooldowns[nextBoss] <= currentTime then
                                currentBossIndex = nextIndex
                                currentBoss = nextBoss
                                allOnCooldown = false
                                break
                            end
                        end
                        
                        if allOnCooldown then
                            -- All bosses are on cooldown, find the one with the shortest remaining cooldown
                            local shortestCooldown = math.huge
                            local shortestIndex = 1
                            
                            for i = 1, #AutoFarmConfig.WorldBosses do
                                local boss = AutoFarmConfig.WorldBosses[i]
                                local remainingCooldown = (AutoFarmConfig.EnemyCooldowns[boss] or 0) - currentTime
                                
                                if remainingCooldown < shortestCooldown then
                                    shortestCooldown = remainingCooldown
                                    shortestIndex = i
                                end
                            end
                            
                            currentBossIndex = shortestIndex
                            currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex]
                            
                            wait(math.min(5, math.max(1, shortestCooldown))) -- Wait at least 1 second, at most 5 seconds
                        else
                            -- Try to start battle with current boss (which is not on cooldown)
                            Utilities.StartNextBattle(currentBoss)
                        end
                    elseif Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        
                        -- Once battle is dismissed, mark the boss as defeated and move to next
                        if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(currentBoss)
                            
                            -- Move to next boss for next iteration
                            currentBossIndex = currentBossIndex % #AutoFarmConfig.WorldBosses + 1
                            currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex]
                        end
                    end
                    
                    -- Wait 1 second before next check
                    wait(1)
                end
            end)
        else
            -- Stop auto farm all bosses
            Utilities.Notify("Auto Farm", "Stopped auto farming all world bosses", "stop_circle")
            
            -- Disconnect auto farm loop
            if AutoFarmConfig.Connections.AutoFarmAllBosses then
                AutoFarmConfig.Connections.AutoFarmAllBosses:Disconnect()
                AutoFarmConfig.Connections.AutoFarmAllBosses = nil
            end
        end
    end
}, "AutoFarmAllEnemiesToggle")

-- Auto Farm Toggle
local autofarm_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm Selected Enemy",
    Description = "Automatically spawns the currently selected enemy after cooldown",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.Enabled = Value
        
        if Value then
            Utilities.Notify("Auto Farm", "Started auto farming " .. (AutoFarmConfig.SelectedWorlds and #AutoFarmConfig.SelectedWorlds > 0 and table.concat(AutoFarmConfig.SelectedWorlds, ", ") or "no worlds selected"), "auto_mode")
            
            if AutoFarmConfig.Connections.AutoFarm then
                AutoFarmConfig.Connections.AutoFarm:Disconnect()
            end
            
            AutoFarmConfig.Connections.AutoFarm = spawn(function()
                while AutoFarmConfig.Enabled do
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local currentTime = os.time()
                        if AutoFarmConfig.CurrentEnemy and AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] and AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] > currentTime then
                            local remainingCooldown = math.ceil(AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] - currentTime)
                            wait(math.min(5, remainingCooldown))
                        else
                            Utilities.StartNextBattle(AutoFarmConfig.CurrentEnemy)
                        end
                    elseif Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        
                        if AutoFarmConfig.CurrentEnemy and not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(AutoFarmConfig.CurrentEnemy)
                        end
                    end
                    
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Farm", "Stopped auto farming", "stop_circle")
            
            if AutoFarmConfig.Connections.AutoFarm then
                AutoFarmConfig.Connections.AutoFarm:Disconnect()
                AutoFarmConfig.Connections.AutoFarm = nil
            end
        end
    end
}, "AutoFarmToggle")

-- Auto collect loop ändern (langsamerer Tween)
local autocollect_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Collect Items",
    Description = "Automatically collects dropped items",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoCollect = Value
        
        if Value then
            -- Start auto collect
            Utilities.Notify("Auto Collect", "Started auto collecting items", "inventory_2")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoCollect then
                AutoFarmConfig.Connections.AutoCollect:Disconnect()
            end
            
            -- Create new auto collect loop
            AutoFarmConfig.Connections.AutoCollect = spawn(function()
                while AutoFarmConfig.AutoCollect do
                    pcall(function()
                        local items = workspace.Folder:GetChildren()
                        
                        for _, item in pairs(items) do
                            if item:IsA("Model") and AutoFarmConfig.AutoCollect then
                                -- Get item position
                                local itemPosition = item:GetPivot().Position
                                
                                -- Get player's character and humanoid root part
                                local character = Utilities.GetLocalPlayer().Character
                                if character and character:FindFirstChild("HumanoidRootPart") then
                                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                                    
                                    -- Tween to the item (langsamerer Tween: 2.0 statt 0.5 Sekunden)
                                    local tweenService = game:GetService("TweenService")
                                    local tweenInfo = TweenInfo.new(2.0, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                                    
                                    local tween = tweenService:Create(
                                        humanoidRootPart,
                                        tweenInfo,
                                        {CFrame = CFrame.new(itemPosition)}
                                    )
                                    
                                    tween:Play()
                                    tween.Completed:Wait()
                                    
                                    -- Wait a bit to ensure item is collected
                                    wait(0.5)
                                end
                            end
                        end
                    end)
                    
                    wait(1) -- Wait before checking for new items
                end
            end)
        else
            -- Stop auto collect
            Utilities.Notify("Auto Collect", "Stopped auto collecting items", "stop_circle")
            
            -- Disconnect auto collect loop
            if AutoFarmConfig.Connections.AutoCollect then
                AutoFarmConfig.Connections.AutoCollect:Disconnect()
                AutoFarmConfig.Connections.AutoCollect = nil
            end
        end
    end
}, "AutoCollectToggle")

-- Auto merge toggle
local automerge_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Merge Units",
    Description = "Automatically merges your units",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoMerge = Value
        
        if Value then
            -- Start auto merge
            Utilities.Notify("Auto Merge", "Started auto merging units", "merge")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoMerge then
                AutoFarmConfig.Connections.AutoMerge:Disconnect()
            end
            
            -- Create new auto merge loop
            AutoFarmConfig.Connections.AutoMerge = spawn(function()
                while AutoFarmConfig.AutoMerge do
                    pcall(function()
                        -- Example auto merge code
                        local args = {
                            [1] = 0,
                            [2] = "light_admiral",
                            [3] = 200,
                            [4] = false
                        }
                        
                        game:GetService("ReplicatedStorage"):WaitForChild("noV"):WaitForChild("b57b2bf9-5561-408a-8668-8d7afa1b05f0"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Wait before attempting to merge again
                end
            end)
        else
            -- Stop auto merge
            Utilities.Notify("Auto Merge", "Stopped auto merging units", "stop_circle")
            
            -- Disconnect auto merge loop
            if AutoFarmConfig.Connections.AutoMerge then
                AutoFarmConfig.Connections.AutoMerge:Disconnect()
                AutoFarmConfig.Connections.AutoMerge = nil
            end
        end
    end
}, "AutoMergeToggle")

-- Auto Farm All Enemies in Order toggle
local autofarm_all_enemies_inorder_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm All Enemies (In Order)",
    Description = "Automatically cycles through all enemies in the exact order from the list",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoFarmAllEnemies = Value
        
        if Value then
            Utilities.Notify("Auto Farm", "Started auto farming all enemies in exact order", "auto_mode")
            
            if AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder then
                AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder:Disconnect()
            end
            
            AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder = spawn(function()
                local enemyIndex = 1
                
                -- Liste aller Gegner in exakter Reihenfolge
                local allEnemiesInOrder = {
                    -- Ninja Village
                    "unstoppable_fist", -- Rock Lee
                    "copy_ninja", -- Kakashi
                    "awakened_dark_avenger", -- Sasuke
                    "awakened_promised_child", -- Naruto Sage Mode
                    "six_paths_of_pain", -- Pain
                    "bijuu_beast", -- Naruto Rage Mode (Boss)
                    
                    -- Green Village
                    "ultimate_warrior", -- Son Gohan
                    "body_switcher", -- Captain Ginyu
                    "namekian_sage", -- Piccolo
                    "awakened_prideful_prince", -- Vegeta
                    "awakened_earth_strongest", -- Goku
                    "awakened_galactic_tyrant", -- Frieza (Boss)
                    
                    -- Shibuya Station
                    "cursed_doll", -- Nobara
                    "awakened_shadow_summoner", -- Megumi
                    "cursed_fist", -- Yuji
                    "rika_blessing", -- Yuta
                    "limitless_master", -- Gojo
                    "king_of_curses", -- Sukuna (Boss)
                    
                    -- Titans City
                    "survey_commander", -- Erwin
                    "blade_warrior", -- Mikasa
                    "armored_giant", -- Reiner
                    "beast_giant", -- Zeke
                    "blade_captain", -- Levi
                    "combat_giant", -- Eren (Boss)
                    
                    -- Dimensional Fortress
                    "thunder_demon", -- Kaigaku
                    "childish_demon", -- Hantengu
                    "compass_demon", -- Akaza
                    "awakened_frost_demon", -- Doma
                    "awakened_six_eyed_slayer", -- Kokushibo
                    "awakened_pale_demon_lord", -- Muzan (Boss)
                    
                    -- Candy Island
                    "genie_commander", -- Daifuku
                    "candy_master", -- Perospero
                    "biscuit_warrior", -- Cracker
                    "juice_queen", -- Smoothie
                    "mochi_emperor", -- Katakuri
                    "soul_queen", -- Big Mom (Boss)
                    
                    -- Solo City
                    "light_saintess", -- Cha Hae-In
                    "the_goliath", -- Thomas Andre
                    "shadow_bear", -- Tank
                    "shadow_commander", -- Igris
                    "shadow_ant", -- Beru
                    "awakened_shadow_monarch" -- Sung Jinwoo (Boss)
                }
                
                while AutoFarmConfig.AutoFarmAllEnemies do
                    local currentEnemy = allEnemiesInOrder[enemyIndex]
                    
                    -- Prüfen, ob wir in einem Kampf sind
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Prüfen, ob der aktuelle Gegner auf Cooldown ist
                        local currentTime = os.time()
                        if not AutoFarmConfig.EnemyCooldowns[currentEnemy] or AutoFarmConfig.EnemyCooldowns[currentEnemy] <= currentTime then
                            -- Versuchen, den Kampf zu starten
                            Utilities.StartNextBattle(currentEnemy)
                            
                            -- Wenn der Kampf nicht gestartet werden konnte, zum nächsten Gegner wechseln
                            if not Utilities.IsInBattle() then
                                enemyIndex = (enemyIndex % #allEnemiesInOrder) + 1
                            end
                        else
                            -- Gegner ist auf Cooldown, zum nächsten wechseln
                            enemyIndex = (enemyIndex % #allEnemiesInOrder) + 1
                        end
                    elseif Utilities.IsInBattle() then
                        -- Wir sind in einem Kampf, warten
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        -- Kampf ist beendet, Endbildschirm schließen
                        Utilities.DismissBattleEnd()
                        
                        -- Nach dem Schließen des Endbildschirms den Gegner als besiegt markieren
                        if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(currentEnemy)
                            
                            -- Move to next enemy for next iteration
                            enemyIndex = (enemyIndex % #allEnemiesInOrder) + 1
                        end
                    end
                    
                    -- Kurz warten vor der nächsten Überprüfung
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Farm", "Stopped auto farming all enemies in order", "stop_circle")
            
            if AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder then
                AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder:Disconnect()
                AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder = nil
            end
        end
    end
}, "AutoFarmAllEnemiesInOrderToggle")

-- Towers Tab
TabTowers:CreateSection("Battle Tower")

-- Battle Tower level display
local battle_tower_level = TabTowers:CreateLabel({
    Text = "Current Battle Tower Level: " .. Utilities.GetBattleTowerLevel(),
    Style = 1
})

-- Update Battle Tower level periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            battle_tower_level:Set({
                Text = "Current Battle Tower Level: " .. Utilities.GetBattleTowerLevel()
            })
        end
    end
end)

-- Tower Level Config
local TowerConfig = {
    BattleTowerLevel = 1,
    AutoContinuousLevel = false,
    AutoHighestLevel = false,
    Connections = {}
}

-- Battle Tower Level Dropdown instead of Input
local battle_tower_dropdown = TabTowers:CreateDropdown({
    Name = "Select Battle Tower Level",
    Description = "Choose a Tower Level (1-100)",
    Options = {"1", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50", 
               "55", "60", "65", "70", "75", "80", "85", "90", "95", "100"},
    CurrentOption = {"1"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        local level = tonumber(Option[1])
        if level then
            TowerConfig.BattleTowerLevel = level
        end
    end
}, "BattleTowerLevelDropdown")

-- Button to start the selected level
TabTowers:CreateButton({
    Name = "Start Battle Tower Level Once",
    Description = "Start the selected Battle Tower level",
    Callback = function()
        local level = TowerConfig.BattleTowerLevel
        
        if level and level >= 1 and level <= 100 then
            local args = {
                [1] = level
            }
            
            local success, result = pcall(function()
                local replicatedStorage = game:GetService("ReplicatedStorage")
                local childkQR = Utilities.SafeWaitForChild(replicatedStorage, "kQR", 5)
                if not childkQR then
                    Utilities.Notify("Fehler", "Konnte kQR in ReplicatedStorage nicht finden", "error")
                    return false
                end
                
                local towerRemote = Utilities.SafeWaitForChild(childkQR, "1457e535-9d02-4014-9883-7618f41bed84", 3)
                if not towerRemote then
                    Utilities.Notify("Fehler", "Konnte Tower-Remote in kQR nicht finden", "error")
                    return false
                end
                
                towerRemote:FireServer(unpack(args))
                return true
            end)
            
            if success and result then
                Utilities.Notify("Battle Tower", "Battle Tower started at level " .. level, "castle")
            else
                Utilities.Notify("Fehler", "Battle Tower konnte nicht gestartet werden", "error")
            end
        else
            Utilities.Notify("Fehler", "Bitte wähle ein Level zwischen 1 und 100", "error")
        end
    end
})

-- Toggle for continuous level
local continuous_tower_toggle = TabTowers:CreateToggle({
    Name = "Auto Continuous Battle Tower",
    Description = "Continuously starts the selected Battle Tower level",
    CurrentValue = false,
    Callback = function(Value)
        TowerConfig.AutoContinuousLevel = Value
        
        if Value then
            -- Activate auto continuous level
            Utilities.Notify("Battle Tower", "Auto Continuous Battle Tower activated for level " .. TowerConfig.BattleTowerLevel, "castle")
            
            -- Remove previous connections
            if TowerConfig.Connections.AutoContinuous then
                TowerConfig.Connections.AutoContinuous:Disconnect()
            end
            
            -- Create new auto continuous loop
            TowerConfig.Connections.AutoContinuous = spawn(function()
                while TowerConfig.AutoContinuousLevel do
                    -- Only start Battle Tower if we're not in a battle
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local args = {
                            [1] = TowerConfig.BattleTowerLevel
                        }
                        
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("1457e535-9d02-4014-9883-7618f41bed84"):FireServer(unpack(args))
                        end)
                        
                        Utilities.DebugPrint("Auto Continuous Battle Tower - Level " .. TowerConfig.BattleTowerLevel .. " started")
                    end
                    
                    wait(5) -- Check every 5 seconds
                end
            end)
        else
            -- Deactivate auto continuous level
            Utilities.Notify("Battle Tower", "Auto Continuous Battle Tower deactivated", "stop_circle")
            
            -- End loop
            if TowerConfig.Connections.AutoContinuous then
                TowerConfig.Connections.AutoContinuous:Disconnect()
                TowerConfig.Connections.AutoContinuous = nil
            end
        end
    end
}, "AutoContinuousTowerToggle")

-- Toggle for automatic highest level
local highest_tower_toggle = TabTowers:CreateToggle({
    Name = "Auto Highest Battle Tower",
    Description = "Automatically starts the highest possible Battle Tower level",
    CurrentValue = false,
    Callback = function(Value)
        TowerConfig.AutoHighestLevel = Value
        
        if Value then
            -- Activate auto highest level
            Utilities.Notify("Battle Tower", "Auto Highest Battle Tower activated", "castle")
            
            -- Remove previous connections
            if TowerConfig.Connections.AutoHighest then
                TowerConfig.Connections.AutoHighest:Disconnect()
            end
            
            -- Create new auto highest loop
            TowerConfig.Connections.AutoHighest = spawn(function()
                while TowerConfig.AutoHighestLevel do
                    -- Only start Battle Tower if we're not in a battle
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local currentLevel = Utilities.GetBattleTowerLevel()
                        
                        local args = {
                            [1] = currentLevel
                        }
                        
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("1457e535-9d02-4014-9883-7618f41bed84"):FireServer(unpack(args))
                        end)
                        
                        Utilities.DebugPrint("Auto Highest Battle Tower - Level " .. currentLevel .. " started")
                    end
                    
                    wait(5) -- Check every 5 seconds
                end
            end)
        else
            -- Deactivate auto highest level
            Utilities.Notify("Battle Tower", "Auto Highest Battle Tower deactivated", "stop_circle")
            
            -- End loop
            if TowerConfig.Connections.AutoHighest then
                TowerConfig.Connections.AutoHighest:Disconnect()
                TowerConfig.Connections.AutoHighest = nil
            end
        end
    end
}, "AutoHighestTowerToggle")

-- Infinite Tower Tab
TabTowers:CreateSection("Infinite Tower")

-- Infinite Tower floor display
local infinite_tower_floor = TabTowers:CreateLabel({
    Text = "Current Infinite Tower Floor: " .. Utilities.GetInfiniteTowerFloor(),
    Style = 1
})

-- Update Infinite Tower floor periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            infinite_tower_floor:Set({
                Text = "Current Infinite Tower Floor: " .. Utilities.GetInfiniteTowerFloor()
            })
        end
    end
end)

-- Infinite Tower control buttons
TabTowers:CreateButton({
    Name = "Start Infinite Tower",
    Description = "Begin the Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("60ed7d69-2cac-467c-9695-6ab3e77159b9"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Started Infinite Tower challenge", "castle")
        else
            Utilities.Notify("Error", "Failed to start Infinite Tower", "error")
        end
    end
})

TabTowers:CreateButton({
    Name = "Pause Infinite Tower",
    Description = "Pause the current Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("5bdb0ab8-610f-4823-9e57-4cd48a5c4eb8"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Paused Infinite Tower challenge", "pause")
        else
            Utilities.Notify("Error", "Failed to pause Infinite Tower", "error")
        end
    end
})

TabTowers:CreateButton({
    Name = "End Infinite Tower",
    Description = "End the current Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("23fb560d-73d0-404a-8dda-bf8088b08f0a"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Ended Infinite Tower challenge", "stop_circle")
        else
            Utilities.Notify("Error", "Failed to end Infinite Tower", "error")
        end
    end
})

-- Raids Tab
TabRaids:CreateSection("Raid Management")

TabRaids:CreateParagraph({
    Title = "Raid Information",
    Text = "Raids offer exclusive rewards and powerful units. You can start a raid against the Eternal Dragon or other powerful bosses."
})

-- Auto Raid Configuration
local RaidConfig = {
    AutoSummonEternalDragon = false,
    AutoSummonShadowDragon = false,
    Connections = {}
}

-- Auto Summon Eternal Dragon toggle
local auto_summon_dragon_toggle = TabRaids:CreateToggle({
    Name = "Auto Fight Eternal Dragon",
    Description = "Automatically fights the Eternal Dragon at regular intervals",
    CurrentValue = false,
    Callback = function(Value)
        RaidConfig.AutoSummonEternalDragon = Value
        
        if Value then
            Utilities.Notify("Auto Raid", "Started auto fighting Eternal Dragon", "security")
            
            if RaidConfig.Connections.AutoSummonDragon then
                RaidConfig.Connections.AutoSummonDragon:Disconnect()
            end
            
            RaidConfig.Connections.AutoSummonDragon = spawn(function()
                while RaidConfig.AutoSummonEternalDragon do
                    if Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        wait(1)
                    else
                        pcall(function()
                            local args = {
                                [1] = "eternal_dragon"
                            }
                            
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
                        end)
                        wait(3)
                    end
                    
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Raid", "Stopped auto fighting Eternal Dragon", "stop_circle")
            
            if RaidConfig.Connections.AutoSummonDragon then
                RaidConfig.Connections.AutoSummonDragon:Disconnect()
                RaidConfig.Connections.AutoSummonDragon = nil
            end
        end
    end
}, "AutoSummonDragonToggle")

TabRaids:CreateButton({
    Name = "Fight Eternal Dragon Once",
    Description = "Start a raid against the Eternal Dragon immediately",
    Callback = function()
        local success, result = pcall(function()
            local args = {
                [1] = "eternal_dragon"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Raid Started", "Successfully started fight with Eternal Dragon", "security")
        else
            Utilities.Notify("Error", "Failed to start raid", "error")
        end
    end
})

-- Auto Summon Shadow Dragon toggle
local auto_summon_shadow_dragon_toggle = TabRaids:CreateToggle({
    Name = "Auto Fight Shadow Dragon",
    Description = "Automatically fights the Shadow Dragon at regular intervals",
    CurrentValue = false,
    Callback = function(Value)
        RaidConfig.AutoSummonShadowDragon = Value
        
        if Value then
            Utilities.Notify("Auto Raid", "Started auto fighting Shadow Dragon", "security")
            
            if RaidConfig.Connections.AutoSummonShadowDragon then
                RaidConfig.Connections.AutoSummonShadowDragon:Disconnect()
            end
            
            RaidConfig.Connections.AutoSummonShadowDragon = spawn(function()
                while RaidConfig.AutoSummonShadowDragon do
                    if Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        wait(1)
                    else
                        pcall(function()
                            local args = {
                                [1] = "shadow_dragon"
                            }
                            
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
                        end)
                        wait(3)
                    end
                    
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Raid", "Stopped auto fighting Shadow Dragon", "stop_circle")
            
            if RaidConfig.Connections.AutoSummonShadowDragon then
                RaidConfig.Connections.AutoSummonShadowDragon:Disconnect()
                RaidConfig.Connections.AutoSummonShadowDragon = nil
            end
        end
    end
}, "AutoSummonShadowDragonToggle")

TabRaids:CreateButton({
    Name = "Fight Shadow Dragon Once",
    Description = "Start a raid against the Shadow Dragon immediately",
    Callback = function()
        local success, result = pcall(function()
            local args = {
                [1] = "shadow_dragon"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Raid Started", "Successfully started fight with Shadow Dragon", "security")
        else
            Utilities.Notify("Error", "Failed to start raid", "error")
        end
    end
})

-- Exploration Tab
TabExploration:CreateSection("Exploration Management")

-- Exploration team configuration
local exploration_difficulty = TabExploration:CreateDropdown({
    Name = "Exploration Difficulty",
    Description = "Select the difficulty level for exploration",
    Options = {"easy", "medium", "hard", "extreme", "nightmare"},
    CurrentOption = {"easy"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        -- Nothing needed here, will be used in other functions
    end
}, "ExploreDifficulty")

-- Unit selection for exploration
local exploration_units = TabExploration:CreateInput({
    Name = "Exploration Units",
    Description = "Enter 4 unit names separated by commas",
    PlaceholderText = "e.g., dark_avenger,black_swordsman,dark_avenger,dark_avenger",
    CurrentValue = "dark_avenger,black_swordsman,dark_avenger,dark_avenger",
    Numeric = false,
    MaxCharacters = 100,
    Enter = false,
    Callback = function(Text)
        -- Nothing needed here, will be used in the deploy button
    end
}, "ExploreUnits")

TabExploration:CreateButton({
    Name = "Deploy Exploration Team",
    Description = "Send your selected units on an exploration mission",
    Callback = function()
        local difficulty = exploration_difficulty.CurrentOption
        if type(difficulty) == "table" then
            difficulty = difficulty[1]
        end
        
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = difficulty,
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("4971f60f-90ff-4142-bf88-5395122136c2"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for " .. difficulty .. " exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

TabExploration:CreateDivider()

TabExploration:CreateSection("Claim Rewards")

-- Exploration Claim Config
local ExplorationConfig = {
    AutoClaimEasy = false,
    AutoClaimMedium = false,
    AutoClaimHard = false,
    AutoClaimExtreme = false,
    AutoClaimNightmare = false,
    Connections = {}
}

-- Auto Claim Easy Toggle
local auto_claim_easy_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Easy Exploration Rewards",
    Description = "Automatically claims rewards from easy difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimEasy = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Easy Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimEasy then
                ExplorationConfig.Connections.AutoClaimEasy:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimEasy = spawn(function()
                while ExplorationConfig.AutoClaimEasy do
                    local args = {
                        [1] = "easy"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    Utilities.DebugPrint("Auto Claiming Easy Exploration Rewards")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Easy Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimEasy then
                ExplorationConfig.Connections.AutoClaimEasy:Disconnect()
                ExplorationConfig.Connections.AutoClaimEasy = nil
            end
        end
    end
}, "AutoClaimEasyToggle")

-- Auto Claim Medium Toggle
local auto_claim_medium_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Medium Exploration Rewards",
    Description = "Automatically claims rewards from medium difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimMedium = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Medium Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimMedium then
                ExplorationConfig.Connections.AutoClaimMedium:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimMedium = spawn(function()
                while ExplorationConfig.AutoClaimMedium do
                    local args = {
                        [1] = "medium"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    Utilities.DebugPrint("Auto Claiming Medium Exploration Rewards")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Medium Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimMedium then
                ExplorationConfig.Connections.AutoClaimMedium:Disconnect()
                ExplorationConfig.Connections.AutoClaimMedium = nil
            end
        end
    end
}, "AutoClaimMediumToggle")

-- Auto Claim Hard Toggle
local auto_claim_hard_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Hard Exploration Rewards",
    Description = "Automatically claims rewards from hard difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimHard = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Hard Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimHard then
                ExplorationConfig.Connections.AutoClaimHard:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimHard = spawn(function()
                while ExplorationConfig.AutoClaimHard do
                    local args = {
                        [1] = "hard"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Hard Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimHard then
                ExplorationConfig.Connections.AutoClaimHard:Disconnect()
                ExplorationConfig.Connections.AutoClaimHard = nil
            end
        end
    end
}, "AutoClaimHardToggle")

-- Auto Claim Extreme Toggle
local auto_claim_extreme_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Extreme Exploration Rewards",
    Description = "Automatically claims rewards from extreme difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimExtreme = Value
        
        if Value then
            Utilities.Notify("Exploration", "Auto Claim Extreme Rewards activated", "redeem")
            
            if ExplorationConfig.Connections.AutoClaimExtreme then
                ExplorationConfig.Connections.AutoClaimExtreme:Disconnect()
            end
            
            ExplorationConfig.Connections.AutoClaimExtreme = spawn(function()
                while ExplorationConfig.AutoClaimExtreme do
                    local args = {
                        [1] = "extreme"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Exploration", "Auto Claim Extreme Rewards deactivated", "stop_circle")
            
            if ExplorationConfig.Connections.AutoClaimExtreme then
                ExplorationConfig.Connections.AutoClaimExtreme:Disconnect()
                ExplorationConfig.Connections.AutoClaimExtreme = nil
            end
        end
    end
}, "AutoClaimExtremeToggle")

-- Auto Claim Nightmare Toggle
local auto_claim_nightmare_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Nightmare Exploration Rewards",
    Description = "Automatically claims rewards from nightmare difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimNightmare = Value
        
        if Value then
            Utilities.Notify("Exploration", "Auto Claim Nightmare Rewards activated", "redeem")
            
            if ExplorationConfig.Connections.AutoClaimNightmare then
                ExplorationConfig.Connections.AutoClaimNightmare:Disconnect()
            end
            
            ExplorationConfig.Connections.AutoClaimNightmare = spawn(function()
                while ExplorationConfig.AutoClaimNightmare do
                    local args = {
                        [1] = "nightmare"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Exploration", "Auto Claim Nightmare Rewards deactivated", "stop_circle")
            
            if ExplorationConfig.Connections.AutoClaimNightmare then
                ExplorationConfig.Connections.AutoClaimNightmare:Disconnect()
                ExplorationConfig.Connections.AutoClaimNightmare = nil
            end
        end
    end
}, "AutoClaimNightmareToggle")

-- Explore Deployment for extreme
TabExploration:CreateDivider()
TabExploration:CreateSection("Extreme & Nightmare Exploration")

TabExploration:CreateButton({
    Name = "Deploy Extreme Exploration Team",
    Description = "Send your selected units on an extreme exploration mission",
    Callback = function()
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = "extreme",
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("4971f60f-90ff-4142-bf88-5395122136c2"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for extreme exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

TabExploration:CreateButton({
    Name = "Deploy Nightmare Exploration Team",
    Description = "Send your selected units on a nightmare exploration mission",
    Callback = function()
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = "nightmare",
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("4971f60f-90ff-4142-bf88-5395122136c2"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for nightmare exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

-- Shop Tab
TabShop:CreateSection("Shop Management")

TabShop:CreateParagraph({
    Title = "Shop Information",
    Text = "Purchase various items from the shop to enhance your gameplay experience."
})

-- Shop items
TabShop:CreateButton({
    Name = "Buy Luck Potion (Small)",
    Description = "Purchase a small luck potion",
    Callback = function()
        Utilities.BuyShopItem("small_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Luck Potion (Medium)",
    Description = "Purchase a medium luck potion",
    Callback = function()
        Utilities.BuyShopItem("medium_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Luck Potion (Large)",
    Description = "Purchase a large luck potion",
    Callback = function()
        Utilities.BuyShopItem("large_luck_potion", 1)
    end
})

TabShop:CreateDivider()

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Small)",
    Description = "Purchase a small cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("small_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Medium)",
    Description = "Purchase a medium cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("medium_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Large)",
    Description = "Purchase a large cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("large_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateDivider()

TabShop:CreateButton({
    Name = "Buy Raid Luck Potion",
    Description = "Purchase a raid luck potion",
    Callback = function()
        Utilities.BuyShopItem("raid_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Border Chance Potion",
    Description = "Purchase a raid border chance potion",
    Callback = function()
        Utilities.BuyShopItem("raid_border_chance_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Cooldown Potion",
    Description = "Purchase a raid cooldown potion",
    Callback = function()
        Utilities.BuyShopItem("raid_cooldown_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Boss Chance Potion",
    Description = "Purchase a raid boss chance potion",
    Callback = function()
        Utilities.BuyShopItem("raid_boss_chance_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Moon Cycle Reroll Potion",
    Description = "Purchase a raid moon cycle reroll potion",
    Callback = function()
        Utilities.BuyShopItem("raid_moon_cycle_reroll_potion", 1)
    end
})

-- Misc Tab
TabMisc:CreateSection("Miscellaneous Features")

-- BillboardGui text modification (Hide Name feature)
local NameHideConfig = {
    Enabled = false,
    OriginalTexts = {},
    OriginalColors = {}
}

-- Function to toggle name hiding
Utilities.ToggleNameHide = function(value)
    NameHideConfig.Enabled = value
    
    if value then
        -- Save original values first (only if not already saved)
        if #NameHideConfig.OriginalTexts == 0 then
            pcall(function()
                -- First TextLabel (which will be changed to "JOIN DC")
                local joinLabel = workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2]
                if joinLabel and joinLabel:IsA("TextLabel") then
                    NameHideConfig.OriginalTexts[joinLabel] = joinLabel.Text
                    NameHideConfig.OriginalColors[joinLabel] = joinLabel.TextColor3
                    
                    -- Change to "JOIN DC" in white
                    joinLabel.Text = "JOIN DC"
                    joinLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- White
                end
                
                -- Second TextLabel (which will be changed to "MYTHHUB")
                local mythLabel = workspace.rswhshj.Head.BillboardGui.Frame.TextLabel
                if mythLabel and mythLabel:IsA("TextLabel") then
                    NameHideConfig.OriginalTexts[mythLabel] = mythLabel.Text
                    NameHideConfig.OriginalColors[mythLabel] = mythLabel.TextColor3
                    
                    -- Change to "MYTHHUB" in #11189D (dark blue)
                    mythLabel.Text = "MYTHHUB"
                    mythLabel.TextColor3 = Color3.fromRGB(17, 24, 157) -- #11189D in RGB
                end
            end)
        else
            -- Apply saved changes (in case they were reverted)
            pcall(function()
                workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2].Text = "JOIN DC"
                workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2].TextColor3 = Color3.fromRGB(255, 255, 255)
                
                workspace.rswhshj.Head.BillboardGui.Frame.TextLabel.Text = "MYTHHUB"
                workspace.rswhshj.Head.BillboardGui.Frame.TextLabel.TextColor3 = Color3.fromRGB(17, 24, 157)
            end)
        end
    else
        -- Restore original values
        for label, originalText in pairs(NameHideConfig.OriginalTexts) do
            pcall(function()
                label.Text = originalText
                label.TextColor3 = NameHideConfig.OriginalColors[label]
            end)
        end
    end
end

-- Add Hide Name toggle
local hide_name_toggle = TabMisc:CreateToggle({
    Name = "Hide Name",
    Description = "Replaces the name with MYTHHUB and JOIN DC text",
    CurrentValue = false,
    Callback = function(Value)
        Utilities.ToggleNameHide(Value)
        
        if Value then
            Utilities.Notify("Name Hider", "Name hidden with custom text", "person")
        else
            Utilities.Notify("Name Hider", "Original name restored", "person")
        end
    end
}, "HideNameToggle")

-- Remove the "Enemy Cooldown Information" section and replace with a detailed cooldown display
TabMisc:CreateSection("Enemy Cooldown Information")

-- Create a function to display enemy cooldowns
local function createCooldownDisplay()
    -- Create the main paragraph for cooldowns
    local cooldownParagraph = TabMisc:CreateParagraph({
        Title = "Current Enemy Cooldowns",
        Text = "Checking cooldowns..."
    })
    
    -- Update function that will be called periodically
    local function updateCooldowns()
        local text = ""
        local currentTime = os.time()
        local hasCooldowns = false
        
        -- Check existence of EnemyCooldowns table
        if not AutoFarmConfig.EnemyCooldowns then
            AutoFarmConfig.EnemyCooldowns = {}
        end
        
        -- Boss names
        local worldBosses = {
            bijuu_beast = "Naruto Rage Mode",
            awakened_galactic_tyrant = "Frieza",
            king_of_curses = "Sukuna",
            combat_giant = "Eren",
            awakened_pale_demon_lord = "Muzan",
            soul_queen = "Big Mom",
            awakened_shadow_monarch = "Sung Jinwoo"
        }
        
        -- Regular enemy names
        local regularEnemies = {
            -- Ninja Village
            unstoppable_fist = "Rock Lee",
            copy_ninja = "Kakashi",
            awakened_dark_avenger = "Sasuke",
            awakened_promised_child = "Naruto Sage Mode",
            six_paths_of_pain = "Pain",
            
            -- Green Village
            ultimate_warrior = "Son Gohan",
            body_switcher = "Captain Ginyu",
            namekian_sage = "Piccolo",
            awakened_prideful_prince = "Vegeta",
            awakened_earth_strongest = "Goku",
            
            -- Shibuya Station
            cursed_doll = "Nobara",
            awakened_shadow_summoner = "Megumi",
            cursed_fist = "Yuji",
            rika_blessing = "Yuta",
            limitless_master = "Gojo",
            
            -- Titans City
            survey_commander = "Erwin",
            blade_warrior = "Mikasa",
            armored_giant = "Reiner",
            beast_giant = "Zeke",
            blade_captain = "Levi",
            
            -- Dimensional Fortress
            thunder_demon = "Kaigaku",
            childish_demon = "Hantengu",
            compass_demon = "Akaza",
            awakened_frost_demon = "Doma",
            awakened_six_eyed_slayer = "Kokushibo",
            
            -- Candy Island
            genie_commander = "Daifuku",
            candy_master = "Perospero",
            biscuit_warrior = "Cracker",
            juice_queen = "Smoothie",
            mochi_emperor = "Katakuri",
            
            -- Solo City
            light_saintess = "Cha Hae-In",
            the_goliath = "Thomas Andre",
            shadow_bear = "Tank",
            shadow_commander = "Igris",
            shadow_ant = "Beru"
        }
        
        -- Add world bosses to cooldown display
        text = text .. "--- World Bosses ---\n"
        for enemyCode, bossName in pairs(worldBosses) do
            local cooldownTime = AutoFarmConfig.EnemyCooldowns[enemyCode]
            if cooldownTime and cooldownTime > currentTime then
                local remainingTime = cooldownTime - currentTime
                local minutes = math.floor(remainingTime / 60)
                local seconds = remainingTime % 60
                text = text .. bossName .. ": " .. string.format("%02d:%02d", minutes, seconds) .. "\n"
                hasCooldowns = true
            else
                text = text .. bossName .. ": Ready\n"
            end
        end
        
        -- Add regular enemies to cooldown display
        text = text .. "\n--- Regular Enemies ---\n"
        for enemyCode, enemyName in pairs(regularEnemies) do
            local cooldownTime = AutoFarmConfig.EnemyCooldowns[enemyCode]
            if cooldownTime and cooldownTime > currentTime then
                local remainingTime = cooldownTime - currentTime
                local minutes = math.floor(remainingTime / 60)
                local seconds = remainingTime % 60
                text = text .. enemyName .. ": " .. string.format("%02d:%02d", minutes, seconds) .. "\n"
                hasCooldowns = true
            end
        end
        
        if not hasCooldowns then
            text = text .. "No enemies on cooldown."
        end
        
        -- Update the paragraph text
        cooldownParagraph:Set({
            Text = text
        })
    end
    
    -- Initial update
    updateCooldowns()
    
    -- Start a timer to update the cooldowns every second
    spawn(function()
        while wait(1) do
            updateCooldowns()
        end
    end)
end

-- Create the cooldown display
createCooldownDisplay()

TabMisc:CreateDivider()

-- Create a section for Performance Optimization in the Misc Tab
TabMisc:CreateSection("Performance Optimization")

-- FPS Boost
TabMisc:CreateToggle({
    Name = "FPS Boost",
    Description = "Reduces graphics quality to increase performance",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            -- Enable FPS Boost
            pcall(function()
                -- Reduce graphics quality
                local lighting = game:GetService("Lighting")
                lighting.GlobalShadows = false
                lighting.ShadowSoftness = 0
                lighting.Technology = Enum.Technology.Compatibility
                
                -- Disable unnecessary rendering
                settings().Rendering.QualityLevel = 1
                
                -- Reduce terrain quality
                workspace.Terrain.WaterWaveSize = 0
                workspace.Terrain.WaterWaveSpeed = 0
                workspace.Terrain.WaterReflectance = 0
                workspace.Terrain.WaterTransparency = 0
                
                -- Disable textures and effects
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Trail") or v:IsA("Smoke") or v:IsA("Fire") then
                        v.Enabled = false
                    end
                end
                
                Utilities.Notify("Performance", "FPS Boost enabled", "speed")
            end)
        else
            -- Restore default settings
            pcall(function()
                -- Reset graphics quality
                local lighting = game:GetService("Lighting")
                lighting.GlobalShadows = true
                lighting.ShadowSoftness = 0.5
                lighting.Technology = Enum.Technology.Future
                
                -- Reset rendering
                settings().Rendering.QualityLevel = 7
                
                -- Reset terrain
                workspace.Terrain.WaterWaveSize = 0.3
                workspace.Terrain.WaterWaveSpeed = 10
                workspace.Terrain.WaterReflectance = 1
                workspace.Terrain.WaterTransparency = 0.6
                
                Utilities.Notify("Performance", "FPS Boost disabled", "speed")
            end)
        end
    end
})

-- Reduce Particles
TabMisc:CreateToggle({
    Name = "Reduce Particles",
    Description = "Disables particle effects for better performance",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            -- Disable particles
            pcall(function()
                for _, v in pairs(game:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Beam") or v:IsA("Trail") or v:IsA("Smoke") or v:IsA("Fire") then
                        v.Enabled = false
                    end
                end
                
                -- Connect to DescendantAdded to disable new particles
                if not Utilities.ParticleConnection then
                    Utilities.ParticleConnection = game.DescendantAdded:Connect(function(descendant)
                        if descendant:IsA("ParticleEmitter") or descendant:IsA("Beam") or descendant:IsA("Trail") or descendant:IsA("Smoke") or descendant:IsA("Fire") then
                            descendant.Enabled = false
                        end
                    end)
                end
                
                Utilities.Notify("Performance", "Particles reduced", "blur_off")
            end)
        else
            -- Enable particles again
            pcall(function()
                if Utilities.ParticleConnection then
                    Utilities.ParticleConnection:Disconnect()
                    Utilities.ParticleConnection = nil
                end
                
                Utilities.Notify("Performance", "Particles enabled", "blur_on")
            end)
        end
    end
})

-- Remove Shadows
TabMisc:CreateToggle({
    Name = "Remove Shadows",
    Description = "Disables shadows for better performance",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            pcall(function()
                game:GetService("Lighting").GlobalShadows = false
                game:GetService("Lighting").ShadowSoftness = 0
                Utilities.Notify("Performance", "Shadows disabled", "visibility_off")
            end)
        else
            pcall(function()
                game:GetService("Lighting").GlobalShadows = true
                game:GetService("Lighting").ShadowSoftness = 0.5
                Utilities.Notify("Performance", "Shadows enabled", "visibility")
            end)
        end
    end
})

TabMisc:CreateDivider()
TabMisc:CreateSection("Auto Stats Upgrade")

-- Auto Stats Configuration
local AutoStatsConfig = {
    AutoUpgradeLuck = false,
    AutoUpgradeCooldownReduction = false,
    AutoUpgradePotionDuration = false,
    AutoUpgradeBorderChance = false,
    AutoUpgradeBossChance = false,
    Connections = {}
}

-- Auto Upgrade Luck toggle
local auto_upgrade_luck_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Luck",
    Description = "Automatically upgrades your luck stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeLuck = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Luck stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeLuck then
                AutoStatsConfig.Connections.AutoUpgradeLuck:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeLuck = spawn(function()
                while AutoStatsConfig.AutoUpgradeLuck do
                    Utilities.UpgradeStat("LUCK")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Luck stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeLuck then
                AutoStatsConfig.Connections.AutoUpgradeLuck:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeLuck = nil
            end
        end
    end
}, "AutoUpgradeLuckToggle")

-- Auto Upgrade Cooldown Reduction toggle
local auto_upgrade_cooldown_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Cooldown Reduction",
    Description = "Automatically upgrades your cooldown reduction stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeCooldownReduction = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Cooldown Reduction stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeCooldownReduction then
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeCooldownReduction = spawn(function()
                while AutoStatsConfig.AutoUpgradeCooldownReduction do
                    Utilities.UpgradeStat("COOLDOWN_REDUCTION")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Cooldown Reduction stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeCooldownReduction then
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction = nil
            end
        end
    end
}, "AutoUpgradeCooldownToggle")

-- Auto Upgrade Potion Duration toggle
local auto_upgrade_potion_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Potion Duration",
    Description = "Automatically upgrades your potion duration stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradePotionDuration = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Potion Duration stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradePotionDuration then
                AutoStatsConfig.Connections.AutoUpgradePotionDuration:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradePotionDuration = spawn(function()
                while AutoStatsConfig.AutoUpgradePotionDuration do
                    Utilities.UpgradeStat("POTION_DURATION")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Potion Duration stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradePotionDuration then
                AutoStatsConfig.Connections.AutoUpgradePotionDuration:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradePotionDuration = nil
            end
        end
    end
}, "AutoUpgradePotionToggle")

-- Auto Upgrade Border Chance toggle
local auto_upgrade_border_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Border Chance",
    Description = "Automatically upgrades your border chance stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeBorderChance = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Border Chance stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeBorderChance then
                AutoStatsConfig.Connections.AutoUpgradeBorderChance:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeBorderChance = spawn(function()
                while AutoStatsConfig.AutoUpgradeBorderChance do
                    Utilities.UpgradeStat("BORDER_CHANCE")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Border Chance stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeBorderChance then
                AutoStatsConfig.Connections.AutoUpgradeBorderChance:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeBorderChance = nil
            end
        end
    end
}, "AutoUpgradeBorderToggle")

-- Auto Upgrade Boss Chance toggle
local auto_upgrade_boss_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Boss Chance",
    Description = "Automatically upgrades your boss chance stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeBossChance = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Boss Chance stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeBossChance then
                AutoStatsConfig.Connections.AutoUpgradeBossChance:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeBossChance = spawn(function()
                while AutoStatsConfig.AutoUpgradeBossChance do
                    Utilities.UpgradeStat("BOSS_CHANCE")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Boss Chance stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeBossChance then
                AutoStatsConfig.Connections.AutoUpgradeBossChance:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeBossChance = nil
            end
        end
    end
}, "AutoUpgradeBossToggle")

-- Theme and Config sections
TabSettings:BuildThemeSection()
TabSettings:BuildConfigSection()

-- Enable autoload config
Luna:LoadAutoloadConfig()

-- Remove Debug Console creation
Utilities.CreateDebugConsole = nil

-- Remove Debug Console toggle from settings
TabSettings:CreateButton({
    Name = "Toggle Debug Console",
    Description = "Show or hide the debug console",
    Callback = function()
        -- Do nothing, debug console removed
    end
})

-- Add global battle end detection loop
spawn(function()
    while true do
        wait(1)
        
        if Utilities.IsBattleEnded() then
            Utilities.DismissBattleEnd()
            
            if not AutoFarmConfig.Enabled and not AutoFarmConfig.AutoFarmAllWorldBosses and not AutoFarmConfig.AutoFarmAllEnemiesInSelectedWorlds then
                local possibleLastEnemy = nil
                
                if game.PlaceId == 9230754391 then
                    possibleLastEnemy = "eternal_dragon"
                else
                    possibleLastEnemy = AutoFarmConfig.CurrentEnemy
                end
                
                if possibleLastEnemy then
                    Utilities.MarkEnemyDefeated(possibleLastEnemy)
                end
            end
        end
    end
end)

-- Enable autoload config
Luna:LoadAutoloadConfig()

-- Add Anti-AFK function
spawn(function()
    local VirtualUser = game:GetService("VirtualUser")
    
    Utilities.GetLocalPlayer().Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
end)

-- Function to upgrade stats
Utilities.UpgradeStat = function(statType)
    if not statType then return end
    
    local args = {
        [1] = statType
    }
    
    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("a0d1432a-262d-4b0a-9173-ee8b1dcfb69c"):FireServer(unpack(args))
    end)
end

-- Function to buy shop items
Utilities.BuyShopItem = function(itemName, amount)
    if not itemName or not amount then return end
    
    local args = {
        [1] = itemName,
        [2] = amount
    }
    
    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("41ccb1a6-1009-4e2f-924e-1b71f8020e9b"):FireServer(unpack(args))
    end)
end

--[[
    ÄNDERUNGSPROTOKOLL - MAI 2025
    
    - Remote-Pfade von "3aA" auf "kQR" aktualisiert
    - Remote-IDs für alle Funktionen aktualisiert:
      * SummonEnemy: 8a63919a-217b-436a-9cfa-4b472d213bbb
      * Battle Tower: 1457e535-9d02-4014-9883-7618f41bed84
      * Infinite Tower (Start): 60ed7d69-2cac-467c-9695-6ab3e77159b9
      * Infinite Tower (Ende): 23fb560d-73d0-404a-8dda-bf8088b08f0a
      * Infinite Tower (Pause): 5bdb0ab8-610f-4823-9e57-4cd48a5c4eb8
      * Exploration (Deploy): 4971f60f-90ff-4142-bf88-5395122136c2
      * Exploration (Claim): e82eeec1-ca38-4f7b-bf14-4b85df674c7b
      * Shop: 41ccb1a6-1009-4e2f-924e-1b71f8020e9b
      * Stats Upgrade: a0d1432a-262d-4b0a-9173-ee8b1dcfb69c
    - Auto-Farm, Raid und Infinite Tower Funktionen angepasst
    - Unterstützung für neue Enemy IDs und Endpoints hinzugefügt
]]

TabMisc:CreateDivider()
TabMisc:CreateSection("Auto-Execute")

-- Auto-Execute nach Teleport
TabMisc:CreateToggle({
    Name = "Auto-Execute nach Teleport",
    Description = "Führt das Skript automatisch nach einem Teleport im Spiel erneut aus",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            -- Code zum Speichern des Skripts für Auto-Execute
            local queueOnTeleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
            
            if queueOnTeleport then
                -- Das aktuelle Skript für die Ausführung nach dem Teleport in die Warteschlange stellen
                local scriptURL = "https://raw.githubusercontent.com/MythTeam/AnimeCardClash/main/RobloxScriptHubMythHub.lua"
                
                queueOnTeleport([[
                    -- Warte, bis das Spiel geladen ist
                    repeat wait() until game:IsLoaded()
                    wait(3)
                    
                    -- Führe das Skript aus
                    loadstring(game:HttpGet("]] .. scriptURL .. [[", true))()
                ]])
                
                -- Verbindung zum TeleportService herstellen
                local teleportService = game:GetService("TeleportService")
                local connection
                
                connection = teleportService.TeleportInitFailed:Connect(function(player, teleportResult, errorMessage)
                    if player == Utilities.GetLocalPlayer() then
                        Utilities.Notify("Auto-Execute", "Fehler beim Teleport: " .. errorMessage, "error")
                        -- Versuche es erneut
                        queueOnTeleport([[
                            -- Warte, bis das Spiel geladen ist
                            repeat wait() until game:IsLoaded()
                            wait(5)
                            
                            -- Führe das Skript aus
                            loadstring(game:HttpGet("]] .. scriptURL .. [[", true))()
                        ]])
                    end
                end)
                
                spawn(function()
                    -- Prüfe regelmäßig, ob wir uns noch im selben Spiel befinden
                    local currentGameId = game.PlaceId
                    while true do
                        wait(5)
                        if game.PlaceId ~= currentGameId then
                            -- Wir wurden bereits teleportiert, also die Verbindung trennen
                            if connection then
                                connection:Disconnect()
                                connection = nil
                            end
                            break
                        end
                    end
                end)
                
                Utilities.Notify("Auto-Execute", "Nach dem nächsten Teleport wird das Skript automatisch ausgeführt", "sync")
            else
                Utilities.Notify("Fehler", "Dein Executor unterstützt diese Funktion nicht", "error")
                return false
            end
        else
            -- Auto-Execute deaktivieren
            local queueOnTeleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
            
            if queueOnTeleport then
                queueOnTeleport("")
                Utilities.Notify("Auto-Execute", "Auto-Execute nach Teleport deaktiviert", "stop_circle")
            end
        end
    end
}, "AutoExecuteToggle")

-- Auto-Reconnect Funktion (speichert Konfiguration)
TabMisc:CreateToggle({
    Name = "Auto-Reconnect",
    Description = "Speichert die aktuelle Konfiguration und führt das Skript nach einem Neustart des Spiels aus",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            -- Aktuellen Executor prüfen
            local saveInstance = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
            
            if saveInstance then
                -- Aktuelle Konfiguration speichern
                local config = {}
                config.AutoFarm = AutoFarmConfig.Enabled
                config.CurrentEnemy = AutoFarmConfig.CurrentEnemy
                config.AutoCollect = AutoFarmConfig.AutoCollect
                config.AutoMerge = AutoFarmConfig.AutoMerge
                config.AutoFarmWorldBosses = AutoFarmConfig.AutoFarmAllWorldBosses
                config.TowerLevel = TowerConfig.BattleTowerLevel
                config.AutoContinuousTower = TowerConfig.AutoContinuousLevel
                config.AutoHighestTower = TowerConfig.AutoHighestLevel
                config.AutoSummonEternalDragon = RaidConfig.AutoSummonEternalDragon
                config.AutoSummonShadowDragon = RaidConfig.AutoSummonShadowDragon
                config.AutoClaimEasy = ExplorationConfig.AutoClaimEasy
                config.AutoClaimMedium = ExplorationConfig.AutoClaimMedium
                config.AutoClaimHard = ExplorationConfig.AutoClaimHard
                config.AutoClaimExtreme = ExplorationConfig.AutoClaimExtreme
                config.AutoClaimNightmare = ExplorationConfig.AutoClaimNightmare
                
                -- Als Datei speichern
                if writefile then
                    writefile("MythHubConfig.json", game:GetService("HttpService"):JSONEncode(config))
                end
                
                -- Auto-Execute mit Konfiguration
                local scriptURL = "https://raw.githubusercontent.com/MythTeam/AnimeCardClash/main/RobloxScriptHubMythHub.lua"
                
                saveInstance([[
                    -- Warte, bis das Spiel geladen ist
                    repeat wait() until game:IsLoaded()
                    wait(5)
                    
                    -- Skript laden
                    loadstring(game:HttpGet("]] .. scriptURL .. [[", true))()
                    
                    -- Konfiguration wiederherstellen
                    wait(3)
                    if readfile and isfile and isfile("MythHubConfig.json") then
                        local config = game:GetService("HttpService"):JSONDecode(readfile("MythHubConfig.json"))
                        -- Hier wird die Skriptkonfiguration automatisch geladen
                        -- Die Funktionen werden im nächsten Update implementiert
                    end
                ]])
                
                -- Persistent Auto-Reconnect (zwischen Spielsitzungen)
                -- Dieses Feature erfordert einen Executor, der Dateien zwischen Sitzungen speichern kann
                if isfile and writefile and readfile then
                    writefile("MythHubAutoStart.lua", [[
                        -- Warte, bis das Spiel geladen ist
                        repeat wait() until game:IsLoaded()
                        wait(5)
                        
                        -- Prüfe, ob wir im richtigen Spiel sind
                        if game.PlaceId == 16018202702 or game.PlaceId == 9230754391 then -- Anime Card Clash IDs
                            -- Skript laden
                            loadstring(game:HttpGet("]] .. scriptURL .. [[", true))()
                            
                            -- Konfiguration wiederherstellen
                            wait(3)
                            if isfile("MythHubConfig.json") then
                                -- Konfiguration wird automatisch geladen
                            end
                        end
                    ]])
                    
                    Utilities.Notify("Auto-Reconnect", "Persistente Auto-Start-Datei erstellt", "sync")
                end
                
                Utilities.Notify("Auto-Reconnect", "Konfiguration gespeichert und Auto-Execute aktiviert", "sync")
            else
                Utilities.Notify("Fehler", "Dein Executor unterstützt diese Funktion nicht", "error")
                return false
            end
        else
            -- Auto-Reconnect deaktivieren
            if isfile and isfile("MythHubConfig.json") then
                delfile("MythHubConfig.json")
            end
            
            if isfile and isfile("MythHubAutoStart.lua") then
                delfile("MythHubAutoStart.lua")
            end
            
            local queueOnTeleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
            if queueOnTeleport then
                queueOnTeleport("")
                Utilities.Notify("Auto-Reconnect", "Auto-Reconnect deaktiviert", "stop_circle")
            end
        end
    end
}, "AutoReconnectToggle")

TabMisc:CreateDivider()
TabMisc:CreateSection("Webhook Notifications")

-- Webhook Configuration
local WebhookConfig = {
    Enabled = false,
    URL = "",
    NotifyRareDrops = true,
    NotifyBossFights = true,
    NotifyTowerCompletion = true,
    NotifyRaidCompletion = true,
    Connections = {}
}

-- Webhook URL Input
local webhook_url_input = TabMisc:CreateInput({
    Name = "Discord Webhook URL",
    Description = "Enter the Discord Webhook URL",
    PlaceholderText = "https://discord.com/api/webhooks/...",
    CurrentValue = "",
    Numeric = false,
    MaxCharacters = 500,
    Enter = true,
    Callback = function(Text)
        WebhookConfig.URL = Text
        Utilities.Notify("Webhook", "Webhook URL saved", "webhook")
    end
}, "WebhookURL")

-- Webhook Toggle
local webhook_toggle = TabMisc:CreateToggle({
    Name = "Enable Webhook Notifications",
    Description = "Activates notifications via the configured webhook",
    CurrentValue = false,
    Callback = function(Value)
        WebhookConfig.Enabled = Value
        
        if Value then
            if WebhookConfig.URL == "" then
                Utilities.Notify("Webhook", "Please enter a webhook URL first", "error")
                return false
            end
            
            -- Test Webhook
            Utilities.SendWebhook({
                username = "MythHub",
                embeds = {{
                    title = "Webhook Test",
                    description = "The webhook connection was established successfully!",
                    color = 5814783, -- Blue in decimal
                    fields = {{
                        name = "Player",
                        value = Utilities.GetLocalPlayer().Name,
                        inline = true
                    }, {
                        name = "Server ID",
                        value = game.JobId,
                        inline = true
                    }},
                    footer = {
                        text = "MythHub Premium - Anime Card Clash"
                    },
                    timestamp = DateTime.now():ToIsoDate()
                }}
            })
            
            Utilities.Notify("Webhook", "Webhook notifications enabled", "webhook")
        else
            Utilities.Notify("Webhook", "Webhook notifications disabled", "webhook")
        end
    end
}, "WebhookToggle")

-- Notification options
TabMisc:CreateToggle({
    Name = "Notify on Item Drops",
    Description = "Sends a notification when an item is dropped",
    CurrentValue = true,
    Callback = function(Value)
        WebhookConfig.NotifyRareDrops = Value
    end
}, "WebhookRareDrops")

TabMisc:CreateToggle({
    Name = "Notify on Boss Fights",
    Description = "Sends a notification when a boss fight starts",
    CurrentValue = true,
    Callback = function(Value)
        WebhookConfig.NotifyBossFights = Value
    end
}, "WebhookBossFights")

TabMisc:CreateToggle({
    Name = "Notify on Tower Completion",
    Description = "Sends a notification when a tower is completed",
    CurrentValue = true,
    Callback = function(Value)
        WebhookConfig.NotifyTowerCompletion = Value
    end
}, "WebhookTowerCompletion")

TabMisc:CreateToggle({
    Name = "Notify on Raid Completion",
    Description = "Sends a notification when a raid is completed",
    CurrentValue = true,
    Callback = function(Value)
        WebhookConfig.NotifyRaidCompletion = Value
    end
}, "WebhookRaidCompletion")

-- Function to send webhook notifications
Utilities.SendWebhook = function(data)
    if not WebhookConfig.Enabled or WebhookConfig.URL == "" then
        return
    end
    
    local success, result = pcall(function()
        local HttpService = game:GetService("HttpService")
        local jsonData = HttpService:JSONEncode(data)
        
        -- Send HTTP request via executor
        local httpRequest = (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or request
        
        if httpRequest then
            httpRequest({
                Url = WebhookConfig.URL,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonData
            })
            return true
        else
            return false
        end
    end)
    
    if not success or not result then
        warn("Webhook request failed: " .. tostring(result))
    end
end

-- Boss fight detection for webhook
spawn(function()
    while wait(1) do
        if WebhookConfig.Enabled and WebhookConfig.NotifyBossFights then
            if Utilities.IsInBattle() then
                -- Check if we're fighting a boss
                local localPlayer = Utilities.GetLocalPlayer()
                if localPlayer and localPlayer.PlayerGui then
                    local battleGui = localPlayer.PlayerGui:FindFirstChild("battle")
                    if battleGui then
                        -- Try to determine the enemy name
                        local enemyName = "Unknown Boss"
                        pcall(function()
                            -- The exact path to the enemy name may vary
                            -- Depending on the UI structure in the game
                            local nameLabel = battleGui:FindFirstChild("EnemyName", true)
                            if nameLabel and nameLabel:IsA("TextLabel") then
                                enemyName = nameLabel.Text
                            end
                        end)
                        
                        -- Check if it's a boss
                        local isBoss = false
                        for _, bossName in pairs(AutoFarmConfig.WorldBosses) do
                            if string.find(enemyName:lower(), bossName:lower()) then
                                isBoss = true
                                break
                            end
                        end
                        
                        if isBoss then
                            -- Send webhook notification for boss fight
                            Utilities.SendWebhook({
                                username = "MythHub",
                                embeds = {{
                                    title = "Boss Fight Started",
                                    description = "A boss fight has begun!",
                                    color = 15158332, -- Red in decimal
                                    fields = {{
                                        name = "Boss",
                                        value = enemyName,
                                        inline = true
                                    }, {
                                        name = "Player",
                                        value = localPlayer.Name,
                                        inline = true
                                    }},
                                    footer = {
                                        text = "MythHub Premium - Anime Card Clash"
                                    },
                                    timestamp = DateTime.now():ToIsoDate()
                                }}
                            })
                            
                            -- Wait a while to avoid repeated notifications
                            wait(30)
                        end
                    end
                end
            end
        end
    end
end)

-- Item Drop Erkennung für Webhook
local function connectItemDrops()
    if WebhookConfig.Connections.ItemDrops then
        WebhookConfig.Connections.ItemDrops:Disconnect()
    end
    
    WebhookConfig.Connections.ItemDrops = workspace.ChildAdded:Connect(function(child)
        if WebhookConfig.Enabled and WebhookConfig.NotifyRareDrops then
            -- Wait a moment until the object is fully loaded
            wait(0.5)
            
            -- Check if it's a dropped item
            if child:IsA("Model") and child:FindFirstChild("Name") then
                local itemName = child.Name
                
                -- Send webhook notification for item drop
                Utilities.SendWebhook({
                    username = "MythHub",
                    embeds = {{
                        title = "Item Found!",
                        description = "An item was dropped!",
                        color = 8311585, -- Purple in decimal
                        fields = {{
                            name = "Item",
                            value = itemName,
                            inline = true
                        }, {
                            name = "Player",
                            value = Utilities.GetLocalPlayer().Name,
                            inline = true
                        }},
                        footer = {
                            text = "MythHub Premium - Anime Card Clash"
                        },
                        timestamp = DateTime.now():ToIsoDate()
                    }}
                })
            end
        end
    end)
end

-- Tower Completion Detection for Webhook
local function checkTowerCompletion()
    if WebhookConfig.Enabled and WebhookConfig.NotifyTowerCompletion then
        -- Check Battle Tower
        local battleTowerLevel = Utilities.GetBattleTowerLevel()
        local infiniteTowerFloor = Utilities.GetInfiniteTowerFloor()
        
        -- Save current levels/floors
        if not WebhookConfig.LastBattleTowerLevel then
            WebhookConfig.LastBattleTowerLevel = battleTowerLevel
        end
        
        if not WebhookConfig.LastInfiniteTowerFloor then
            WebhookConfig.LastInfiniteTowerFloor = infiniteTowerFloor
        end
        
        -- Check for changes
        if battleTowerLevel > WebhookConfig.LastBattleTowerLevel then
            -- Battle Tower Level completed
            Utilities.SendWebhook({
                username = "MythHub",
                embeds = {{
                    title = "Battle Tower Completed!",
                    description = "A Battle Tower level has been completed!",
                    color = 4037965, -- Green in decimal
                    fields = {{
                        name = "Level",
                        value = tostring(WebhookConfig.LastBattleTowerLevel),
                        inline = true
                    }, {
                        name = "New Level",
                        value = tostring(battleTowerLevel),
                        inline = true
                    }, {
                        name = "Player",
                        value = Utilities.GetLocalPlayer().Name,
                        inline = true
                    }},
                    footer = {
                        text = "MythHub Premium - Anime Card Clash"
                    },
                    timestamp = DateTime.now():ToIsoDate()
                }}
            })
            
            WebhookConfig.LastBattleTowerLevel = battleTowerLevel
        end
        
        if infiniteTowerFloor > WebhookConfig.LastInfiniteTowerFloor then
            -- Infinite Tower Floor completed
            Utilities.SendWebhook({
                username = "MythHub",
                embeds = {{
                    title = "Infinite Tower Completed!",
                    description = "An Infinite Tower floor has been completed!",
                    color = 4037965, -- Green in decimal
                    fields = {{
                        name = "Floor",
                        value = tostring(WebhookConfig.LastInfiniteTowerFloor),
                        inline = true
                    }, {
                        name = "New Floor",
                        value = tostring(infiniteTowerFloor),
                        inline = true
                    }, {
                        name = "Player",
                        value = Utilities.GetLocalPlayer().Name,
                        inline = true
                    }},
                    footer = {
                        text = "MythHub Premium - Anime Card Clash"
                    },
                    timestamp = DateTime.now():ToIsoDate()
                }}
            })
            
            WebhookConfig.LastInfiniteTowerFloor = infiniteTowerFloor
        end
    end
end

-- Raid Completion Detection
local function connectRaidCompletion()
    if WebhookConfig.Connections.RaidCompletion then
        WebhookConfig.Connections.RaidCompletion:Disconnect()
    end
    
    WebhookConfig.Connections.RaidCompletion = game:GetService("Players").LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
        if WebhookConfig.Enabled and WebhookConfig.NotifyRaidCompletion then
            if child.Name == "battle-end" then
                wait(1) -- Wait briefly for GUI to fully load
                
                -- Try to determine if it was a raid
                local wasRaid = false
                local raidBoss = "Unknown"
                
                pcall(function()
                    -- Check Battle-End GUI for indicators of a raid
                    if child:FindFirstChild("RaidRewards", true) or 
                       child:FindFirstChild("DragonRewards", true) then
                        wasRaid = true
                        
                        -- Try to determine the raid boss name
                        local bossNameLabel = child:FindFirstChild("BossName", true)
                        if bossNameLabel and bossNameLabel:IsA("TextLabel") then
                            raidBoss = bossNameLabel.Text
                        end
                    end
                end)
                
                if wasRaid then
                    -- Send webhook notification for completed raid
                    Utilities.SendWebhook({
                        username = "MythHub",
                        embeds = {{
                            title = "Raid Completed!",
                            description = "A raid has been successfully completed!",
                            color = 16766720, -- Gold in decimal
                            fields = {{
                                name = "Boss",
                                value = raidBoss,
                                inline = true
                            }, {
                                name = "Player",
                                value = Utilities.GetLocalPlayer().Name,
                                inline = true
                            }},
                            footer = {
                                text = "MythHub Premium - Anime Card Clash"
                            },
                            timestamp = DateTime.now():ToIsoDate()
                        }}
                    })
                end
            end
        end
    end)
end

-- Initialize Item Drop and Raid Completion connections
if WebhookConfig.Enabled then
    connectItemDrops()
    connectRaidCompletion()
end

-- Update webhook connections when the toggle is switched
WebhookConfig.UpdateConnections = function()
    if WebhookConfig.Enabled then
        connectItemDrops()
        connectRaidCompletion()
        
        -- Check if inventory webhook is enabled with continuous updates
        if WebhookConfig.InventorySendEnabled and not WebhookConfig.Connections.InventorySender then
            WebhookConfig.Connections.InventorySender = spawn(function()
                while WebhookConfig.InventorySendEnabled and WebhookConfig.Enabled do
                    -- Send/update the inventory immediately
                    pcall(Utilities.SendInventoryWebhook)
                    
                    -- Debug info - we can see this in the output
                    warn("Sending inventory webhook update - next update in " .. (WebhookConfig.InventoryInterval/60) .. " minutes")
                    
                    -- Wait the configured interval before next update
                    wait(WebhookConfig.InventoryInterval) 
                end
            end)
        end
    else
        -- Disconnect connections when disabled
        if WebhookConfig.Connections.ItemDrops then
            WebhookConfig.Connections.ItemDrops:Disconnect()
            WebhookConfig.Connections.ItemDrops = nil
        end
        
        if WebhookConfig.Connections.RaidCompletion then
            WebhookConfig.Connections.RaidCompletion:Disconnect()
            WebhookConfig.Connections.RaidCompletion = nil
        end
        
        if WebhookConfig.Connections.InventorySender then
            WebhookConfig.Connections.InventorySender = nil -- It's a thread, not a connection
        end
    end
end

-- Update webhook status on toggle
webhook_toggle:Set({Callback = function(Value)
    WebhookConfig.Enabled = Value
    
    if Value then
        if WebhookConfig.URL == "" then
            Utilities.Notify("Webhook", "Please enter a webhook URL first", "error")
            return false
        end
        
        -- Test Webhook
        Utilities.SendWebhook({
            username = "MythHub",
            embeds = {{
                title = "Webhook Test",
                description = "Webhook connection established successfully!",
                color = 5814783, -- Blue in decimal
                fields = {{
                    name = "Player",
                    value = Utilities.GetLocalPlayer().Name,
                    inline = true
                }, {
                    name = "Server ID",
                    value = game.JobId,
                    inline = true
                }},
                footer = {
                    text = "MythHub Premium - Anime Card Clash"
                },
                timestamp = DateTime.now():ToIsoDate()
            }}
        })
        
        WebhookConfig.UpdateConnections()
        Utilities.Notify("Webhook", "Webhook notifications enabled", "webhook")
    else
        WebhookConfig.UpdateConnections()
        Utilities.Notify("Webhook", "Webhook notifications disabled", "webhook")
    end
end})

-- Update changelog
if WebhookConfig then
    local changelogText = [[
    CHANGELOG - MAY 2025
    
    - Remote paths updated from "3aA" to "kQR"
    - Remote IDs updated for all functions:
      * SummonEnemy: 8a63919a-217b-436a-9cfa-4b472d213bbb
      * Battle Tower: 1457e535-9d02-4014-9883-7618f41bed84
      * Infinite Tower (Start): 60ed7d69-2cac-467c-9695-6ab3e77159b9
      * Infinite Tower (End): 23fb560d-73d0-404a-8dda-bf8088b08f0a
      * Infinite Tower (Pause): 5bdb0ab8-610f-4823-9e57-4cd48a5c4eb8
      * Exploration (Deploy): 4971f60f-90ff-4142-bf88-5395122136c2
      * Exploration (Claim): e82eeec1-ca38-4f7b-bf14-4b85df674c7b
      * Shop: 41ccb1a6-1009-4e2f-924e-1b71f8020e9b
      * Stats Upgrade: a0d1432a-262d-4b0a-9173-ee8b1dcfb69c
    - Auto-Farm, Raid and Infinite Tower functions adjusted
    - Support for new Enemy IDs and Endpoints added
    - Auto-Execute after teleport added
    - Auto-Reconnect with configuration saving added
    - Discord Webhook integration added
    - Inventory Webhook with live updates implemented
    ]]
    
    -- Update the changelog at the end of the script
    local lines = {}
    for line in changelogText:gmatch("[^\r\n]+") do
        table.insert(lines, line)
    end
    
    -- Replace the existing changelog
    local script = debug.getinfo(1, "S").source:sub(2)
    local content = readfile(script)
    local startPattern = "%-%-%[%[%s*ÄNDERUNGSPROTOKOLL"
    local endPattern = "%]%]"
    
    local startPos = content:find(startPattern)
    local endPos = content:find(endPattern, startPos)
    
    if startPos and endPos then
        local preContent = content:sub(1, startPos - 1)
        local postContent = content:sub(endPos + 2)
        local newContent = preContent .. "--[[\n" .. changelogText .. "\n]]" .. postContent
        
        writefile(script, newContent)
    end
end

-- Add inventory functionality to WebhookConfig
WebhookConfig.InventorySendEnabled = false
WebhookConfig.InventoryInterval = 300 -- 5 minutes default value
WebhookConfig.LastInventorySend = 0

-- Inventory Webhook Section
TabMisc:CreateDivider()
TabMisc:CreateSection("Inventory Webhook")

-- Inventory Webhook Toggle
TabMisc:CreateToggle({
    Name = "Send Inventory via Webhook",
    Description = "Sends and continuously updates your inventory via webhook",
    CurrentValue = false,
    Callback = function(Value)
        WebhookConfig.InventorySendEnabled = Value
        
        if Value then
            if WebhookConfig.URL == "" then
                Utilities.Notify("Webhook", "Please enter a webhook URL first", "error")
                return false
            end
            
            -- Activate live updates
            WebhookConfig.UpdateConnections()
            
            -- Send immediately when activated
            Utilities.SendInventoryWebhook()
            
            Utilities.Notify("Webhook", "Inventory webhook enabled with scheduled updates", "webhook")
        else
            if WebhookConfig.Connections.InventorySender then
                WebhookConfig.Connections.InventorySender:Disconnect()
                WebhookConfig.Connections.InventorySender = nil
            end
            
            Utilities.Notify("Webhook", "Inventory webhook disabled", "webhook")
        end
    end
}, "InventoryWebhookToggle")

-- Interval Slider
TabMisc:CreateSlider({
    Name = "Interval (Minutes)",
    Description = "Time between inventory webhook updates",
    Range = {1, 60},
    Increment = 1,
    CurrentValue = 5,
    Callback = function(Value)
        WebhookConfig.InventoryInterval = Value * 60 -- Convert to seconds
        Utilities.Notify("Webhook", "Inventory interval set to " .. Value .. " minutes", "webhook")
    end
}, "InventoryIntervalSlider")

-- Button to send immediately
TabMisc:CreateButton({
    Name = "Send Inventory Now",
    Description = "Immediately sends your current inventory via webhook",
    Callback = function()
        if WebhookConfig.URL == "" then
            Utilities.Notify("Webhook", "Please enter a webhook URL first", "error")
            return
        end
        
        Utilities.SendInventoryWebhook()
        Utilities.Notify("Webhook", "Inventory has been sent", "webhook")
    end
})

-- Function to prepare and send inventory via webhook
Utilities.SendInventoryWebhook = function()
    if not WebhookConfig.Enabled or WebhookConfig.URL == "" then
        return
    end
    
    local success, result = pcall(function()
        -- Import necessary modules
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RuntimeLib = require(ReplicatedStorage:WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
        
        -- Check if modules exist before importing
        if not ReplicatedStorage or not RuntimeLib then
            warn("Required modules not found for inventory webhook")
            return false
        end
        
        -- Safe import with error handling
        local LocalUser, ItemsWithId, ItemCategory
        
        local importSuccess, importError = pcall(function()
            LocalUser = RuntimeLib.import(script, ReplicatedStorage, "TS", "user", "local", "local-user").LocalUser
            ItemsWithId = RuntimeLib.import(script, ReplicatedStorage, "TS", "item", "items").ItemsWithId
            ItemCategory = RuntimeLib.import(script, ReplicatedStorage, "TS", "item", "item-category").ItemCategory
        end)
        
        if not importSuccess then
            warn("Failed to import modules: " .. tostring(importError))
            return false
        end
        
        -- Validate imported modules
        if not LocalUser or not LocalUser.atomMap or not LocalUser.atomMap.player or not ItemsWithId then
            warn("Required game modules missing or invalid")
            return false
        end
        
        -- Category emojis
        local CATEGORY_EMOJIS = {
            POTION = "🧪",
            TRAIT = "⚛️",
            TITLE = "👑",
            EQUIPMENT = "🗡️",
            ARTIFACT = "🔮",
            INSTANT_ROLL = "🎲",
            CARD_BACK = "🎴",
            RAID = "🏯",
            MISC = "📦",
            -- Additional variants for different spellings
            ["Potion"] = "🧪",
            ["Trait"] = "⚛️",
            ["Title"] = "👑",
            ["Equipment"] = "🗡️",
            ["Artifact"] = "🔮",
            ["Instant Roll"] = "🎲",
            ["Card Back"] = "🎴",
            ["Raid"] = "🏯",
            ["Misc"] = "📦"
        }
        
        -- Define category colors for embeds
        local categoryColors = {
            POTION = 0x3498DB,    -- Blue
            TRAIT = 0x1ABC9C,     -- Turquoise
            TITLE = 0xF1C40F,     -- Gold
            EQUIPMENT = 0xE74C3C, -- Red
            ARTIFACT = 0x9B59B6,  -- Purple
            INSTANT_ROLL = 0x2ECC71, -- Green
            CARD_BACK = 0xE67E22, -- Orange
            RAID = 0x34495E,      -- Dark Blue
            MISC = 0x95A5A6       -- Gray
        }
        
        -- Returns the matching emoji for a category
        local function getCategoryEmoji(categoryName)
            -- Direct mapping with simple string checks
            local categoryLower = string.lower(tostring(categoryName or ""))
            
            if string.find(categoryLower, "potion") then
                return "🧪"
            elseif string.find(categoryLower, "trait") then
                return "⚛️"
            elseif string.find(categoryLower, "title") then
                return "👑"
            elseif string.find(categoryLower, "equipment") then
                return "🗡️"
            elseif string.find(categoryLower, "artifact") then
                return "🔮"
            elseif string.find(categoryLower, "instant") or string.find(categoryLower, "roll") then
                return "🎲"
            elseif string.find(categoryLower, "card") then
                return "🎴"
            elseif string.find(categoryLower, "raid") then
                return "🏯"
            elseif string.find(categoryLower, "misc") then
                return "📦"
            end
            
            return "❓" -- Fallback
        end
        
        -- Helper functions for better formatting
        local function divider(emoji)
            return string.rep(emoji or "━", 15)
        end
        
        local function formatHeader(text, emoji)
            return divider() .. "\n" .. emoji .. " **" .. text .. "** " .. emoji .. "\n" .. divider()
        end
        
        -- Safely get backpack items from the atom map
        local backpackItems = {}
        local itemCount = 0
        
        -- Try to get inventory items
        local getBackpackSuccess, getBackpackError = pcall(function()
            if LocalUser and LocalUser.atomMap and LocalUser.atomMap.player then
                local playerData = LocalUser.atomMap.player()
                if playerData and playerData.backpack and playerData.backpack.items then
                    return playerData.backpack.items
                end
            end
            return {}
        end)
        
        if not getBackpackSuccess then
            warn("Failed to get backpack items: " .. tostring(getBackpackError))
            -- Create a fallback warning message
            backpackItems = {}
        else
            backpackItems = getBackpackError or {}
        end
        
        -- Prepare to categorize items
        local categorizedItems = {}
        
        -- Process items
        for itemId, itemData in pairs(backpackItems) do
            local item = {
                id = itemId,
                data = itemData,
                info = ItemsWithId[itemId]
            }
            
            if item.info and item.info.category then
                local categoryName = item.info.category
                if not categorizedItems[categoryName] then
                    categorizedItems[categoryName] = {}
                end
                
                table.insert(categorizedItems[categoryName], item)
                itemCount = itemCount + 1
            end
        end
        
        -- Get player information
        local playerName = Utilities.GetLocalPlayer().Name
        local maskedUsername = playerName
        
        -- Get avatar image if available
        local logoUrl = "https://i.imgur.com/jVJ9q32.png"
        local HttpService = game:GetService("HttpService")
        local embeds = {}
        
        -- Create main embed with player info and stats
        local mainEmbed = {
            title = formatHeader("Player Stats", "👤"),
            color = 0x3498DB, -- Blue color
            thumbnail = {
                url = logoUrl
            },
            fields = {},
            footer = {
                text = "MythHub Premium • Anime Card Clash",
                icon_url = logoUrl
            }
        }
        
        -- Add player stats
        local statsSuccess, statsError = pcall(function()
            if LocalUser and LocalUser.atomMap and LocalUser.atomMap.player then
                local playerData = LocalUser.atomMap.player()
                if playerData then
                    table.insert(mainEmbed.fields, {
                        name = "📊 **Player Stats**",
                        value = string.format(
                            "👤 **Name:** %s\n💰 **Money:** %s\n💎 **Gems:** %s",
                            playerName,
                            playerData.money or "N/A",
                            playerData.gems or "N/A"
                        ),
                        inline = false
                    })
                end
            end
        end)
        
        if not statsSuccess then
            warn("Failed to get player stats: " .. tostring(statsError))
            table.insert(mainEmbed.fields, {
                name = "📊 **Player Stats**",
                value = "*Error retrieving player stats*",
                inline = false
            })
        end
        
        -- Add equipped items to main embed
        local equippedField = {
            name = "⚔️ **Equipped Items**",
            value = "",
            inline = false
        }
        
        local equippedTitle, equippedEquipment, equippedArtifact
        
        local getEquippedSuccess, getEquippedError = pcall(function()
            if LocalUser and LocalUser.backpack then
                equippedTitle = LocalUser.backpack:getEquippedTitle()
                equippedEquipment = LocalUser.backpack:getEquippedEquipment()
                equippedArtifact = LocalUser.backpack:getEquippedArtifact()
            end
        end)
        
        if not getEquippedSuccess then
            warn("Failed to get equipped items: " .. tostring(getEquippedError))
            equippedField.value = "*Error retrieving equipped items*"
        else
            -- Improved null checks for equipment
            if equippedTitle and type(equippedTitle) == "table" and equippedTitle.item and type(equippedTitle.item) == "table" and equippedTitle.item.name then
                equippedField.value = equippedField.value .. "👑 **Title:** " .. equippedTitle.item.name .. "\n"
            end
            
            if equippedEquipment and type(equippedEquipment) == "table" and equippedEquipment.item and type(equippedEquipment.item) == "table" and equippedEquipment.item.name then
                equippedField.value = equippedField.value .. "⚔️ **Equipment:** " .. equippedEquipment.item.name .. "\n"
            end
            
            if equippedArtifact and type(equippedArtifact) == "table" and equippedArtifact.item and type(equippedArtifact.item) == "table" and equippedArtifact.item.name then
                equippedField.value = equippedField.value .. "🔮 **Artifact:** " .. equippedArtifact.item.name .. "\n"
            end
            
            if equippedField.value == "" then
                equippedField.value = "*No items equipped*"
            end
        end
        
        table.insert(mainEmbed.fields, equippedField)
        
        -- Add Infinity Tower Level prominently
        local towerLevelField = {
            name = "🏯 **Infinity Tower Progress**",
            value = "",
            inline = false
        }
        
        -- Try to get Infinity Tower level
        local getTowerSuccess, towerLevel = pcall(function()
            if LocalUser and LocalUser.infiniteTower then
                return LocalUser.infiniteTower:getLevel() or 0
            elseif LocalUser and LocalUser.atomMap and LocalUser.atomMap.player then
                local playerData = LocalUser.atomMap.player()
                if playerData and playerData.infiniteTower then
                    return playerData.infiniteTower.level or 0
                elseif playerData and playerData.tower and playerData.tower.infiniteLevel then
                    return playerData.tower.infiniteLevel or 0
                end
            end
            return 0
        end)
        
        if not getTowerSuccess or towerLevel == 0 then
            towerLevelField.value = "*No data available*"
        else
            towerLevelField.value = "Current Level: **" .. towerLevel .. "**"
        end
        
        -- Add the tower level field prominently at the top
        table.insert(mainEmbed.fields, 1, towerLevelField)
        
        table.insert(embeds, mainEmbed)
        
        -- Create separate embed for each category for better readability
        for categoryName, items in pairs(categorizedItems) do
            if #items > 0 then
                local categoryEmoji = getCategoryEmoji(categoryName)
                local categoryEmbed = {
                    title = formatHeader(categoryName, categoryEmoji),
                    description = "**Total:** " .. #items .. " items",
                    color = categoryColors[categoryName] or 0x2ECC71, -- Green as default
                    fields = {},
                    footer = {
                        text = "MythHub Premium • Category: " .. categoryName,
                        icon_url = logoUrl
                    }
                }
                
                -- Group items
                local groupedItems = {}
                for _, item in ipairs(items) do
                    if not groupedItems[item.info.name] then
                        groupedItems[item.info.name] = {
                            count = 0,
                            equipped = false,
                            item = item
                        }
                    end
                    
                    groupedItems[item.info.name].count = groupedItems[item.info.name].count + (item.data.quantity or 1)
                    if item.data.equipped then
                        groupedItems[item.info.name].equipped = true
                    end
                end
                
                -- Convert to sorted array
                local sortedItems = {}
                for _, groupInfo in pairs(groupedItems) do
                    table.insert(sortedItems, groupInfo)
                end
                
                -- Sort by name
                table.sort(sortedItems, function(a, b)
                    return a.item.info.name < b.item.info.name
                end)
                
                -- Create fields with max 20 items per field
                local maxItemsPerField = 20
                local totalFields = math.ceil(#sortedItems / maxItemsPerField)
                
                for fieldIndex = 1, totalFields do
                    local startIdx = (fieldIndex - 1) * maxItemsPerField + 1
                    local endIdx = math.min(fieldIndex * maxItemsPerField, #sortedItems)
                    
                    local fieldValue = ""
                    for i = startIdx, endIdx do
                        local groupInfo = sortedItems[i]
                        local equipped = (groupInfo.equipped and "✅") or ""
                        
                        fieldValue = fieldValue .. string.format(
                            "**%s** (×%d) %s\n",
                            groupInfo.item.info.name or "Unknown Item",
                            groupInfo.count,
                            equipped
                        )
                    end
                    
                    local fieldName = categoryEmoji .. " **" .. categoryName .. "** (" .. #sortedItems .. ")"
                    if totalFields > 1 then
                        fieldName = fieldName .. " - Part " .. fieldIndex .. "/" .. totalFields
                    end
                    
                    table.insert(categoryEmbed.fields, {
                        name = fieldName,
                        value = fieldValue,
                        inline = false
                    })
                end
                
                table.insert(embeds, categoryEmbed)
            end
        end
        
        -- Send webhook with improved design
        local HttpService = game:GetService("HttpService")
        local httpRequest = (syn and syn.request) or (http and http.request) or (fluxus and fluxus.request) or request
        
        if httpRequest then
            -- Discord allows maximum 10 embeds per message
            if #embeds > 10 then
                embeds = {table.unpack(embeds, 1, 10)}
            end
            
            -- Create a nicer webhook title
            local currentDate = os.date("%m/%d/%Y", os.time())
            local webhookContent = "## 📋 MythHub Inventory Report - " .. currentDate .. "\n"
            webhookContent = webhookContent .. "Player: " .. maskedUsername .. " | Items: " .. tostring(itemCount)
            
            -- Improved webhook message with avatar and username
            -- Add the file directly as an attachment
            local fileData
            
            -- Improved error handling for the logo file
            local readSuccess, readResult = pcall(function()
                if isfile and readfile and isfile("MYTHLOGO.png") then
                    return readfile("MYTHLOGO.png")
                elseif getsynasset and readfile and isfile("MYTHLOGO.png") then
                    -- Alternative for Synapse X
                    return readfile("MYTHLOGO.png") 
                end
                return nil
            end)
            
            if readSuccess and readResult then
                fileData = readResult
            else
                warn("Logo file could not be read. Using alternative logo.")
            end
            
            -- HTTP Request with file attachment (if available)
            local requestSuccess, requestError = pcall(function()
                -- Prepare webhook URL and method
                local method = "POST"  -- Default: Create new message
                local url = WebhookConfig.URL
                
                -- If a message ID is already saved, update it instead of sending a new one
                if WebhookConfig.LastMessageID then
                    method = "PATCH"  -- PATCH to update an existing message
                    url = WebhookConfig.URL .. "/messages/" .. WebhookConfig.LastMessageID
                end
                
                local response
                
                if fileData then
                    response = httpRequest({
                        Url = url,
                        Method = method,
                        Headers = {
                            ["Content-Type"] = "multipart/form-data; boundary=---------------------------boundary"
                        },
                        Body = "---------------------------boundary\r\n" ..
                              'Content-Disposition: form-data; name="payload_json"\r\n' ..
                              "Content-Type: application/json\r\n\r\n" ..
                              HttpService:JSONEncode({
                                  username = "MythHub Inventory System",
                                  content = webhookContent,
                                  embeds = embeds
                              }) .. "\r\n" ..
                              "---------------------------boundary\r\n" ..
                              'Content-Disposition: form-data; name="file"; filename="MYTHLOGO.png"\r\n' ..
                              "Content-Type: image/png\r\n\r\n" ..
                              fileData .. "\r\n" ..
                              "---------------------------boundary--\r\n"
                    })
                else
                    -- Fallback ohne Dateianhang
                    response = httpRequest({
                        Url = url,
                        Method = method,
                        Headers = {
                            ["Content-Type"] = "application/json"
                        },
                        Body = HttpService:JSONEncode({
                            username = "MythHub Inventory System",
                            avatar_url = "https://i.imgur.com/jVJ9q32.png", -- Fallback
                            content = webhookContent,
                            embeds = embeds
                        })
                    })
                end
                
                -- Speichere Message-ID für künftige Updates
                if method == "POST" and response and response.Body then
                    local success, body = pcall(function() return HttpService:JSONDecode(response.Body) end)
                    if success and body and body.id then
                        WebhookConfig.LastMessageID = body.id
                        -- Debug-Info
                        warn("New webhook message ID saved: " .. tostring(body.id))
                    end
                end
            end)
            
            if not requestSuccess then
                warn("Webhook request failed: " .. tostring(requestError))
            end
            
            return true
        else
            return false
        end
    end)
    
    if not success then
        warn("Inventory webhook failed: " .. tostring(result))
    end
end

-- Start the Tower Completion Checker
spawn(function()
    while wait(30) do -- Check every 30 seconds
        pcall(checkTowerCompletion)
    end
end)

