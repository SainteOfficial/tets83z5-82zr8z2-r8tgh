--[[
    MythHub Premium
    Game: Anime Card Clash
    Created by: MythTeam
    
    Features:
    - Dashboard mit Informationen und Statistiken
    - AutoFarm für Gegner aus allen Welten
    - Tower-Automatisierung für Battle und Infinite Towers
    - Raid-Unterstützung und Automatisierung
    - Explorations-Management
    - Shop-Automatisierung
    - Verschiedene Utilities wie Auto-Pickup, Auto-Merge und mehr
    
    Zuletzt aktualisiert: Mai 2025
]]

print("Nothing to see here :O")

-- Load Luna Interface Library
local Luna = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/refs/heads/main/source.lua", true))()

-- Initialize Window without Key System
local Window = Luna:CreateWindow({
    Name = "MythHub Premium",
    Subtitle = "Anime Card Clash",
    LogoID = "134758479713826", -- MythHub logo ID
    LoadingEnabled = true,
    LoadingTitle = "MythHub Premium",
    LoadingSubtitle = "Anime Card Clash Edition",
    
    ConfigSettings = {
        RootFolder = "MythHub",
        ConfigFolder = "AnimeCardClash"
    },
    
    KeySystem = false
})

-- Utility Functions
local Utilities = {}

-- Füge eine sicherere WaitForChild-Funktion mit Timeout hinzu
Utilities.SafeWaitForChild = function(parent, childName, timeout)
    timeout = timeout or 10 -- Standard-Timeout von 10 Sekunden
    
    local startTime = os.time()
    local child = nil
    
    -- Versuche das Kind zu finden, bis es gefunden wird oder das Timeout erreicht ist
    while not child and os.time() - startTime < timeout do
        child = parent:FindFirstChild(childName)
        if child then
            return child
        end
        wait(0.1) -- Kurz warten, um nicht zu viel CPU zu verbrauchen
    end
    
    -- Wenn das Kind nicht gefunden wurde, gib eine Warnung aus
    if not child then
        warn("SafeWaitForChild: Konnte " .. childName .. " in " .. parent.Name .. " nicht finden (Timeout nach " .. timeout .. " Sekunden)")
        return nil
    end
    
    return child
end

-- Function to summon an enemy for battle
Utilities.SummonEnemy = function(enemyName)
    if not enemyName then
        return false
    end
    
    local success, result = pcall(function()
        local args = {
            [1] = enemyName
        }
        
        local replicatedStorage = game:GetService("ReplicatedStorage")
        -- Verwende SafeWaitForChild statt WaitForChild, um Infinite Yield zu vermeiden
        local childkQR = Utilities.SafeWaitForChild(replicatedStorage, "kQR", 5)
        if not childkQR then
            return false
        end
        
        local battleRemote = Utilities.SafeWaitForChild(childkQR, "8a63919a-217b-436a-9cfa-4b472d213bbb", 3)
        if not battleRemote then
            return false
        end
        
        battleRemote:FireServer(unpack(args))
        return true
    end)
    
    if not success then
        warn("SummonEnemy fehlgeschlagen: " .. tostring(result))
        return false
    end
    
    return true
end

-- Function to get local player
Utilities.GetLocalPlayer = function()
    return game:GetService("Players").LocalPlayer
end

-- Function to check if a player is in game
Utilities.IsInGame = function()
    return game:IsLoaded() and Utilities.GetLocalPlayer() ~= nil
end

-- Function to create notifications
Utilities.Notify = function(title, content, icon)
    Luna:Notification({
        Title = title or "MythHub Notification",
        Content = content or "Action completed successfully",
        Icon = icon or "notifications_active",
        ImageSource = "Material"
    })
end

-- Function to get Battle Tower level
Utilities.GetBattleTowerLevel = function()
    local success, result = pcall(function()
        local replicatedStorage = game:GetService("ReplicatedStorage")
        local TS = Utilities.SafeWaitForChild(replicatedStorage, "TS", 5)
        if not TS then return 1 end
        
        local user = Utilities.SafeWaitForChild(TS, "user", 3)
        if not user then return 1 end
        
        local localFolder = Utilities.SafeWaitForChild(user, "local", 3)
        if not localFolder then return 1 end
        
        local LocalUserModule = Utilities.SafeWaitForChild(localFolder, "local-user", 3)
        if not LocalUserModule then return 1 end
        
        local LocalUser = require(LocalUserModule).LocalUser
        local battleTowerWave = LocalUser.metadata:getAsNumber("battle_tower_wave")
        return battleTowerWave or 1
    end)
    
    if success then
        return result
    else
        return 1
    end
end

-- Function to get Infinite Tower floor
Utilities.GetInfiniteTowerFloor = function()
    local success, result = pcall(function()
        local LocalUser = require(game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        
        if LocalUser and LocalUser.infiniteTower then
            local document = LocalUser.infiniteTower:getDocument()
            if document and document.floor then
                return document.floor
            end
        end
        return 1
    end)
    
    if success and result then
        return result
    else
        return 1
    end
end

-- Function to get available upgrade points
Utilities.GetUpgradePoints = function()
    local success, result = pcall(function()
        local LocalUser = require(game:GetService("ReplicatedStorage"):WaitForChild("TS"):WaitForChild("user"):WaitForChild("local"):WaitForChild("local-user")).LocalUser
        return LocalUser.upgrades:getCards()
    end)
    
    if success then
        return result
    else
        return 0
    end
end

-- Function to check if player is in battle
Utilities.IsInBattle = function()
    local success, result = pcall(function()
        local localPlayer = Utilities.GetLocalPlayer()
        if localPlayer and localPlayer.PlayerGui then
            -- Prüft, ob eine der Kampf-GUIs existiert
            local hasBattleGui = localPlayer.PlayerGui:FindFirstChild("battle") ~= nil
            local hasHideBattleButton = localPlayer.PlayerGui:FindFirstChild("HideBattleButton") ~= nil
            
            -- Wenn eine der beiden GUIs existiert, ist der Spieler noch im Kampf
            return hasBattleGui or hasHideBattleButton
        end
        return false
    end)
    
    if success then
        return result
    else
        return false
    end
end

-- Function to check if battle just ended
Utilities.IsBattleEnded = function()
    local success, result = pcall(function()
        local localPlayer = Utilities.GetLocalPlayer()
        if localPlayer and localPlayer.PlayerGui then
            local hasBattleEndGui = localPlayer.PlayerGui:FindFirstChild("battle-end") ~= nil
            return hasBattleEndGui
        end
        return false
    end)
    
    if success then
        return result
    else
        return false
    end
end

-- Function to simulate mouse clicks (M1) in the middle-bottom of the screen
Utilities.ClickM1 = function(times)
    times = times or 10
    
    pcall(function()
        -- Get screen size
        local screenSize = workspace.CurrentCamera.ViewportSize
        local middleX = screenSize.X / 2
        local lowerY = screenSize.Y * 0.7 -- 70% down the screen (middle-bottom)
        
        for i = 1, times do
            game:GetService("VirtualInputManager"):SendMouseButtonEvent(middleX, lowerY, 0, true, game, 1)
            wait(0.1)
            game:GetService("VirtualInputManager"):SendMouseButtonEvent(middleX, lowerY, 0, false, game, 1)
            wait(0.1)
        end
    end)
end

-- Function to dismiss battle end screen
Utilities.DismissBattleEnd = function()
    -- Sicherheitsüberprüfung mit pcall
    pcall(function()
        if Utilities.IsBattleEnded() then
            wait(3)
            
            -- Klicke M1 wiederholt, bis der Endbildschirm weg ist
            local maxAttempts = 30 -- Maximale Versuche, um Endlosschleifen zu vermeiden
            local attempts = 0
            
            while Utilities.IsBattleEnded() and attempts < maxAttempts do
                -- Versuche, mit M1 zu klicken
                pcall(function()
                    Utilities.ClickM1(3)
                end)
                wait(0.5)
                attempts = attempts + 1
            end
            
            -- Etwas länger warten, um sicherzustellen, dass alles geschlossen ist
            wait(1)
        end
    end)
end

-- AutoFarm Configuration
local AutoFarmConfig = {
    Enabled = false,
    CurrentWorld = "Ninja Village",
    CurrentEnemy = "unstoppable_fist",
    AutoCollect = false,
    AutoMerge = false,
    AutoFarmAllWorldBosses = false,
    AutoFarmAllEnemies = false,
    SelectedWorlds = {"Ninja Village"},
    SelectedEnemies = {"unstoppable_fist"},
    WorldBosses = {
        "bijuu_beast",           -- Naruto Rage Mode
        "awakened_galactic_tyrant", -- Frieza
        "king_of_curses",        -- Sukuna
        "combat_giant",          -- Eren
        "awakened_pale_demon_lord", -- Muzan
        "soul_queen",            -- Big Mom
        "awakened_shadow_monarch"  -- Sung Jinwoo
    },
    AllEnemies = {
        -- Ninja Village
        "unstoppable_fist", -- Rock Lee
        "copy_ninja", -- Kakashi
        "awakened_dark_avenger", -- Sasuke
        "awakened_promised_child", -- Naruto Sage Mode
        "six_paths_of_pain", -- Pain
        "bijuu_beast", -- Naruto Rage Mode (Boss)
        
        -- Green Village
        "ultimate_warrior", -- Son Gohan
        "body_switcher", -- Captain Ginyu
        "namekian_sage", -- Piccolo
        "awakened_prideful_prince", -- Vegeta
        "awakened_earth_strongest", -- Goku
        "awakened_galactic_tyrant", -- Frieza (Boss)
        
        -- Shibuya Station
        "cursed_doll", -- Nobara
        "awakened_shadow_summoner", -- Megumi
        "cursed_fist", -- Yuji
        "rika_blessing", -- Yuta
        "limitless_master", -- Gojo
        "king_of_curses", -- Sukuna (Boss)
        
        -- Titans City
        "survey_commander", -- Erwin
        "blade_warrior", -- Mikasa
        "armored_giant", -- Reiner
        "beast_giant", -- Zeke
        "blade_captain", -- Levi
        "combat_giant", -- Eren (Boss)
        
        -- Dimensional Fortress
        "thunder_demon", -- Kaigaku
        "childish_demon", -- Hantengu
        "compass_demon", -- Akaza
        "awakened_frost_demon", -- Doma
        "awakened_six_eyed_slayer", -- Kokushibo
        "awakened_pale_demon_lord", -- Muzan (Boss)
        
        -- Candy Island
        "genie_commander", -- Daifuku
        "candy_master", -- Perospero
        "biscuit_warrior", -- Cracker
        "juice_queen", -- Smoothie
        "mochi_emperor", -- Katakuri
        "soul_queen", -- Big Mom (Boss)
        
        -- Solo City
        "light_saintess", -- Cha Hae-In
        "the_goliath", -- Thomas Andre
        "shadow_bear", -- Tank
        "shadow_commander", -- Igris
        "shadow_ant", -- Beru
        "awakened_shadow_monarch" -- Sung Jinwoo (Boss)
    },
    Interval = 10 * 60, -- 10 minutes cooldown
    Connections = {},
    EnemyCooldowns = {} -- Stellen wir sicher, dass dies als leeres Table initialisiert wird
}

-- Funktion, um sicherzustellen, dass EnemyCooldowns existiert
Utilities.EnsureEnemyCooldownsInitialized = function()
    if not AutoFarmConfig.EnemyCooldowns then
        AutoFarmConfig.EnemyCooldowns = {}
    end
end

-- Function to handle battle flow and start next battle
Utilities.StartNextBattle = function(enemyName)
    -- Sicherheitsüberprüfung für nil
    if not enemyName then
        return false
    end
    
    -- Stellen wir sicher, dass EnemyCooldowns existiert
    Utilities.EnsureEnemyCooldownsInitialized()
    
    -- Cooldown-Überprüfung mit Fehlerbehandlung
    local onCooldown = false
    pcall(function()
        local currentTime = os.time()
        if enemyName and AutoFarmConfig.EnemyCooldowns[enemyName] and AutoFarmConfig.EnemyCooldowns[enemyName] > currentTime then
            onCooldown = true
        end
    end)
    
    if onCooldown then
        return false
    end
    
    -- Überprüfung des Spielstatus mit Fehlerbehandlung
    local inBattle = Utilities.IsInBattle()
    local battleEnded = Utilities.IsBattleEnded()
    
    if inBattle then
        return false -- Bereits im Kampf, kann keinen neuen starten
    end
    
    if battleEnded then
        pcall(function()
            Utilities.DismissBattleEnd()
        end)
        wait(1) -- Kurz warten, um sicherzustellen, dass der Endbildschirm weg ist
        return false
    end
    
    -- Erneute Überprüfung, ob wir den Kampf starten können
    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
        local success = false
        
        -- Versuche, den Gegner zu beschwören
        pcall(function()
            local args = {
                [1] = enemyName
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
            success = true
        end)
        
        if success then
            -- Warten, damit der Kampf gestartet werden kann
            wait(2)
            
            -- Prüfen, ob wir im Kampf sind
            if Utilities.IsInBattle() then
                return true
            else
                -- Wenn wir nicht im Kampf sind, obwohl wir den Gegner beschworen haben, könnte er auf Cooldown sein
                pcall(function()
                    if enemyName and not (enemyName == "eternal_dragon" or enemyName == "shadow_dragon") then
                        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + AutoFarmConfig.Interval
                    end
                end)
                return false
            end
        end
        
        return success
    end
    
    return false
end

-- Function to mark an enemy as defeated (sets its cooldown)
Utilities.MarkEnemyDefeated = function(enemyName)
    if not enemyName then
        return
    end
    
    -- Check if enemy is a raid boss (eternal_dragon or shadow_dragon) or world boss
    local isRaidBoss = (enemyName == "eternal_dragon" or enemyName == "shadow_dragon")
    local isWorldBoss = false
    
    -- Check if it's a world boss
    for _, boss in ipairs(AutoFarmConfig.WorldBosses) do
        if enemyName == boss then
            isWorldBoss = true
            break
        end
    end
    
    -- Only set cooldown if it's not a raid boss
    if isRaidBoss then
        return
    elseif isWorldBoss then
        -- Still apply cooldown for world bosses (not raid bosses)
        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + 600
    else
        -- Set cooldown to exactly 10 minutes (600 seconds) for regular enemies
        AutoFarmConfig.EnemyCooldowns[enemyName] = os.time() + 600
    end
end

-- Enemy display names mapping
local EnemyDisplayNames = {
    -- Ninja Village
    unstoppable_fist = "Rock Lee",
    copy_ninja = "Kakashi",
    awakened_dark_avenger = "Sasuke",
    awakened_promised_child = "Naruto Sage Mode",
    six_paths_of_pain = "Pain",
    bijuu_beast = "Naruto Rage Mode (Boss)",
    
    -- Green Village
    ultimate_warrior = "Son Gohan",
    body_switcher = "Captain Ginyu",
    namekian_sage = "Piccolo",
    awakened_prideful_prince = "Vegeta",
    awakened_earth_strongest = "Goku",
    awakened_galactic_tyrant = "Frieza (Boss)",
    
    -- Shibuya Station
    cursed_doll = "Nobara",
    awakened_shadow_summoner = "Megumi",
    cursed_fist = "Yuji",
    rika_blessing = "Yuta",
    limitless_master = "Gojo",
    king_of_curses = "Sukuna (Boss)",
    
    -- Titans City
    survey_commander = "Erwin",
    blade_warrior = "Mikasa",
    armored_giant = "Reiner",
    beast_giant = "Zeke",
    blade_captain = "Levi",
    combat_giant = "Eren (Boss)",
    
    -- Dimensional Fortress
    thunder_demon = "Kaigaku",
    childish_demon = "Hantengu",
    compass_demon = "Akaza",
    awakened_frost_demon = "Doma",
    awakened_six_eyed_slayer = "Kokushibo",
    awakened_pale_demon_lord = "Muzan (Boss)",
    
    -- Candy Island
    genie_commander = "Daifuku",
    candy_master = "Perospero",
    biscuit_warrior = "Cracker",
    juice_queen = "Smoothie",
    mochi_emperor = "Katakuri",
    soul_queen = "Big Mom (Boss)",
    
    -- Solo City
    light_saintess = "Cha Hae-In",
    the_goliath = "Thomas Andre",
    shadow_bear = "Tank",
    shadow_commander = "Igris",
    shadow_ant = "Beru",
    awakened_shadow_monarch = "Sung Jinwoo (Boss)"
}

-- Function to generate enemy display options for dropdown
local function getEnemyDisplayOptions(enemies)
    local displayOptions = {}
    for _, enemyCode in ipairs(enemies) do
        table.insert(displayOptions, EnemyDisplayNames[enemyCode] .. " (" .. enemyCode .. ")")
    end
    return displayOptions
end

-- Function to extract enemy code from display option
local function getEnemyCodeFromDisplayOption(displayOption)
    return string.match(displayOption, "%(([^%)]+)%)")
end

-- Initialize Tabs
local TabDashboard = Window:CreateTab({
    Name = "Dashboard",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabAutoFarm = Window:CreateTab({
    Name = "AutoFarm",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabTowers = Window:CreateTab({
    Name = "Towers",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabRaids = Window:CreateTab({
    Name = "Raids",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabExploration = Window:CreateTab({
    Name = "Exploration",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabShop = Window:CreateTab({
    Name = "Shop",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabMisc = Window:CreateTab({
    Name = "Misc",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

local TabSettings = Window:CreateTab({
    Name = "Settings",
    Icon = "view_in_ar",
    ImageSource = "Material",
    ShowTitle = true
})

-- Create Home Tab with information dashboard
Window:CreateHomeTab({
    SupportedExecutors = {}, -- Kein Executor-Check, damit der Script für alle funktioniert
    DiscordInvite = "MythHubDiscord",
    Icon = 2
})

-- Dashboard Tab
TabDashboard:CreateParagraph({
    Title = "Welcome to MythHub Premium - Anime Card Clash",
    Text = "Thank you for choosing MythHub Premium for Anime Card Clash. This script offers a comprehensive suite of features to enhance your gameplay experience. Our premium features are optimized for the best executors on the market."
})

TabDashboard:CreateSection("Player Statistics")

local stats_section = TabDashboard:CreateParagraph({
    Title = "Your Statistics",
    Text = "Loading player statistics..."
})

-- Update player stats periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            local tower_level = Utilities.GetBattleTowerLevel()
            local infinite_floor = Utilities.GetInfiniteTowerFloor()
            local upgrade_points = Utilities.GetUpgradePoints()
            
            stats_section:Set({
                Text = "Battle Tower Level: " .. tower_level .. 
                      "\nInfinite Tower Floor: " .. infinite_floor .. 
                      "\nAvailable Upgrade Points: " .. upgrade_points
            })
        end
    end
end)

TabDashboard:CreateDivider()

-- Add executor compatibility warning
TabDashboard:CreateSection("Executor Compatibility")

TabDashboard:CreateParagraph({
    Title = "Free Executor Limitations",
    Text = "Please note that free executors may not support all features due to their limitations. Specifically:\n\n• Battle Tower automation will not work properly\n• Stat Points features are incompatible with free executors\n\nOther features like AutoFarm and basic automation should function normally. For the best experience, we recommend using premium executors such as Synapse X, Script-Ware, or Fluxus."
})

TabDashboard:CreateDivider()

TabDashboard:CreateSection("Latest Updates")

TabDashboard:CreateParagraph({
    Title = "Recent Changes",
    Text = "• Added Auto Raid function with boss detection\n• Improved AutoFarm efficiency and stability\n• Added Auto-Merge functionality\n• Fixed issues with Tower automation\n• Improved UI responsiveness"
})

-- Add premium features highlight
TabDashboard:CreateDivider()

TabDashboard:CreateSection("Premium Features")

TabDashboard:CreateParagraph({
    Title = "MythHub Premium Advantages",
    Text = "• Advanced Battle Tower automation (Premium executors only)\n• Stat Points optimization system\n• Multi-world boss farming\n• Intelligent cooldown management\n• Automatic exploration team management\n• Premium support via our Discord"
})

-- AutoFarm Tab
TabAutoFarm:CreateSection("Enemy Farm Configuration")

-- World selection
local world_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select Worlds",
    Description = "Choose the worlds to farm enemies from",
    Options = {"Ninja Village", "Green Village", "Shibuya Station", "Titans City", "Dimensional Fortress", "Candy Island", "Solo City"},
    CurrentOption = {"Ninja Village"},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Option)
        AutoFarmConfig.SelectedWorlds = Option
        -- Update enemy dropdown based on selected worlds
        updateEnemyDropdown(Option)
    end
}, "WorldSelection")

-- Enemy dropdown (will be updated based on world selection)
local enemy_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select Enemies",
    Description = "Choose the enemies to farm",
    Options = getEnemyDisplayOptions({"unstoppable_fist", "copy_ninja", "awakened_dark_avenger", "awakened_promised_child", "six_paths_of_pain", "bijuu_beast"}),
    CurrentOption = {EnemyDisplayNames["unstoppable_fist"] .. " (unstoppable_fist)"},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Option)
        local selectedEnemies = {}
        for _, displayOption in ipairs(Option) do
            local enemyCode = getEnemyCodeFromDisplayOption(displayOption)
            if enemyCode then
                table.insert(selectedEnemies, enemyCode)
            end
        end
        AutoFarmConfig.SelectedEnemies = selectedEnemies
        AutoFarmConfig.CurrentEnemy = selectedEnemies[1] or "unstoppable_fist"
    end
}, "EnemySelection")

-- Function to update enemy dropdown based on world selection
function updateEnemyDropdown(worlds)
    local allEnemies = {}
    local enemyCodes = {}
    
    -- If no worlds selected, default to Ninja Village
    if #worlds == 0 then
        worlds = {"Ninja Village"}
    end
    
    for _, world in ipairs(worlds) do
        if world == "Ninja Village" then
            for _, enemy in ipairs({"unstoppable_fist", "copy_ninja", "awakened_dark_avenger", "awakened_promised_child", "six_paths_of_pain", "bijuu_beast"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Green Village" then
            for _, enemy in ipairs({"ultimate_warrior", "body_switcher", "namekian_sage", "awakened_prideful_prince", "awakened_earth_strongest", "awakened_galactic_tyrant"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Shibuya Station" then
            for _, enemy in ipairs({"cursed_doll", "awakened_shadow_summoner", "cursed_fist", "rika_blessing", "limitless_master", "king_of_curses"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Titans City" then
            for _, enemy in ipairs({"survey_commander", "blade_warrior", "armored_giant", "beast_giant", "blade_captain", "combat_giant"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Dimensional Fortress" then
            for _, enemy in ipairs({"thunder_demon", "childish_demon", "compass_demon", "awakened_frost_demon", "awakened_six_eyed_slayer", "awakened_pale_demon_lord"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Candy Island" then
            for _, enemy in ipairs({"genie_commander", "candy_master", "biscuit_warrior", "juice_queen", "mochi_emperor", "soul_queen"}) do
                enemyCodes[enemy] = true
            end
        elseif world == "Solo City" then
            for _, enemy in ipairs({"light_saintess", "the_goliath", "shadow_bear", "shadow_commander", "shadow_ant", "awakened_shadow_monarch"}) do
                enemyCodes[enemy] = true
            end
        end
    end
    
    -- Convert to array
    for enemyCode, _ in pairs(enemyCodes) do
        table.insert(allEnemies, enemyCode)
    end
    
    -- Get display options
    local displayOptions = getEnemyDisplayOptions(allEnemies)
    
    -- Update dropdown
    enemy_dropdown:Set({
        Options = displayOptions,
        CurrentOption = {displayOptions[1]}
    })
    
    -- Update selected enemies
    AutoFarmConfig.SelectedEnemies = {allEnemies[1] or "unstoppable_fist"}
    AutoFarmConfig.CurrentEnemy = allEnemies[1] or "unstoppable_fist"
end

TabAutoFarm:CreateDivider()
TabAutoFarm:CreateSection("World Bosses")

-- World Boss section (moved from Raid tab)
local world_boss_dropdown = TabAutoFarm:CreateDropdown({
    Name = "Select World Boss",
    Description = "Choose a world boss to battle",
    Options = {
        "Naruto Rage Mode (bijuu_beast)",
        "Frieza (awakened_galactic_tyrant)",
        "Sukuna (king_of_curses)",
        "Eren (combat_giant)",
        "Muzan (awakened_pale_demon_lord)",
        "Big Mom (soul_queen)",
        "Sung Jinwoo (awakened_shadow_monarch)"
    },
    CurrentOption = {"Naruto Rage Mode (bijuu_beast)"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        -- Nothing needed here, will be used in the button below
    end
}, "WorldBossSelection")

TabAutoFarm:CreateButton({
    Name = "Fight Selected Boss",
    Description = "Start a battle against the selected world boss",
    Callback = function()
        local boss = world_boss_dropdown.CurrentOption
        if type(boss) == "table" then
            boss = boss[1]
        end
        
        local bossCode = getEnemyCodeFromDisplayOption(boss)
        if bossCode then
            Utilities.SummonEnemy(bossCode)
        end
    end
})

TabAutoFarm:CreateDivider()
TabAutoFarm:CreateSection("Auto Farm Options")

-- Auto Farm All World Bosses toggle
local autofarm_all_bosses_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm All World Bosses",
    Description = "Automatically cycles through all world bosses",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoFarmAllWorldBosses = Value
        
        if Value then
            -- Start auto farm all bosses
            Utilities.Notify("Auto Farm", "Started auto farming all world bosses", "auto_mode")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoFarmAllBosses then
                AutoFarmConfig.Connections.AutoFarmAllBosses:Disconnect()
            end
            
            -- Create new auto farm loop
            AutoFarmConfig.Connections.AutoFarmAllBosses = spawn(function()
                local currentBossIndex = 1
                local currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex] or "bijuu_beast"
                
                while AutoFarmConfig.AutoFarmAllWorldBosses do
                    -- Check if we need to update the current boss (for bosses not on cooldown)
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Try to find a boss that's not on cooldown
                        local allOnCooldown = true
                        local startingIndex = currentBossIndex
                        
                        for i = 1, #AutoFarmConfig.WorldBosses do
                            -- Calculate the next boss index with wrap-around
                            local nextIndex = (startingIndex + i - 1) % #AutoFarmConfig.WorldBosses + 1
                            local nextBoss = AutoFarmConfig.WorldBosses[nextIndex]
                            
                            -- Check if this boss is on cooldown
                            local currentTime = os.time()
                            if not AutoFarmConfig.EnemyCooldowns[nextBoss] or AutoFarmConfig.EnemyCooldowns[nextBoss] <= currentTime then
                                currentBossIndex = nextIndex
                                currentBoss = nextBoss
                                allOnCooldown = false
                                break
                            end
                        end
                        
                        if allOnCooldown then
                            -- All bosses are on cooldown, find the one with the shortest remaining cooldown
                            local shortestCooldown = math.huge
                            local shortestIndex = 1
                            
                            for i = 1, #AutoFarmConfig.WorldBosses do
                                local boss = AutoFarmConfig.WorldBosses[i]
                                local remainingCooldown = (AutoFarmConfig.EnemyCooldowns[boss] or 0) - currentTime
                                
                                if remainingCooldown < shortestCooldown then
                                    shortestCooldown = remainingCooldown
                                    shortestIndex = i
                                end
                            end
                            
                            currentBossIndex = shortestIndex
                            currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex]
                            
                            wait(math.min(5, math.max(1, shortestCooldown))) -- Wait at least 1 second, at most 5 seconds
                        else
                            -- Try to start battle with current boss (which is not on cooldown)
                            Utilities.StartNextBattle(currentBoss)
                        end
                    elseif Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        
                        -- Once battle is dismissed, mark the boss as defeated and move to next
                        if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(currentBoss)
                            
                            -- Move to next boss for next iteration
                            currentBossIndex = currentBossIndex % #AutoFarmConfig.WorldBosses + 1
                            currentBoss = AutoFarmConfig.WorldBosses[currentBossIndex]
                        end
                    end
                    
                    -- Wait 1 second before next check
                    wait(1)
                end
            end)
        else
            -- Stop auto farm all bosses
            Utilities.Notify("Auto Farm", "Stopped auto farming all world bosses", "stop_circle")
            
            -- Disconnect auto farm loop
            if AutoFarmConfig.Connections.AutoFarmAllBosses then
                AutoFarmConfig.Connections.AutoFarmAllBosses:Disconnect()
                AutoFarmConfig.Connections.AutoFarmAllBosses = nil
            end
        end
    end
}, "AutoFarmAllEnemiesToggle")

-- Auto Farm Toggle
local autofarm_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm Selected Enemy",
    Description = "Automatically spawns the currently selected enemy after cooldown",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.Enabled = Value
        
        if Value then
            Utilities.Notify("Auto Farm", "Started auto farming " .. AutoFarmConfig.CurrentEnemy .. " in " .. table.concat(AutoFarmConfig.SelectedWorlds, ", "), "auto_mode")
            
            if AutoFarmConfig.Connections.AutoFarm then
                AutoFarmConfig.Connections.AutoFarm:Disconnect()
            end
            
            AutoFarmConfig.Connections.AutoFarm = spawn(function()
                while AutoFarmConfig.Enabled do
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local currentTime = os.time()
                        if AutoFarmConfig.CurrentEnemy and AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] and AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] > currentTime then
                            local remainingCooldown = math.ceil(AutoFarmConfig.EnemyCooldowns[AutoFarmConfig.CurrentEnemy] - currentTime)
                            wait(math.min(5, remainingCooldown))
                        else
                            Utilities.StartNextBattle(AutoFarmConfig.CurrentEnemy)
                        end
                    elseif Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        
                        if AutoFarmConfig.CurrentEnemy and not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(AutoFarmConfig.CurrentEnemy)
                        end
                    end
                    
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Farm", "Stopped auto farming", "stop_circle")
            
            if AutoFarmConfig.Connections.AutoFarm then
                AutoFarmConfig.Connections.AutoFarm:Disconnect()
                AutoFarmConfig.Connections.AutoFarm = nil
            end
        end
    end
}, "AutoFarmToggle")

-- Auto collect loop ändern (langsamerer Tween)
local autocollect_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Collect Items",
    Description = "Automatically collects dropped items",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoCollect = Value
        
        if Value then
            -- Start auto collect
            Utilities.Notify("Auto Collect", "Started auto collecting items", "inventory_2")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoCollect then
                AutoFarmConfig.Connections.AutoCollect:Disconnect()
            end
            
            -- Create new auto collect loop
            AutoFarmConfig.Connections.AutoCollect = spawn(function()
                while AutoFarmConfig.AutoCollect do
                    pcall(function()
                        local items = workspace.Folder:GetChildren()
                        
                        for _, item in pairs(items) do
                            if item:IsA("Model") and AutoFarmConfig.AutoCollect then
                                -- Get item position
                                local itemPosition = item:GetPivot().Position
                                
                                -- Get player's character and humanoid root part
                                local character = Utilities.GetLocalPlayer().Character
                                if character and character:FindFirstChild("HumanoidRootPart") then
                                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                                    
                                    -- Tween to the item (langsamerer Tween: 2.0 statt 0.5 Sekunden)
                                    local tweenService = game:GetService("TweenService")
                                    local tweenInfo = TweenInfo.new(2.0, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
                                    
                                    local tween = tweenService:Create(
                                        humanoidRootPart,
                                        tweenInfo,
                                        {CFrame = CFrame.new(itemPosition)}
                                    )
                                    
                                    tween:Play()
                                    tween.Completed:Wait()
                                    
                                    -- Wait a bit to ensure item is collected
                                    wait(0.5)
                                end
                            end
                        end
                    end)
                    
                    wait(1) -- Wait before checking for new items
                end
            end)
        else
            -- Stop auto collect
            Utilities.Notify("Auto Collect", "Stopped auto collecting items", "stop_circle")
            
            -- Disconnect auto collect loop
            if AutoFarmConfig.Connections.AutoCollect then
                AutoFarmConfig.Connections.AutoCollect:Disconnect()
                AutoFarmConfig.Connections.AutoCollect = nil
            end
        end
    end
}, "AutoCollectToggle")

-- Auto merge toggle
local automerge_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Merge Units",
    Description = "Automatically merges your units",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoMerge = Value
        
        if Value then
            -- Start auto merge
            Utilities.Notify("Auto Merge", "Started auto merging units", "merge")
            
            -- Clear previous connections if any
            if AutoFarmConfig.Connections.AutoMerge then
                AutoFarmConfig.Connections.AutoMerge:Disconnect()
            end
            
            -- Create new auto merge loop
            AutoFarmConfig.Connections.AutoMerge = spawn(function()
                while AutoFarmConfig.AutoMerge do
                    pcall(function()
                        -- Example auto merge code
                        local args = {
                            [1] = 0,
                            [2] = "light_admiral",
                            [3] = 200,
                            [4] = false
                        }
                        
                        game:GetService("ReplicatedStorage"):WaitForChild("noV"):WaitForChild("b57b2bf9-5561-408a-8668-8d7afa1b05f0"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Wait before attempting to merge again
                end
            end)
        else
            -- Stop auto merge
            Utilities.Notify("Auto Merge", "Stopped auto merging units", "stop_circle")
            
            -- Disconnect auto merge loop
            if AutoFarmConfig.Connections.AutoMerge then
                AutoFarmConfig.Connections.AutoMerge:Disconnect()
                AutoFarmConfig.Connections.AutoMerge = nil
            end
        end
    end
}, "AutoMergeToggle")

-- Auto Farm All Enemies in Order toggle
local autofarm_all_enemies_inorder_toggle = TabAutoFarm:CreateToggle({
    Name = "Auto Farm All Enemies (In Order)",
    Description = "Automatically cycles through all enemies in the exact order from the list",
    CurrentValue = false,
    Callback = function(Value)
        AutoFarmConfig.AutoFarmAllEnemies = Value
        
        if Value then
            Utilities.Notify("Auto Farm", "Started auto farming all enemies in exact order", "auto_mode")
            
            if AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder then
                AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder:Disconnect()
            end
            
            AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder = spawn(function()
                local enemyIndex = 1
                
                -- Liste aller Gegner in exakter Reihenfolge
                local allEnemiesInOrder = {
                    -- Ninja Village
                    "unstoppable_fist", -- Rock Lee
                    "copy_ninja", -- Kakashi
                    "awakened_dark_avenger", -- Sasuke
                    "awakened_promised_child", -- Naruto Sage Mode
                    "six_paths_of_pain", -- Pain
                    "bijuu_beast", -- Naruto Rage Mode (Boss)
                    
                    -- Green Village
                    "ultimate_warrior", -- Son Gohan
                    "body_switcher", -- Captain Ginyu
                    "namekian_sage", -- Piccolo
                    "awakened_prideful_prince", -- Vegeta
                    "awakened_earth_strongest", -- Goku
                    "awakened_galactic_tyrant", -- Frieza (Boss)
                    
                    -- Shibuya Station
                    "cursed_doll", -- Nobara
                    "awakened_shadow_summoner", -- Megumi
                    "cursed_fist", -- Yuji
                    "rika_blessing", -- Yuta
                    "limitless_master", -- Gojo
                    "king_of_curses", -- Sukuna (Boss)
                    
                    -- Titans City
                    "survey_commander", -- Erwin
                    "blade_warrior", -- Mikasa
                    "armored_giant", -- Reiner
                    "beast_giant", -- Zeke
                    "blade_captain", -- Levi
                    "combat_giant", -- Eren (Boss)
                    
                    -- Dimensional Fortress
                    "thunder_demon", -- Kaigaku
                    "childish_demon", -- Hantengu
                    "compass_demon", -- Akaza
                    "awakened_frost_demon", -- Doma
                    "awakened_six_eyed_slayer", -- Kokushibo
                    "awakened_pale_demon_lord", -- Muzan (Boss)
                    
                    -- Candy Island
                    "genie_commander", -- Daifuku
                    "candy_master", -- Perospero
                    "biscuit_warrior", -- Cracker
                    "juice_queen", -- Smoothie
                    "mochi_emperor", -- Katakuri
                    "soul_queen", -- Big Mom (Boss)
                    
                    -- Solo City
                    "light_saintess", -- Cha Hae-In
                    "the_goliath", -- Thomas Andre
                    "shadow_bear", -- Tank
                    "shadow_commander", -- Igris
                    "shadow_ant", -- Beru
                    "awakened_shadow_monarch" -- Sung Jinwoo (Boss)
                }
                
                while AutoFarmConfig.AutoFarmAllEnemies do
                    local currentEnemy = allEnemiesInOrder[enemyIndex]
                    
                    -- Prüfen, ob wir in einem Kampf sind
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        -- Prüfen, ob der aktuelle Gegner auf Cooldown ist
                        local currentTime = os.time()
                        if not AutoFarmConfig.EnemyCooldowns[currentEnemy] or AutoFarmConfig.EnemyCooldowns[currentEnemy] <= currentTime then
                            -- Versuchen, den Kampf zu starten
                            Utilities.StartNextBattle(currentEnemy)
                            
                            -- Wenn der Kampf nicht gestartet werden konnte, zum nächsten Gegner wechseln
                            if not Utilities.IsInBattle() then
                                enemyIndex = (enemyIndex % #allEnemiesInOrder) + 1
                            end
                        else
                            -- Gegner ist auf Cooldown, zum nächsten wechseln
                            enemyIndex = (enemyIndex % #allEnemiesInOrder) + 1
                        end
                    elseif Utilities.IsInBattle() then
                        -- Wir sind in einem Kampf, warten
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        -- Kampf ist beendet, Endbildschirm schließen
                        Utilities.DismissBattleEnd()
                        
                        -- Nach dem Schließen des Endbildschirms den Gegner als besiegt markieren
                        if not Utilities.IsBattleEnded() and not Utilities.IsInBattle() then
                            Utilities.MarkEnemyDefeated(currentEnemy)
                            
                            -- Zum nächsten Gegner wechseln
                            enemyIndex = (enemyIndex % #allEnemiesInOrder) + 1
                        end
                    end
                    
                    -- Kurz warten vor der nächsten Überprüfung
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Farm", "Stopped auto farming all enemies in order", "stop_circle")
            
            if AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder then
                AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder:Disconnect()
                AutoFarmConfig.Connections.AutoFarmAllEnemiesInOrder = nil
            end
        end
    end
}, "AutoFarmAllEnemiesInOrderToggle")

-- Towers Tab
TabTowers:CreateSection("Battle Tower")

-- Battle Tower level display
local battle_tower_level = TabTowers:CreateLabel({
    Text = "Current Battle Tower Level: " .. Utilities.GetBattleTowerLevel(),
    Style = 1
})

-- Update Battle Tower level periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            battle_tower_level:Set({
                Text = "Current Battle Tower Level: " .. Utilities.GetBattleTowerLevel()
            })
        end
    end
end)

-- Tower Level Config
local TowerConfig = {
    BattleTowerLevel = 1,
    AutoContinuousLevel = false,
    AutoHighestLevel = false,
    Connections = {}
}

-- Battle Tower Level Dropdown instead of Input
local battle_tower_dropdown = TabTowers:CreateDropdown({
    Name = "Select Battle Tower Level",
    Description = "Choose a Tower Level (1-100)",
    Options = {"1", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50", 
               "55", "60", "65", "70", "75", "80", "85", "90", "95", "100"},
    CurrentOption = {"1"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        local level = tonumber(Option[1])
        if level then
            TowerConfig.BattleTowerLevel = level
        end
    end
}, "BattleTowerLevelDropdown")

-- Button to start the selected level
TabTowers:CreateButton({
    Name = "Start Battle Tower Level Once",
    Description = "Start the selected Battle Tower level",
    Callback = function()
        local level = TowerConfig.BattleTowerLevel
        
        if level and level >= 1 and level <= 100 then
            local args = {
                [1] = level
            }
            
            local success, result = pcall(function()
                local replicatedStorage = game:GetService("ReplicatedStorage")
                local childkQR = Utilities.SafeWaitForChild(replicatedStorage, "kQR", 5)
                if not childkQR then
                    Utilities.Notify("Fehler", "Konnte kQR in ReplicatedStorage nicht finden", "error")
                    return false
                end
                
                local towerRemote = Utilities.SafeWaitForChild(childkQR, "1457e535-9d02-4014-9883-7618f41bed84", 3)
                if not towerRemote then
                    Utilities.Notify("Fehler", "Konnte Tower-Remote in kQR nicht finden", "error")
                    return false
                end
                
                towerRemote:FireServer(unpack(args))
                return true
            end)
            
            if success and result then
                Utilities.Notify("Battle Tower", "Battle Tower started at level " .. level, "castle")
            else
                Utilities.Notify("Fehler", "Battle Tower konnte nicht gestartet werden", "error")
            end
        else
            Utilities.Notify("Fehler", "Bitte wähle ein Level zwischen 1 und 100", "error")
        end
    end
})

-- Toggle for continuous level
local continuous_tower_toggle = TabTowers:CreateToggle({
    Name = "Auto Continuous Battle Tower",
    Description = "Continuously starts the selected Battle Tower level",
    CurrentValue = false,
    Callback = function(Value)
        TowerConfig.AutoContinuousLevel = Value
        
        if Value then
            -- Activate auto continuous level
            Utilities.Notify("Battle Tower", "Auto Continuous Battle Tower activated for level " .. TowerConfig.BattleTowerLevel, "castle")
            
            -- Remove previous connections
            if TowerConfig.Connections.AutoContinuous then
                TowerConfig.Connections.AutoContinuous:Disconnect()
            end
            
            -- Create new auto continuous loop
            TowerConfig.Connections.AutoContinuous = spawn(function()
                while TowerConfig.AutoContinuousLevel do
                    -- Only start Battle Tower if we're not in a battle
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local args = {
                            [1] = TowerConfig.BattleTowerLevel
                        }
                        
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("1457e535-9d02-4014-9883-7618f41bed84"):FireServer(unpack(args))
                        end)
                        
                        Utilities.DebugPrint("Auto Continuous Battle Tower - Level " .. TowerConfig.BattleTowerLevel .. " started")
                    end
                    
                    wait(5) -- Check every 5 seconds
                end
            end)
        else
            -- Deactivate auto continuous level
            Utilities.Notify("Battle Tower", "Auto Continuous Battle Tower deactivated", "stop_circle")
            
            -- End loop
            if TowerConfig.Connections.AutoContinuous then
                TowerConfig.Connections.AutoContinuous:Disconnect()
                TowerConfig.Connections.AutoContinuous = nil
            end
        end
    end
}, "AutoContinuousTowerToggle")

-- Toggle for automatic highest level
local highest_tower_toggle = TabTowers:CreateToggle({
    Name = "Auto Highest Battle Tower",
    Description = "Automatically starts the highest possible Battle Tower level",
    CurrentValue = false,
    Callback = function(Value)
        TowerConfig.AutoHighestLevel = Value
        
        if Value then
            -- Activate auto highest level
            Utilities.Notify("Battle Tower", "Auto Highest Battle Tower activated", "castle")
            
            -- Remove previous connections
            if TowerConfig.Connections.AutoHighest then
                TowerConfig.Connections.AutoHighest:Disconnect()
            end
            
            -- Create new auto highest loop
            TowerConfig.Connections.AutoHighest = spawn(function()
                while TowerConfig.AutoHighestLevel do
                    -- Only start Battle Tower if we're not in a battle
                    if not Utilities.IsInBattle() and not Utilities.IsBattleEnded() then
                        local currentLevel = Utilities.GetBattleTowerLevel()
                        
                        local args = {
                            [1] = currentLevel
                        }
                        
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("1457e535-9d02-4014-9883-7618f41bed84"):FireServer(unpack(args))
                        end)
                        
                        Utilities.DebugPrint("Auto Highest Battle Tower - Level " .. currentLevel .. " started")
                    end
                    
                    wait(5) -- Check every 5 seconds
                end
            end)
        else
            -- Deactivate auto highest level
            Utilities.Notify("Battle Tower", "Auto Highest Battle Tower deactivated", "stop_circle")
            
            -- End loop
            if TowerConfig.Connections.AutoHighest then
                TowerConfig.Connections.AutoHighest:Disconnect()
                TowerConfig.Connections.AutoHighest = nil
            end
        end
    end
}, "AutoHighestTowerToggle")

-- Infinite Tower Tab
TabTowers:CreateSection("Infinite Tower")

-- Infinite Tower floor display
local infinite_tower_floor = TabTowers:CreateLabel({
    Text = "Current Infinite Tower Floor: " .. Utilities.GetInfiniteTowerFloor(),
    Style = 1
})

-- Update Infinite Tower floor periodically
spawn(function()
    while wait(5) do
        if Utilities.IsInGame() then
            infinite_tower_floor:Set({
                Text = "Current Infinite Tower Floor: " .. Utilities.GetInfiniteTowerFloor()
            })
        end
    end
end)

-- Infinite Tower control buttons
TabTowers:CreateButton({
    Name = "Start Infinite Tower",
    Description = "Begin the Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("60ed7d69-2cac-467c-9695-6ab3e77159b9"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Started Infinite Tower challenge", "castle")
        else
            Utilities.Notify("Error", "Failed to start Infinite Tower", "error")
        end
    end
})

TabTowers:CreateButton({
    Name = "Pause Infinite Tower",
    Description = "Pause the current Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("5bdb0ab8-610f-4823-9e57-4cd48a5c4eb8"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Paused Infinite Tower challenge", "pause")
        else
            Utilities.Notify("Error", "Failed to pause Infinite Tower", "error")
        end
    end
})

TabTowers:CreateButton({
    Name = "End Infinite Tower",
    Description = "End the current Infinite Tower challenge",
    Callback = function()
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("23fb560d-73d0-404a-8dda-bf8088b08f0a"):FireServer()
        end)
        
        if success then
            Utilities.Notify("Infinite Tower", "Ended Infinite Tower challenge", "stop_circle")
        else
            Utilities.Notify("Error", "Failed to end Infinite Tower", "error")
        end
    end
})

-- Raids Tab
TabRaids:CreateSection("Raid Management")

TabRaids:CreateParagraph({
    Title = "Raid Information",
    Text = "Raids offer exclusive rewards and powerful units. You can start a raid against the Eternal Dragon or other powerful bosses."
})

-- Auto Raid Configuration
local RaidConfig = {
    AutoSummonEternalDragon = false,
    AutoSummonShadowDragon = false,
    Connections = {}
}

-- Auto Summon Eternal Dragon toggle
local auto_summon_dragon_toggle = TabRaids:CreateToggle({
    Name = "Auto Fight Eternal Dragon",
    Description = "Automatically fights the Eternal Dragon at regular intervals",
    CurrentValue = false,
    Callback = function(Value)
        RaidConfig.AutoSummonEternalDragon = Value
        
        if Value then
            Utilities.Notify("Auto Raid", "Started auto fighting Eternal Dragon", "security")
            
            if RaidConfig.Connections.AutoSummonDragon then
                RaidConfig.Connections.AutoSummonDragon:Disconnect()
            end
            
            RaidConfig.Connections.AutoSummonDragon = spawn(function()
                while RaidConfig.AutoSummonEternalDragon do
                    if Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        wait(1)
                    else
                        pcall(function()
                            local args = {
                                [1] = "eternal_dragon"
                            }
                            
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
                        end)
                        wait(3)
                    end
                    
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Raid", "Stopped auto fighting Eternal Dragon", "stop_circle")
            
            if RaidConfig.Connections.AutoSummonDragon then
                RaidConfig.Connections.AutoSummonDragon:Disconnect()
                RaidConfig.Connections.AutoSummonDragon = nil
            end
        end
    end
}, "AutoSummonDragonToggle")

TabRaids:CreateButton({
    Name = "Fight Eternal Dragon Once",
    Description = "Start a raid against the Eternal Dragon immediately",
    Callback = function()
        local success, result = pcall(function()
            local args = {
                [1] = "eternal_dragon"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Raid Started", "Successfully started fight with Eternal Dragon", "security")
        else
            Utilities.Notify("Error", "Failed to start raid", "error")
        end
    end
})

-- Auto Summon Shadow Dragon toggle
local auto_summon_shadow_dragon_toggle = TabRaids:CreateToggle({
    Name = "Auto Fight Shadow Dragon",
    Description = "Automatically fights the Shadow Dragon at regular intervals",
    CurrentValue = false,
    Callback = function(Value)
        RaidConfig.AutoSummonShadowDragon = Value
        
        if Value then
            Utilities.Notify("Auto Raid", "Started auto fighting Shadow Dragon", "security")
            
            if RaidConfig.Connections.AutoSummonShadowDragon then
                RaidConfig.Connections.AutoSummonShadowDragon:Disconnect()
            end
            
            RaidConfig.Connections.AutoSummonShadowDragon = spawn(function()
                while RaidConfig.AutoSummonShadowDragon do
                    if Utilities.IsInBattle() then
                        wait(2)
                    elseif Utilities.IsBattleEnded() then
                        Utilities.DismissBattleEnd()
                        wait(1)
                    else
                        pcall(function()
                            local args = {
                                [1] = "shadow_dragon"
                            }
                            
                            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
                        end)
                        wait(3)
                    end
                    
                    wait(1)
                end
            end)
        else
            Utilities.Notify("Auto Raid", "Stopped auto fighting Shadow Dragon", "stop_circle")
            
            if RaidConfig.Connections.AutoSummonShadowDragon then
                RaidConfig.Connections.AutoSummonShadowDragon:Disconnect()
                RaidConfig.Connections.AutoSummonShadowDragon = nil
            end
        end
    end
}, "AutoSummonShadowDragonToggle")

TabRaids:CreateButton({
    Name = "Fight Shadow Dragon Once",
    Description = "Start a raid against the Shadow Dragon immediately",
    Callback = function()
        local success, result = pcall(function()
            local args = {
                [1] = "shadow_dragon"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("8a63919a-217b-436a-9cfa-4b472d213bbb"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Raid Started", "Successfully started fight with Shadow Dragon", "security")
        else
            Utilities.Notify("Error", "Failed to start raid", "error")
        end
    end
})

-- Exploration Tab
TabExploration:CreateSection("Exploration Management")

-- Exploration team configuration
local exploration_difficulty = TabExploration:CreateDropdown({
    Name = "Exploration Difficulty",
    Description = "Select the difficulty level for exploration",
    Options = {"easy", "medium", "hard", "extreme", "nightmare"},
    CurrentOption = {"easy"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        -- Nothing needed here, will be used in other functions
    end
}, "ExploreDifficulty")

-- Unit selection for exploration
local exploration_units = TabExploration:CreateInput({
    Name = "Exploration Units",
    Description = "Enter 4 unit names separated by commas",
    PlaceholderText = "e.g., dark_avenger,black_swordsman,dark_avenger,dark_avenger",
    CurrentValue = "dark_avenger,black_swordsman,dark_avenger,dark_avenger",
    Numeric = false,
    MaxCharacters = 100,
    Enter = false,
    Callback = function(Text)
        -- Nothing needed here, will be used in the deploy button
    end
}, "ExploreUnits")

TabExploration:CreateButton({
    Name = "Deploy Exploration Team",
    Description = "Send your selected units on an exploration mission",
    Callback = function()
        local difficulty = exploration_difficulty.CurrentOption
        if type(difficulty) == "table" then
            difficulty = difficulty[1]
        end
        
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = difficulty,
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("4971f60f-90ff-4142-bf88-5395122136c2"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for " .. difficulty .. " exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

TabExploration:CreateDivider()

TabExploration:CreateSection("Claim Rewards")

-- Exploration Claim Config
local ExplorationConfig = {
    AutoClaimEasy = false,
    AutoClaimMedium = false,
    AutoClaimHard = false,
    AutoClaimExtreme = false,
    AutoClaimNightmare = false,
    Connections = {}
}

-- Auto Claim Easy Toggle
local auto_claim_easy_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Easy Exploration Rewards",
    Description = "Automatically claims rewards from easy difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimEasy = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Easy Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimEasy then
                ExplorationConfig.Connections.AutoClaimEasy:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimEasy = spawn(function()
                while ExplorationConfig.AutoClaimEasy do
                    local args = {
                        [1] = "easy"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    Utilities.DebugPrint("Auto Claiming Easy Exploration Rewards")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Easy Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimEasy then
                ExplorationConfig.Connections.AutoClaimEasy:Disconnect()
                ExplorationConfig.Connections.AutoClaimEasy = nil
            end
        end
    end
}, "AutoClaimEasyToggle")

-- Auto Claim Medium Toggle
local auto_claim_medium_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Medium Exploration Rewards",
    Description = "Automatically claims rewards from medium difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimMedium = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Medium Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimMedium then
                ExplorationConfig.Connections.AutoClaimMedium:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimMedium = spawn(function()
                while ExplorationConfig.AutoClaimMedium do
                    local args = {
                        [1] = "medium"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    Utilities.DebugPrint("Auto Claiming Medium Exploration Rewards")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Medium Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimMedium then
                ExplorationConfig.Connections.AutoClaimMedium:Disconnect()
                ExplorationConfig.Connections.AutoClaimMedium = nil
            end
        end
    end
}, "AutoClaimMediumToggle")

-- Auto Claim Hard Toggle
local auto_claim_hard_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Hard Exploration Rewards",
    Description = "Automatically claims rewards from hard difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimHard = Value
        
        if Value then
            -- Activate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Hard Rewards activated", "redeem")
            
            -- Remove previous connections
            if ExplorationConfig.Connections.AutoClaimHard then
                ExplorationConfig.Connections.AutoClaimHard:Disconnect()
            end
            
            -- Create new Auto Claim loop
            ExplorationConfig.Connections.AutoClaimHard = spawn(function()
                while ExplorationConfig.AutoClaimHard do
                    local args = {
                        [1] = "hard"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            -- Deactivate Auto Claim
            Utilities.Notify("Exploration", "Auto Claim Hard Rewards deactivated", "stop_circle")
            
            -- End loop
            if ExplorationConfig.Connections.AutoClaimHard then
                ExplorationConfig.Connections.AutoClaimHard:Disconnect()
                ExplorationConfig.Connections.AutoClaimHard = nil
            end
        end
    end
}, "AutoClaimHardToggle")

-- Auto Claim Extreme Toggle
local auto_claim_extreme_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Extreme Exploration Rewards",
    Description = "Automatically claims rewards from extreme difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimExtreme = Value
        
        if Value then
            Utilities.Notify("Exploration", "Auto Claim Extreme Rewards activated", "redeem")
            
            if ExplorationConfig.Connections.AutoClaimExtreme then
                ExplorationConfig.Connections.AutoClaimExtreme:Disconnect()
            end
            
            ExplorationConfig.Connections.AutoClaimExtreme = spawn(function()
                while ExplorationConfig.AutoClaimExtreme do
                    local args = {
                        [1] = "extreme"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Exploration", "Auto Claim Extreme Rewards deactivated", "stop_circle")
            
            if ExplorationConfig.Connections.AutoClaimExtreme then
                ExplorationConfig.Connections.AutoClaimExtreme:Disconnect()
                ExplorationConfig.Connections.AutoClaimExtreme = nil
            end
        end
    end
}, "AutoClaimExtremeToggle")

-- Auto Claim Nightmare Toggle
local auto_claim_nightmare_toggle = TabExploration:CreateToggle({
    Name = "Auto Claim Nightmare Exploration Rewards",
    Description = "Automatically claims rewards from nightmare difficulty explorations",
    CurrentValue = false,
    Callback = function(Value)
        ExplorationConfig.AutoClaimNightmare = Value
        
        if Value then
            Utilities.Notify("Exploration", "Auto Claim Nightmare Rewards activated", "redeem")
            
            if ExplorationConfig.Connections.AutoClaimNightmare then
                ExplorationConfig.Connections.AutoClaimNightmare:Disconnect()
            end
            
            ExplorationConfig.Connections.AutoClaimNightmare = spawn(function()
                while ExplorationConfig.AutoClaimNightmare do
                    local args = {
                        [1] = "nightmare"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("e82eeec1-ca38-4f7b-bf14-4b85df674c7b"):FireServer(unpack(args))
                    end)
                    
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Exploration", "Auto Claim Nightmare Rewards deactivated", "stop_circle")
            
            if ExplorationConfig.Connections.AutoClaimNightmare then
                ExplorationConfig.Connections.AutoClaimNightmare:Disconnect()
                ExplorationConfig.Connections.AutoClaimNightmare = nil
            end
        end
    end
}, "AutoClaimNightmareToggle")

-- Explore Deployment for extreme
TabExploration:CreateDivider()
TabExploration:CreateSection("Extreme & Nightmare Exploration")

TabExploration:CreateButton({
    Name = "Deploy Extreme Exploration Team",
    Description = "Send your selected units on an extreme exploration mission",
    Callback = function()
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = "extreme",
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("4971f60f-90ff-4142-bf88-5395122136c2"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for extreme exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

TabExploration:CreateButton({
    Name = "Deploy Nightmare Exploration Team",
    Description = "Send your selected units on a nightmare exploration mission",
    Callback = function()
        local units_text = exploration_units.CurrentValue
        local units = {}
        
        for unit in string.gmatch(units_text, "[^,]+") do
            table.insert(units, string.trim(unit))
        end
        
        -- Ensure we have exactly 4 units
        while #units < 4 do
            table.insert(units, "dark_avenger")
        end
        
        if #units > 4 then
            units = {units[1], units[2], units[3], units[4]}
        end
        
        local args = {
            [1] = "nightmare",
            [2] = units
        }
        
        local success, result = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("4971f60f-90ff-4142-bf88-5395122136c2"):FireServer(unpack(args))
        end)
        
        if success then
            Utilities.Notify("Exploration", "Deployed team for nightmare exploration", "explore")
        else
            Utilities.Notify("Error", "Failed to deploy exploration team", "error")
        end
    end
})

-- Shop Tab
TabShop:CreateSection("Shop Management")

TabShop:CreateParagraph({
    Title = "Shop Information",
    Text = "Purchase various items from the shop to enhance your gameplay experience."
})

-- Shop items
TabShop:CreateButton({
    Name = "Buy Luck Potion (Small)",
    Description = "Purchase a small luck potion",
    Callback = function()
        Utilities.BuyShopItem("small_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Luck Potion (Medium)",
    Description = "Purchase a medium luck potion",
    Callback = function()
        Utilities.BuyShopItem("medium_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Luck Potion (Large)",
    Description = "Purchase a large luck potion",
    Callback = function()
        Utilities.BuyShopItem("large_luck_potion", 1)
    end
})

TabShop:CreateDivider()

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Small)",
    Description = "Purchase a small cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("small_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Medium)",
    Description = "Purchase a medium cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("medium_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Cooldown Reduction (Large)",
    Description = "Purchase a large cooldown reduction potion",
    Callback = function()
        Utilities.BuyShopItem("large_cooldown_reduction_potion", 1)
    end
})

TabShop:CreateDivider()

TabShop:CreateButton({
    Name = "Buy Raid Luck Potion",
    Description = "Purchase a raid luck potion",
    Callback = function()
        Utilities.BuyShopItem("raid_luck_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Border Chance Potion",
    Description = "Purchase a raid border chance potion",
    Callback = function()
        Utilities.BuyShopItem("raid_border_chance_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Cooldown Potion",
    Description = "Purchase a raid cooldown potion",
    Callback = function()
        Utilities.BuyShopItem("raid_cooldown_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Boss Chance Potion",
    Description = "Purchase a raid boss chance potion",
    Callback = function()
        Utilities.BuyShopItem("raid_boss_chance_potion", 1)
    end
})

TabShop:CreateButton({
    Name = "Buy Raid Moon Cycle Reroll Potion",
    Description = "Purchase a raid moon cycle reroll potion",
    Callback = function()
        Utilities.BuyShopItem("raid_moon_cycle_reroll_potion", 1)
    end
})

-- Misc Tab
TabMisc:CreateSection("Miscellaneous Features")

-- BillboardGui text modification (Hide Name feature)
local NameHideConfig = {
    Enabled = false,
    OriginalTexts = {},
    OriginalColors = {}
}

-- Function to toggle name hiding
Utilities.ToggleNameHide = function(value)
    NameHideConfig.Enabled = value
    
    if value then
        -- Save original values first (only if not already saved)
        if #NameHideConfig.OriginalTexts == 0 then
            pcall(function()
                -- First TextLabel (which will be changed to "JOIN DC")
                local joinLabel = workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2]
                if joinLabel and joinLabel:IsA("TextLabel") then
                    NameHideConfig.OriginalTexts[joinLabel] = joinLabel.Text
                    NameHideConfig.OriginalColors[joinLabel] = joinLabel.TextColor3
                    
                    -- Change to "JOIN DC" in white
                    joinLabel.Text = "JOIN DC"
                    joinLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- White
                end
                
                -- Second TextLabel (which will be changed to "MYTHHUB")
                local mythLabel = workspace.rswhshj.Head.BillboardGui.Frame.TextLabel
                if mythLabel and mythLabel:IsA("TextLabel") then
                    NameHideConfig.OriginalTexts[mythLabel] = mythLabel.Text
                    NameHideConfig.OriginalColors[mythLabel] = mythLabel.TextColor3
                    
                    -- Change to "MYTHHUB" in #11189D (dark blue)
                    mythLabel.Text = "MYTHHUB"
                    mythLabel.TextColor3 = Color3.fromRGB(17, 24, 157) -- #11189D in RGB
                end
            end)
        else
            -- Apply saved changes (in case they were reverted)
            pcall(function()
                workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2].Text = "JOIN DC"
                workspace.rswhshj.Head.BillboardGui.Frame:GetChildren()[2].TextColor3 = Color3.fromRGB(255, 255, 255)
                
                workspace.rswhshj.Head.BillboardGui.Frame.TextLabel.Text = "MYTHHUB"
                workspace.rswhshj.Head.BillboardGui.Frame.TextLabel.TextColor3 = Color3.fromRGB(17, 24, 157)
            end)
        end
    else
        -- Restore original values
        for label, originalText in pairs(NameHideConfig.OriginalTexts) do
            pcall(function()
                label.Text = originalText
                label.TextColor3 = NameHideConfig.OriginalColors[label]
            end)
        end
    end
end

-- Add Hide Name toggle
local hide_name_toggle = TabMisc:CreateToggle({
    Name = "Hide Name",
    Description = "Replaces the name with MYTHHUB and JOIN DC text",
    CurrentValue = false,
    Callback = function(Value)
        Utilities.ToggleNameHide(Value)
        
        if Value then
            Utilities.Notify("Name Hider", "Name hidden with custom text", "person")
        else
            Utilities.Notify("Name Hider", "Original name restored", "person")
        end
    end
}, "HideNameToggle")

-- Remove the "Enemy Cooldown Information" section and replace with a detailed cooldown display
TabMisc:CreateSection("Enemy Cooldown Information")

-- Create a function to display enemy cooldowns
local function createCooldownDisplay()
    -- Create the main paragraph for cooldowns
    local cooldownParagraph = TabMisc:CreateParagraph({
        Title = "Current Enemy Cooldowns",
        Text = "Checking cooldowns..."
    })
    
    -- Update function that will be called periodically
    local function updateCooldowns()
        local text = ""
        local currentTime = os.time()
        local hasCooldowns = false
        
        -- Check existence of EnemyCooldowns table
        if not AutoFarmConfig.EnemyCooldowns then
            AutoFarmConfig.EnemyCooldowns = {}
        end
        
        -- Boss names
        local worldBosses = {
            bijuu_beast = "Naruto Rage Mode",
            awakened_galactic_tyrant = "Frieza",
            king_of_curses = "Sukuna",
            combat_giant = "Eren",
            awakened_pale_demon_lord = "Muzan",
            soul_queen = "Big Mom",
            awakened_shadow_monarch = "Sung Jinwoo"
        }
        
        -- Regular enemy names
        local regularEnemies = {
            -- Ninja Village
            unstoppable_fist = "Rock Lee",
            copy_ninja = "Kakashi",
            awakened_dark_avenger = "Sasuke",
            awakened_promised_child = "Naruto Sage Mode",
            six_paths_of_pain = "Pain",
            
            -- Green Village
            ultimate_warrior = "Son Gohan",
            body_switcher = "Captain Ginyu",
            namekian_sage = "Piccolo",
            awakened_prideful_prince = "Vegeta",
            awakened_earth_strongest = "Goku",
            
            -- Shibuya Station
            cursed_doll = "Nobara",
            awakened_shadow_summoner = "Megumi",
            cursed_fist = "Yuji",
            rika_blessing = "Yuta",
            limitless_master = "Gojo",
            
            -- Titans City
            survey_commander = "Erwin",
            blade_warrior = "Mikasa",
            armored_giant = "Reiner",
            beast_giant = "Zeke",
            blade_captain = "Levi",
            
            -- Dimensional Fortress
            thunder_demon = "Kaigaku",
            childish_demon = "Hantengu",
            compass_demon = "Akaza",
            awakened_frost_demon = "Doma",
            awakened_six_eyed_slayer = "Kokushibo",
            
            -- Candy Island
            genie_commander = "Daifuku",
            candy_master = "Perospero",
            biscuit_warrior = "Cracker",
            juice_queen = "Smoothie",
            mochi_emperor = "Katakuri",
            
            -- Solo City
            light_saintess = "Cha Hae-In",
            the_goliath = "Thomas Andre",
            shadow_bear = "Tank",
            shadow_commander = "Igris",
            shadow_ant = "Beru"
        }
        
        -- Add world bosses to cooldown display
        text = text .. "--- World Bosses ---\n"
        for enemyCode, bossName in pairs(worldBosses) do
            local cooldownTime = AutoFarmConfig.EnemyCooldowns[enemyCode]
            if cooldownTime and cooldownTime > currentTime then
                local remainingTime = cooldownTime - currentTime
                local minutes = math.floor(remainingTime / 60)
                local seconds = remainingTime % 60
                text = text .. bossName .. ": " .. string.format("%02d:%02d", minutes, seconds) .. "\n"
                hasCooldowns = true
            else
                text = text .. bossName .. ": Ready\n"
            end
        end
        
        -- Add regular enemies to cooldown display
        text = text .. "\n--- Regular Enemies ---\n"
        for enemyCode, enemyName in pairs(regularEnemies) do
            local cooldownTime = AutoFarmConfig.EnemyCooldowns[enemyCode]
            if cooldownTime and cooldownTime > currentTime then
                local remainingTime = cooldownTime - currentTime
                local minutes = math.floor(remainingTime / 60)
                local seconds = remainingTime % 60
                text = text .. enemyName .. ": " .. string.format("%02d:%02d", minutes, seconds) .. "\n"
                hasCooldowns = true
            end
        end
        
        if not hasCooldowns then
            text = text .. "No enemies on cooldown."
        end
        
        -- Update the paragraph text
        cooldownParagraph:Set({
            Text = text
        })
    end
    
    -- Initial update
    updateCooldowns()
    
    -- Start a timer to update the cooldowns every second
    spawn(function()
        while wait(1) do
            updateCooldowns()
        end
    end)
end

-- Create the cooldown display
createCooldownDisplay()

TabMisc:CreateDivider()

-- Create a section for Performance Optimization in the Misc Tab
TabMisc:CreateSection("Performance Optimization")

-- FPS Boost
TabMisc:CreateToggle({
    Name = "FPS Boost",
    Description = "Reduces graphics quality to increase performance",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            -- Enable FPS Boost
            pcall(function()
                -- Reduce graphics quality
                local lighting = game:GetService("Lighting")
                lighting.GlobalShadows = false
                lighting.ShadowSoftness = 0
                lighting.Technology = Enum.Technology.Compatibility
                
                -- Disable unnecessary rendering
                settings().Rendering.QualityLevel = 1
                
                -- Reduce terrain quality
                workspace.Terrain.WaterWaveSize = 0
                workspace.Terrain.WaterWaveSpeed = 0
                workspace.Terrain.WaterReflectance = 0
                workspace.Terrain.WaterTransparency = 0
                
                -- Disable textures and effects
                for _, v in pairs(workspace:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Trail") or v:IsA("Smoke") or v:IsA("Fire") then
                        v.Enabled = false
                    end
                end
                
                Utilities.Notify("Performance", "FPS Boost enabled", "speed")
            end)
        else
            -- Restore default settings
            pcall(function()
                -- Reset graphics quality
                local lighting = game:GetService("Lighting")
                lighting.GlobalShadows = true
                lighting.ShadowSoftness = 0.5
                lighting.Technology = Enum.Technology.Future
                
                -- Reset rendering
                settings().Rendering.QualityLevel = 7
                
                -- Reset terrain
                workspace.Terrain.WaterWaveSize = 0.3
                workspace.Terrain.WaterWaveSpeed = 10
                workspace.Terrain.WaterReflectance = 1
                workspace.Terrain.WaterTransparency = 0.6
                
                Utilities.Notify("Performance", "FPS Boost disabled", "speed")
            end)
        end
    end
})

-- Reduce Particles
TabMisc:CreateToggle({
    Name = "Reduce Particles",
    Description = "Disables particle effects for better performance",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            -- Disable particles
            pcall(function()
                for _, v in pairs(game:GetDescendants()) do
                    if v:IsA("ParticleEmitter") or v:IsA("Beam") or v:IsA("Trail") or v:IsA("Smoke") or v:IsA("Fire") then
                        v.Enabled = false
                    end
                end
                
                -- Connect to DescendantAdded to disable new particles
                if not Utilities.ParticleConnection then
                    Utilities.ParticleConnection = game.DescendantAdded:Connect(function(descendant)
                        if descendant:IsA("ParticleEmitter") or descendant:IsA("Beam") or descendant:IsA("Trail") or descendant:IsA("Smoke") or descendant:IsA("Fire") then
                            descendant.Enabled = false
                        end
                    end)
                end
                
                Utilities.Notify("Performance", "Particles reduced", "blur_off")
            end)
        else
            -- Enable particles again
            pcall(function()
                if Utilities.ParticleConnection then
                    Utilities.ParticleConnection:Disconnect()
                    Utilities.ParticleConnection = nil
                end
                
                Utilities.Notify("Performance", "Particles enabled", "blur_on")
            end)
        end
    end
})

-- Remove Shadows
TabMisc:CreateToggle({
    Name = "Remove Shadows",
    Description = "Disables shadows for better performance",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            pcall(function()
                game:GetService("Lighting").GlobalShadows = false
                game:GetService("Lighting").ShadowSoftness = 0
                Utilities.Notify("Performance", "Shadows disabled", "visibility_off")
            end)
        else
            pcall(function()
                game:GetService("Lighting").GlobalShadows = true
                game:GetService("Lighting").ShadowSoftness = 0.5
                Utilities.Notify("Performance", "Shadows enabled", "visibility")
            end)
        end
    end
})

TabMisc:CreateDivider()
TabMisc:CreateSection("Auto Stats Upgrade")

-- Auto Stats Configuration
local AutoStatsConfig = {
    AutoUpgradeLuck = false,
    AutoUpgradeCooldownReduction = false,
    AutoUpgradePotionDuration = false,
    AutoUpgradeBorderChance = false,
    AutoUpgradeBossChance = false,
    Connections = {}
}

-- Auto Upgrade Luck toggle
local auto_upgrade_luck_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Luck",
    Description = "Automatically upgrades your luck stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeLuck = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Luck stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeLuck then
                AutoStatsConfig.Connections.AutoUpgradeLuck:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeLuck = spawn(function()
                while AutoStatsConfig.AutoUpgradeLuck do
                    Utilities.UpgradeStat("LUCK")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Luck stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeLuck then
                AutoStatsConfig.Connections.AutoUpgradeLuck:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeLuck = nil
            end
        end
    end
}, "AutoUpgradeLuckToggle")

-- Auto Upgrade Cooldown Reduction toggle
local auto_upgrade_cooldown_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Cooldown Reduction",
    Description = "Automatically upgrades your cooldown reduction stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeCooldownReduction = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Cooldown Reduction stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeCooldownReduction then
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeCooldownReduction = spawn(function()
                while AutoStatsConfig.AutoUpgradeCooldownReduction do
                    Utilities.UpgradeStat("COOLDOWN_REDUCTION")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Cooldown Reduction stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeCooldownReduction then
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeCooldownReduction = nil
            end
        end
    end
}, "AutoUpgradeCooldownToggle")

-- Auto Upgrade Potion Duration toggle
local auto_upgrade_potion_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Potion Duration",
    Description = "Automatically upgrades your potion duration stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradePotionDuration = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Potion Duration stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradePotionDuration then
                AutoStatsConfig.Connections.AutoUpgradePotionDuration:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradePotionDuration = spawn(function()
                while AutoStatsConfig.AutoUpgradePotionDuration do
                    Utilities.UpgradeStat("POTION_DURATION")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Potion Duration stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradePotionDuration then
                AutoStatsConfig.Connections.AutoUpgradePotionDuration:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradePotionDuration = nil
            end
        end
    end
}, "AutoUpgradePotionToggle")

-- Auto Upgrade Border Chance toggle
local auto_upgrade_border_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Border Chance",
    Description = "Automatically upgrades your border chance stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeBorderChance = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Border Chance stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeBorderChance then
                AutoStatsConfig.Connections.AutoUpgradeBorderChance:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeBorderChance = spawn(function()
                while AutoStatsConfig.AutoUpgradeBorderChance do
                    Utilities.UpgradeStat("BORDER_CHANCE")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Border Chance stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeBorderChance then
                AutoStatsConfig.Connections.AutoUpgradeBorderChance:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeBorderChance = nil
            end
        end
    end
}, "AutoUpgradeBorderToggle")

-- Auto Upgrade Boss Chance toggle
local auto_upgrade_boss_toggle = TabMisc:CreateToggle({
    Name = "Auto Upgrade Boss Chance",
    Description = "Automatically upgrades your boss chance stat when points are available",
    CurrentValue = false,
    Callback = function(Value)
        AutoStatsConfig.AutoUpgradeBossChance = Value
        
        if Value then
            Utilities.Notify("Auto Stats", "Started auto upgrading Boss Chance stat", "trending_up")
            
            if AutoStatsConfig.Connections.AutoUpgradeBossChance then
                AutoStatsConfig.Connections.AutoUpgradeBossChance:Disconnect()
            end
            
            AutoStatsConfig.Connections.AutoUpgradeBossChance = spawn(function()
                while AutoStatsConfig.AutoUpgradeBossChance do
                    Utilities.UpgradeStat("BOSS_CHANCE")
                    wait(5) -- Try every 5 seconds
                end
            end)
        else
            Utilities.Notify("Auto Stats", "Stopped auto upgrading Boss Chance stat", "stop_circle")
            
            if AutoStatsConfig.Connections.AutoUpgradeBossChance then
                AutoStatsConfig.Connections.AutoUpgradeBossChance:Disconnect()
                AutoStatsConfig.Connections.AutoUpgradeBossChance = nil
            end
        end
    end
}, "AutoUpgradeBossToggle")

-- Theme and Config sections
TabSettings:BuildThemeSection()
TabSettings:BuildConfigSection()

-- Enable autoload config
Luna:LoadAutoloadConfig()

-- Remove Debug Console creation
Utilities.CreateDebugConsole = nil

-- Remove Debug Console toggle from settings
TabSettings:CreateButton({
    Name = "Toggle Debug Console",
    Description = "Show or hide the debug console",
    Callback = function()
        -- Do nothing, debug console removed
    end
})

-- Add global battle end detection loop
spawn(function()
    while true do
        wait(1)
        
        if Utilities.IsBattleEnded() then
            Utilities.DismissBattleEnd()
            
            if not AutoFarmConfig.Enabled and not AutoFarmConfig.AutoFarmAllWorldBosses and not AutoFarmConfig.AutoFarmAllEnemiesInSelectedWorlds then
                local possibleLastEnemy = nil
                
                if game.PlaceId == 9230754391 then
                    possibleLastEnemy = "eternal_dragon"
                else
                    possibleLastEnemy = AutoFarmConfig.CurrentEnemy
                end
                
                if possibleLastEnemy then
                    Utilities.MarkEnemyDefeated(possibleLastEnemy)
                end
            end
        end
    end
end)

-- Enable autoload config
Luna:LoadAutoloadConfig()

-- Add Anti-AFK function
spawn(function()
    local VirtualUser = game:GetService("VirtualUser")
    
    Utilities.GetLocalPlayer().Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new())
    end)
end)

-- Function to upgrade stats
Utilities.UpgradeStat = function(statType)
    if not statType then return end
    
    local args = {
        [1] = statType
    }
    
    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("a0d1432a-262d-4b0a-9173-ee8b1dcfb69c"):FireServer(unpack(args))
    end)
end

-- Function to buy shop items
Utilities.BuyShopItem = function(itemName, amount)
    if not itemName or not amount then return end
    
    local args = {
        [1] = itemName,
        [2] = amount
    }
    
    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("kQR"):WaitForChild("41ccb1a6-1009-4e2f-924e-1b71f8020e9b"):FireServer(unpack(args))
    end)
end

--[[
    ÄNDERUNGSPROTOKOLL - MAI 2025
    
    - Remote-Pfade von "3aA" auf "kQR" aktualisiert
    - Remote-IDs für alle Funktionen aktualisiert:
      * SummonEnemy: 8a63919a-217b-436a-9cfa-4b472d213bbb
      * Battle Tower: 1457e535-9d02-4014-9883-7618f41bed84
      * Infinite Tower (Start): 60ed7d69-2cac-467c-9695-6ab3e77159b9
      * Infinite Tower (Ende): 23fb560d-73d0-404a-8dda-bf8088b08f0a
      * Infinite Tower (Pause): 5bdb0ab8-610f-4823-9e57-4cd48a5c4eb8
      * Exploration (Deploy): 4971f60f-90ff-4142-bf88-5395122136c2
      * Exploration (Claim): e82eeec1-ca38-4f7b-bf14-4b85df674c7b
      * Shop: 41ccb1a6-1009-4e2f-924e-1b71f8020e9b
      * Stats Upgrade: a0d1432a-262d-4b0a-9173-ee8b1dcfb69c
    - Auto-Farm, Raid und Infinite Tower Funktionen angepasst
    - Unterstützung für neue Enemy IDs und Endpoints hinzugefügt
]]
